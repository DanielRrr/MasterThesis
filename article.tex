\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{dsfont}
\usepackage{mathabx}
\usepackage[all, 2cell]{xy}
\usepackage[all]{xy}
\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{defin}{Definition}
\newtheorem{ex}{Example}
\newtheorem{col}{Corollary}
\newtheorem{con}{Consequence}
\usepackage{listings} 		% for source code
\date{}
\title{Modal type theory based on the intuitionistic epistemic logic}

\begin{document}
\maketitle

\begin{abstract}
Modal intuitionistic epistemic logic IEL$^{-}$ was proposed by S.Artemov and T. Protopopescu as the formal
foundation for the intuitionistic theory of knowledge. We construct a modal simply typed lambda-calculus
which is Curry-Howard isomorphic to IEL$^{-}$ as formal theory of calculations with applicative functors in
functional programming languages like Haskell or Idris.
\end{abstract}


  % This is a comment, not shown in final output.
  % The following shows typesetting  power of LaTeX:

  \section{Introduction}

  Modal intutionistic epistemic logic IEL was proposed by S. Artemov and T. Proropopescu \cite{Artemov}. IEL
  provides the epistimology and the theory of knowledge as based on BHK-semantics of intuitionistic logic.
  IEL$^{-}$  is a variant of IEL, that corresponds to intuitionistic belief.
  Informally, ${\bf K}A$ denotes that $A$ is verified intuitionistically.

  Intuitionistic epistemic logic IEL$^{-}$ is defined by following axioms and derivation rules:

  \begin{defin} Intuitionistic epistemic logic IEL:

    1) IPC axioms;

    2) ${\bf K}(A \to B) \to ({\bf K}A \to {\bf K}B)$ (normality);

    3) $A \to {\bf K}A$ (co-reflection);

    Rule: MP.

  \end{defin}

  V. Krupski and  A. Yatmanov provided the sequential calculus for IEL and proved that this calculus is
  PSPACE-complete \cite{Krupski}.

  Functional programming languages such as Haskell \cite{Haskell}, Idris \cite{Idris}, Purescript \cite{Purs}
  Elm \cite{Elm} or Scala \cite{Scala} have special type classes\footnote{Type class in Haskell is a general interface for
  special group of datatypes.} for calculations with container types like \verb"Functor" and
  \verb"Applicative" \footnote{Reader may read more about container types in the Haskell standard library documentation\cite{Base} or in the next one textbook
  \cite{Miran}}:

  \begin{lstlisting}[language=Haskell]
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    class Functor f => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}

  By \emph{container} (or \emph{computational context}) type we mean some type-operator $f$, where $f$ is a
  ``function'' from $*$ to $*$: type operator takes a simple type (ща kind $*$) and returns another
  simple type of kind \verb"*". For more detailed description of the type system with kinds used in
  Haskell see \cite{Morten}.

Applicative functor allows to generalize the action of a functor for functions with arbitrary number of arguments, for instance:
  \begin{lstlisting}[language=Haskell]
  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
  liftA2 f x y = ((pure f) <*> x) <*> y
  \end{lstlisting}

  It's not difficult to see that modal axioms in $IEL^{-}$ and types of the methods of Applicative class in
  Haskell-like languages (which is described below) are syntactically similar and we are going to show that
  this coincidence has a non-trivial computational meaning.

  We investigate the relationship between intuitionistic epistemic logic IEL$^{-}$ and applicative programming with side-effects
  by constructing the type system (which is called $\lambda_{{\bf K}}$) which is Curry-Howard isomorphic to $IEL^{-}$.
  So we will consider ${\bf K}$-modality as an arbitrary applicative functor and we prove that obtained type system
  is sound and complete for applicative functor on cartesian closed category (using the categorical definition proposed by Paterson \cite{Cons}).

  $\lambda_{{\bf K}}$ consists of the rules for simply typed lambda-calculus and special typing rules for
  lifting types into the applicative functor ${\bf K}$. We assume that our type system will
  axiomatize the simplest case of computation with effects with one container. We provide a proof-theoretical
  view at this kind of computations in functional programming and prove strong normalization and confluence.

  \section{Typed lambda-calculus based on IEL$^{-}$}

  The first is to define the natural deduction calculus for NIEL$^{-}$ :

  \begin{defin} Natural deduction NIEL$^{-}$ for IEL$^{-}$ is an extenstion of intuitionistic natural deduction calculus
    with additional inference rules for modality:

  \begin{minipage}{0.5\textwidth}
    \begin{flushleft}
  	\begin{prooftree}
    	\AxiomC{$\Gamma \vdash A$}
    	\RightLabel{${\bf K}_I$}
    	\UnaryInfC{$\Gamma \vdash {\bf K}A$}
  \end{prooftree}
    \end{flushleft}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \begin{flushright}
  	\begin{prooftree}
    \AxiomC{$\Gamma \vdash {\bf K} A_1, \dots, \Gamma \vdash {\bf K} A_n $}
    \AxiomC{$A_1,\dots,A_n \vdash B$}
    \BinaryInfC{$\Gamma \vdash {\bf K} B$}
  	\end{prooftree}
    \end{flushright}
  \end{minipage}
  \end{defin}

The first rule allows to derive co-reflextion. The second modal rule is a counterpart of $\Box_I$
rule in natural deduction calculus for constructive K (see \cite{ModalLa}).

We will denote $\Gamma \vdash {\bf K} A_1, \dots, \Gamma \vdash {\bf K} A_n$ and $A_1,\dots,A_n \vdash B$ as $\Gamma \vdash {\bf K} \vec{A}$ and $\vec{A} \vdash B$ for brevity.

  \vspace{\baselineskip}

  \begin{lemma}
    $\Gamma \vdash_{\text{NIEL}^{-}} A \Rightarrow$ IEL$^{-} \vdash \bigwedge \Gamma \rightarrow A$.
  \end{lemma}

  \begin{proof}
Induction on the derivation.

  \vspace{\baselineskip}

Let us consider cases with modality.

\vspace{\baselineskip}

1) If $\Gamma \vdash_{\text{NIEL}^{-}} A$, then $\text{IEL}^{-} \vdash \bigwedge \Gamma \rightarrow {\bf K}A$.

$\begin{array}{lll}
(1) & \bigwedge \Gamma \rightarrow A & \text{assumption}\\
(2) & A \rightarrow {\bf K}A &\text{co-reflection}\\
(3) & (\bigwedge \Gamma \rightarrow A) \rightarrow ((A \rightarrow {\bf K}A) \rightarrow (\bigwedge \Gamma \rightarrow {\bf K}A))&\text{IPC theorem}\\
(4) & (A \rightarrow {\bf K}A) \rightarrow (\bigwedge \Gamma \rightarrow {\bf K}A) &\text{from (1), (3) and MP}\\
(5) & \bigwedge \Gamma \rightarrow {\bf K}A &\text{from (2), (4) and MP}\\
\end{array}$

\vspace{\baselineskip}

2) If $\Gamma \vdash_{\text{NIEL}^{-}} {\bf K} \vec{A}$ and $\vec{A} \vdash B$, then $\text{IEL}^{-} \vdash \bigwedge \Gamma \rightarrow {\bf K}B$.

$\begin{array}{lll}
(1) &\bigwedge \Gamma \rightarrow \bigwedge \limits_{i = 1}^{n} {\bf K} A_i & \text{assumption} \\
(2) &\bigwedge \limits_{i = 1}^{n} {\bf K} A_i \rightarrow {\bf K} \bigwedge \limits_{i = 1}^{n} A_i& \text{IEL$^{-}$ theorem} \\
(3) &\bigwedge \Gamma \rightarrow {\bf K} \bigwedge \limits_{i = 1}^{n} A_i & \text{from (1), (2) and transitivity} \\
(4) &\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B& \text{assumption} \\
(5) &(\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B) \rightarrow {\bf K} (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{co-reflection}\\
(6) &{\bf K} (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{from (4), (5) and MP} \\
(7) &{\bf K} \bigwedge \limits_{i = 1}^{n} A_i \rightarrow {\bf K} B & \text{from (6) and normality} \\
(8) &\bigwedge \Gamma \rightarrow {\bf K} B & \text{from (3), (7) and transitivity}
\end{array}$

  \end{proof}

\begin{lemma}
  $ $
  If $\text{IEL}^{-} \vdash A$, then $\text{NIEL}^{-} \vdash A$.
\end{lemma}

\begin{proof}
  Straightforward derivation of modal axioms in $\text{NIEL}^{-}$. We consider this derivation below using terms.
\end{proof}

  \vspace{\baselineskip}

  At the next step we build the typed lambda-calculus based on the NIEL$^{-}$ with implication and dijunction
by proof-assingment in rules. Obtained fragment is equivalent to IEL$^{-}$ without axioms for negation and disjunction.

  At first, we define lambda-terms and types for this lambda-calculus.

  \vspace{\baselineskip}

  \begin{defin} The set of terms:

  Let $\mathbb{V}$ be the set of variables. The set $\Lambda_{{\bf K}}$ of terms is defined by the grammar:

$\begin{array}{lll}
& \Lambda_{{\bf K}} ::= \mathbb{V} \: | \:  (\lambda \mathbb{V}.\Lambda_{{\bf K}}) \: | \: (\Lambda_{{\bf K}}\Lambda_{{\bf K}}) \: | \: (\Lambda_{{\bf K}} , \Lambda_{{\bf K}}) \: | \: (\pi_1 \Lambda_{{\bf K}}) \: | \: (\pi_2 \Lambda_{{\bf K}}) \: | & \\
& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ({\bf pure \: } \: \Lambda_{{\bf K}}) \: | \: ({\bf let \:\: pure} \:\: \mathbb{V}^{*} = \Lambda_{{\bf K}}^{*} \:\: {\bf in} \:\: \Lambda_{{\bf K}})
\end{array}$

  \end{defin}

Where $\mathbb{V}^{*}$ and $\Lambda_{{\bf K}}^{*}$ denote the set of finite sequences of variables $\bigcup \limits_{i=0}^{\infty} \mathbb{V}^i$
and the set of finite sequences of terms $\bigcup \limits_{i = 0}^{\infty} {\Lambda_{{\bf K}}}^i $. Note that the sequence of variables $\vec{x}$ and the sequence of terms $\vec{M}$ should have the same length.
Otherwise, term is not well-formed.

  \begin{defin} The set of types:

  Let $\mathbb{T}$ be the set of atomic types. The set $\mathbb{T}_{{\bf K}}$ of types with applicative
  functor ${\bf K}$ is generated by the grammar:
  \begin{equation}
    \mathbb{T}_{{\bf K}} ::= \mathbb{T} \: | \: (\mathbb{T}_{{\bf K}} \to \mathbb{T}_{{\bf K}}) \: |
    \: (\mathbb{T}_{{\bf K}} \times \mathbb{T}_{{\bf K}}) \: | \: ({\bf K}\mathbb{T}_{{\bf K}})
  \end{equation}
  \end{defin}

  Context, domain of context and range of context are defined standardly \cite{Neder}\cite{Morten}.

  Our type system is based on the Curry-style typing rules:

  \begin{defin} Modal typed lambda calculus $\lambda_{{\bf K}}$ based on NIEL$^{-}_{\land, \to}$:

    \begin{center}
    \begin{prooftree}
    \AxiomC{$ $}
    \RightLabel{\scriptsize{ax}}
    \UnaryInfC{$\Gamma , x : A \vdash x : A$}
    \end{prooftree}
    \end{center}

    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
      \AxiomC{$\Gamma, x : A \vdash M : B$}
      \RightLabel{$\rightarrow_i$}
      \UnaryInfC{$\Gamma \vdash \lambda x. M : A \to B$}
      \end{prooftree}

      \begin{prooftree}
      \AxiomC{ $\Gamma \vdash M : A$ }
      \AxiomC{ $\Gamma \vdash N : B$ }
      \RightLabel{$\times_i$}
      \BinaryInfC{$\Gamma \vdash \langle M, N \rangle : A \times B$}
      \end{prooftree}

      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : A$}
        \RightLabel{${\bf K}_I$}
        \UnaryInfC{$\Gamma \vdash {\bf pure \: } \: M : {\bf K}A $}
      \end{prooftree}
  \end{minipage}%
  \hfill
  \begin{minipage}{0.45\textwidth}
  \begin{tabular}{p{\textwidth}}
    \begin{prooftree}
    \AxiomC{$\Gamma \vdash M : A \to B$}
    \AxiomC{$\Gamma \vdash N : A$}
    \RightLabel{$\rightarrow_e$}
    \BinaryInfC{$\Gamma \vdash MN : B$}
    \end{prooftree}

    \begin{prooftree}
    \AxiomC{ $\Gamma \vdash M : A_1 \times A_2$ }
    \RightLabel{$\times_e$, $i \in \{ 1, 2 \}$}
    \UnaryInfC{$\Gamma \vdash \pi_i M : A_i$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \vec{M} : {\bf K} \vec{A}$}
      \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
      \RightLabel{$\text{let}_{{\bf K}}$}
      \BinaryInfC{$\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N : {\bf K} B$}
    \end{prooftree}
  \end{tabular}
  \end{minipage}%

  \end{defin}

  ${\bf K}_I$-typing rule is the same as $\bigcirc$-introduction in lax logic (also known as monadic
  metalanguage \cite{Lax}) and in typed lambda-calculus which is derived by proof-assignment for lax-logic
  proofs.
  ${\bf K}_I$ allows to inject an object of type $\alpha$ into the functor. ${\bf K}_I$  reflects the
  Haskell method {\bf pure} for Applicative class. It plays the same role as the {\bf return} method in Monad class.

  $\text{let}_{{\bf K}}$ is similar to the $\Box$-rule in typed lambda calculus for intuitionistic normal modal logic {\bf IK}, which is described in \cite{ModalK}.

$\Gamma \vdash \vec{M} : {\bf K} \vec{A}$ is a syntax sugar for the sequence $\Gamma \vdash M_1 : {\bf K}A_1,\dots,\Gamma \vdash M_n : {\bf K}A_n$ and $\vec{x} : \vec{A} \vdash N : B$ is a short form for $x_1 : A_1, \dots, x_n : A_n \vdash N : B$.
${\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N$ is a simultaneous local binding in $N$.
We use this short form instead of ${\bf let \: pure\:} x_1,\dots,x_n = M_1,\dots,M_n {\: \bf in \:} N$.

In fact, our calculus is the extention of typed lambda calculus for {\bf IK} by ${\bf K}_I$-rule that is appropriate to co-reflection.

  \vspace{\baselineskip}

Here are some examples of closed terms:

\begin{prooftree}
\AxiomC{$x : A \vdash x : A$}
\UnaryInfC{$x : A \vdash {\bf pure \:} x : {\bf K} A$}
\UnaryInfC{$\vdash (\lambda x. {\bf pure \: } x) : A \to {\bf K}A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$f : {\bf K} (A \to B) \vdash f : {\bf K} (A \to B)$}
\AxiomC{$x : {\bf K} A \vdash x : {\bf K} A $}
\AxiomC{$g : A \to B \vdash g : A \to B$}
\AxiomC{$y : A \vdash y : A$}
\RightLabel{$\to_e$}
\BinaryInfC{$g : A \to B, y : A \vdash g y : B$}
\RightLabel{$\text{let}_{{\bf K}}$}
\TrinaryInfC{$f : {\bf K} (A \to B), x : {\bf K} A \vdash {\bf let \: pure \:} g, y  = f, x {\: \bf in \:} g y : {\bf K} B$}
\UnaryInfC{$f : {\bf K} (A \to B) \vdash \lambda x. {\bf let \: pure\:} g, y = f, x {\: \bf in \:} g y : {\bf K} A \to {\bf K} B$}
\UnaryInfC{$\vdash \lambda f. \lambda x. {\bf let \:pure \:} g, y = f, x {\: \bf in \:} g y : {\bf K}(A \to B) \to {\bf K} A \to {\bf K} B$}
\end{prooftree}

  \vspace{\baselineskip}

  Now we define free variables and substitutions. $\beta$-reduction, multi-step $\beta$-reduction and $\beta$-equality are defined standardly:

  \begin{defin} The set $FV(M)$ of free variables for a term $M$:

  1) $FV(x) = \{ x \}$;

  2) $FV(\lambda x. M) = FV(M) \setminus \{ x\}$;

  3) $FV(M N) = FV(M) \cup FV(N);$

  4) $FV(\langle M,N \rangle) = FV(M) \cup FV(N)$;

  5) $FV(\pi_i M) \subseteq FV(M)$, $i \in \{ 1, 2\}$;

  6) $FV(\text{pure } M) = FV(M)$;

  7) $FV({\bf let \: pure} \: \vec{x} = \vec{M} \:\: {\bf in} \:\: N) = \bigcup \limits_{i = 1}^n FV(M), \text{where $n = |\vec{M}|$}$.
  \end{defin}

  \begin{defin} Substitution:

  1) $x [x := N] = N$, $x [y := N] = x$;

  2) $(M N) [x := N] = M[x := N] N [x := N]$;

  3) $(\lambda x. M) [x := N] = \lambda x. M [y := N]$, $y \in FV(M)$;

  4) $(M, N)[x := P] = (M[x := P], N [x := P])$;

  5) $(\pi_i M) [x := P] = \pi_i (M[x := P])$, $i \in \{ 1, 2\}$;

  6) $({\bf pure \: } M) [x := P] = {\bf pure \: } (M [x := P])$;

  7) $({\bf let \: pure \:}\vec{x} = \vec{M} {\: \bf in \:} N) [y := P] = {\bf let \: pure \:} \vec{x} = (\vec{M} [y := P]) {\: \bf in \:} N$.
  \end{defin}

Substitution and free variable for terms of kind ${\bf let \: pure}$ are defined similary to \cite{ModalK}.

  \begin{defin} Type substituition

    The substituition of type $C$ for type variable $B$ in type $A$ is defined inductively:

    1) $B [B := C] = B$ and $D [B := C] = D$, if $B \neq D$;

    2) $(A_1 \alpha A_2)[B := C] = (A_1[B := C]) \alpha (A_2[B := C])$, where $\alpha \in \{ \to, \times \}$;

    3) $({\bf K}A)[B := C] = {\bf K}(A [B := C])$;

    4) Let $\Gamma$ be the context, then $\Gamma [B := C] = \{ x : (A[B := C]) \: | \: x : A \in \Gamma \}$.
  \end{defin}

  \begin{defin} $\beta$-reduction and $\eta$-reduction rules for $\lambda_{{\bf K}}$.

  1) $(\lambda x. M) N \rightarrow_{\beta} M [x := N]$;

  2) $\pi_1 \langle M, N \rangle \rightarrow_{\beta} M$;

  3) $\pi_2 \langle M, N \rangle \rightarrow_{\beta} N$;

  4) $\begin{array}{llll}
  & {\bf let \: pure \:} \vec{x}, y, \vec{z} = \vec{M}, {\bf let \: pure \: } \vec{w} = \vec{N} {\: \bf in \: } Q, \vec{P} {\: in \:} R \rightarrow_{\beta} & \\
  & {\bf let \: pure \:} \vec{x}, \vec{w}, \vec{z} = \vec{M}, \vec{N}, \vec{P} {\: \bf in \: } R [y := Q]
  \end{array}$

  5) ${\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N \rightarrow_{\beta} {\bf pure \:} N [\vec{x} := \vec{M}]$

  6) ${\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M \rightarrow_{\beta} {\bf pure \:} M$, where \underline{\quad} is an empty sequence of terms.

  7) $\lambda x. f x \rightarrow_{\eta} f$;

  8) $\langle \pi_1 P, \pi_2 P \rangle \rightarrow_{\eta} P$;

  9) ${\bf let \: pure \:} x = M {\: \bf in \: } x \rightarrow_{\eta} M$;

  \end{defin}

By default we use call-by-name evaluation strategy.

This commuting relation denotes that we identify terms of kind {\bf let pure} if they are differ in the order of binding.

Now we will prove standard lemmas for contexts in type systems\footnote{We will not prove cases with
$\to$-constructor, they are proved standardly in the same lemmas for simply typed lambda calculus, for
example see \cite{Neder} \cite{Morten}. We will consider only modal cases}:

\begin{lemma} Generation for ${\bf K}_I$.

  Let $\Gamma \vdash {\bf pure \:} M : {\bf K}A$, then $\Gamma \vdash M : A$;
\end{lemma}

\begin{proof}
  Straightforwardly.
\end{proof}

\begin{lemma} Basic lemmas.

\begin{itemize}
  \item If $\Gamma \vdash M : A$ and $\Gamma \subseteq \Delta$, then $\Delta \vdash M : A$;
  \item If $\Gamma \vdash M : A$, then $\Delta \vdash M : A$, where $\Delta = \{ x_i : A_i \: | \: (x_i : A_i) \in \Gamma \: \& \: x_i \in FV(M) \}$
  \item If $\Gamma, x : A \vdash M : B$ and $\Gamma \vdash N : A$, then $\Gamma \vdash M [x := N] : B$.
  \item If $\Gamma \vdash M : A$, then $\Gamma [B := C] \vdash M : (A [B := C])$;
  \item If $\Gamma \vdash M : A$ and $\Delta$ is a permutation of $\Gamma$, then $\Delta \vdash M : A$.
\end{itemize}
\end{lemma}

\begin{proof}
  $ $

1) The derivation ends in

\begin{prooftree}
  \AxiomC{$\Gamma \vdash \vec{M} : {\bf K} \vec{A}$}
  \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
  \RightLabel{$\text{let}_{{\bf K}}$}
  \BinaryInfC{$\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N : {\bf K}B$}
\end{prooftree}

By IH $\Delta \vdash \vec{M} : {\bf K} \vec{A}$, so $\Delta \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N : {\bf K}B$.

  \vspace{\baselineskip}

2) Similary.

  \vspace{\baselineskip}

3) The derivation ends in

\begin{prooftree}
  \AxiomC{$\Gamma, z : C \vdash \vec{M} : {\bf K} \vec{A}$}
  \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
  \RightLabel{$\text{let}_{{\bf K}}$}
  \BinaryInfC{$\Gamma, z : C \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N : {\bf K}B$}
\end{prooftree}

Let $\Gamma \vdash P : C$.

By IH, $\Gamma \vdash \vec{M} [z := P] : {\bf K} \vec{A}$. So $\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} [z := P] {\: \bf in \: } N : {\bf K}B$

  \vspace{\baselineskip}

4-5) Similary.

\end{proof}

\begin{theorem} Subject reduction

  If $\Gamma \vdash M : A$ and $M \twoheadrightarrow_{\beta \eta} N$, then $\Gamma \vdash N : A$

\end{theorem}

\begin{proof}

Induction on the derivation $\Gamma \vdash M : A$ and on the generation of $\rightarrow_{\beta \eta}$.

For cases with application, abstraction and pairs see \cite{Morten} \cite{Pierce}.

1) If $\Gamma \vdash {\bf let \: pure \:} \vec{x}, y, \vec{z} = \vec{M}, {\bf let \: pure \: } \vec{w} = \vec{N} {\bf \: in \: } Q, \vec{P}  {\: \bf in \:} R : {\bf K}B$,
  then $\Gamma \vdash {\bf let \: pure \:} \vec{x}, \vec{w}, \vec{z} = \vec{M}, \vec{N}, \vec{P} \: { \bf in } \: R [y := Q] : {\bf K}B$ by rule 4).

2) Let $\Gamma \vdash {\bf let \: pure \:} x = M {\: \bf in \: } x : {\bf K}A$, then $\Gamma \vdash M : {\bf K}A$ by rule 9).

See \cite{ModalK}.

3) The derivation ends in

\begin{prooftree}
\AxiomC{$\Gamma \vdash {\bf pure \:} \vec{M} : {\bf K}\vec{A}$}
\AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
\BinaryInfC{$\Gamma \vdash {\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N : {\bf K}B$}
\end{prooftree}

So $\Gamma \vdash \vec{M} : \vec{A}$ by Lemma 4 and $\Gamma \vdash N [\vec{x} := \vec{M}] : B$ by Lemma 4, part 3.

Then we can transform this into the following derivation:

\begin{prooftree}
\AxiomC{$\Gamma \vdash N [\vec{x} := \vec{M}] : B$}
\RightLabel{${\bf K}_I$}
\UnaryInfC{$\Gamma \vdash {\bf pure \:} N [\vec{x} := \vec{M}] : {\bf K}B$}
\end{prooftree}

4) The derivation ends in

\begin{prooftree}
\AxiomC{$\vdash M : A$}
\UnaryInfC{$\vdash {\bf let \: pure \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : {\bf K} A$}
\end{prooftree}

So, if $\vdash M : A$, then $\vdash {\bf pure \:} M : {\bf K}A$.

Note that this part of the lemma works conversly too.
\end{proof}

\begin{theorem}
  $ $

  $\twoheadrightarrow_{\beta}$ is strongly normalizing;
\end{theorem}

\begin{proof}
  $ $

We modify and apply Tait's technique of logical relation for modalities. See \cite{Pierce} \cite{Troelstra}.

We treat only modal cases below.

\begin{defin} The set of strongly computable terms:
  \begin{itemize}
    \item $SC_A = \{ M : A \: | \: M \text{ is strongly normalizing} \}$ for $A \in \mathbb{T}$;
    \item $SC_{A \to B} = \{ M : A \to B \: | \: \forall N \in SC_A, M N \in SC_B \}$, for $A,B \in \mathbb{T}_{\bf K}$ for $A, B \in \mathbb{T}_{{\bf K}}$;
    \item $SC_{{\bf K}A} = \{ M : {\bf K}A \: | \: M \text{ is strongly normalizing} \}$ for $A \in \mathbb{T}$;
    \item $\forall i \in \{ 1,\dots,n\}, \prod \limits_{i = 1}^{n} SC_{{\bf K}A_i} = \{ \vec{M} = (M_1,\dots,M_n) \:\: | \:\: \forall N \in SC_{B}, FV(N) = \{ x_1,\dots,x_n\} \: \& \: \forall i, x_i \in SC_{A_i} \Rightarrow {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \:} N \in SC_{{\bf K} B}\}$
  \end{itemize}
\end{defin}

\begin{defin}
  A term $M$ is neutral, if it has one of the following forms:
  \begin{itemize}
    \item $M N$;
    \item If $M$ is neutral, then ${\bf pure \:} M$ is neutral;
    \item If $\vec{M}$ and $N$ are neutral, then ${\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: N}$ is neutral.
    $\vec{x}$ is a sequence of free variables of a term $N$.
  \end{itemize}
\end{defin}

\begin{lemma}
  $ $

\begin{itemize}
\item If $M \in SC_A$ and $A \in \mathbb{T}_{{\bf K}}$, then $M$ is strongly normalizing;
\item If $M \in SC_A$, $A \in \mathbb{T}_{{\bf K}}$ and $M \rightarrow_{\beta} N$, then $N \in SC_A$;
\item If $N$ is neutral, $N \in SC_A$. Then, if $M \rightarrow_{\beta} N$, then $M \in SC_A$;
\end{itemize}
\end{lemma}

\begin{proof}
  $ $

  By induction on the structure of $A$.

1) $A \equiv {\bf K}A$, where $A \in \mathbb{T}$.

i-ii-iii) Immediately.

    \vspace{\baselineskip}

2)

i) Suppose $\vec{M} = (M_1,\dots,M_n) \in \prod \limits_{i = 1}^{n} SC_{{\bf K}A_i}$.

Let $N \in SC_{B}$, such that $FV(N) = \{ x_1,\dots, x_n \}$ and $\forall i, x_i \in SC_{A_i}$.

So ${\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N \in SC_{{\bf K}B}$ by IH.

So $\vec{M}$ are strongly normalizing, since ${\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N$ is strongly normalizing by IH.

\vspace{\baselineskip}

ii) Let $\vec{M_1} \in \prod \limits_{i = 1}^{n} SC_{{\bf K}A_i}$ and $\vec{M_1} \rightarrow_{\beta} \vec{M_2}$.

Let $N \in SC_{B}$, such that $FV(N) = \{ x_1,\dots,x_n \}$ and $\forall i, x_i \in SC_{A_i}$.

So ${\bf let \: pure \:} \vec{x} = \vec{M_1} {\: \bf in \:} N \rightarrow_{\beta} {\bf let \: pure \:} \vec{x} = \vec{M_2} {\: \bf in \:} N$

and ${\bf let \: pure \:} \vec{x} = \vec{M_2} {\: \bf in \:} N \in SC_{{\bf K}B}$ by assumption.

So $\vec{M_2} \in \prod \limits_{i = 1}^{n} SC_{{\bf K}A_i}$.

iii) Let $M_2$ be neutral, $M_2 \in \prod \limits_{i = 1}^{n} SC_{{\bf K}A_i}$ and $M_1 \rightarrow_{\beta} M_2$.

Let $N \in SC_{B}$, , such that $FV(N) = \{ x_1,\dots,x_n \}$ and $\forall i, x_i \in SC_{A_i}$.

So ${\bf let \: pure \:} \vec{x} = \vec{M_2} {\: \bf in \:} N \in SC_{{\bf K}B}$.

Thus ${\bf let \: pure \:} \vec{x} = \vec{M_1} {\: \bf in \:} N \rightarrow_{\beta} {\bf let \: pure \:} \vec{x} = \vec{M_2} {\: \bf in \:} \in N$.

Hence ${\bf let \: pure \:} \vec{x} = \vec{M_1} {\: \bf in \:} N\in SC_{{\bf K}B}$ by IH, so $\vec{M_1} \in \prod \limits_{i = 1}^{n} SC_{{\bf K}A_i}$.
\end{proof}

\begin{lemma}
  $ $

  If $M \in SC_A$, then ${\bf pure \:} M \in SC_{{\bf K}A}$
\end{lemma}

\begin{proof}

  Induction on the structure of M.
\end{proof}

\begin{lemma}
  $ $

  Let $x_1 : A_1,\dots, x_n : A_n \vdash M : A$, then forall $i, M_i \in SC_{A_i}$. Then $M [x_1 := M_1,\dots,x_n := M_n] \in SC_A$.
\end{lemma}

\begin{proof}
  $ $

Induction on the derivation of $x_1 : A_1,\dots, x_n : A_n \vdash M : A$.

  1) The derivation ends in:

\begin{prooftree}
\AxiomC{$x_1 : A_1,\dots, x_n : A_n \vdash M : A$}
\UnaryInfC{$x_1 : A_1,\dots, x_n : A_n \vdash {\bf pure \:} M : {\bf K}A$}
\end{prooftree}

  By assumption $M [x_1 := M_1,\dots,x_n := M_n] \in SC_A$, so ${\bf pure \:} M [x_1 := M_1,\dots,x_n := M_n] \in SC_{{\bf K}A}$.

\vspace{\baselineskip}

  2) The derivation ends in:
\begin{prooftree}
  \AxiomC{$x_1 : A_1,\dots, x_n : A_n \vdash \vec{M^{'}} : {\bf K}\vec{A}$}
  \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
  \BinaryInfC{$x_1 : A_1,\dots, x_n : A_n \vdash {\bf let \: pure \:} \vec{x} = \vec{M^{'}} {\: \bf in \:} N : {\bf K}B$}
\end{prooftree}

By IH forall $i \in \{ 1,\dots,\text{length}(\vec{M^{'}}) \}$, $M_i^{'} [x_1 := M_1,\dots,x_n := M_n] \in SC_{{\bf K}A_i}$.

So ${\bf let \: pure \:} \vec{x} = \vec{M^{'}} [x_1 := M_1,\dots,x_n := M_n] {\: \bf in \:} N \in SC_{{\bf K} B}$,
otherwise we can build infinite reduction path in $\vec{M^{'}} [x_1 := M_1,\dots,x_n := M_n]$.
\end{proof}

\begin{col}

  All terms are strongly computable, therefore are strongly normalizing.
\end{col}

\end{proof}

\begin{theorem}
  $ $

  $\twoheadrightarrow_{\beta}$ is confluent.
\end{theorem}

\begin{proof}

  We modify and apply Barendregt's technique with term underlying. We will consider the grammar without constructors for pairs.

\begin{defin} The set of underlined terms.

  \begin{itemize}
    \item $x \in \mathbb{V} \Rightarrow x \in \underline{\Lambda}$;
    \item $M \in \underline{\Lambda} \Rightarrow (\lambda x. M) \in \underline{\Lambda}$;
    \item $M, N \in \underline{\Lambda} \Rightarrow (M N) \in \underline{\Lambda}$;
    \item $M \in \underline{\Lambda} \Rightarrow ({\bf pure \:} M) \in \underline{\Lambda}$;
    \item $\vec{x} \in \mathbb{V}, \vec{M}, N \in \underline{\Lambda} \Rightarrow {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \:} N \in \underline{\Lambda}$;
    \item $M, N \in \underline{\Lambda} \Rightarrow (\lambda_i x. M) N \in \underline{\Lambda}$, for all $i \in \mathbb{N}$.
  \end{itemize}
\end{defin}

\begin{defin} Subsitution for term with labelled lambda:

  $((\lambda_i x. M) N) [y := Z] = (\lambda_i x. M [y := Z]) (N [y := Z])$
\end{defin}

\begin{defin} Index erasing

  Let us define map $|.| : \underline{\Lambda} \to \Lambda$ as follows:

  \begin{itemize}
    \item $|x| = x$;
    \item $|\lambda x. M| = \lambda x. |M|$;
    \item $|M N| = |M| |N|$;
    \item $|{\bf pure \:} M| = {\bf pure \:} |M|$;
    \item $|{\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \:} N| = {\bf let \: pure \:} \vec{x} = \vec{|M|} {\: \bf in \:} |N|$;
    \item $|(\lambda_i x. M) N| = (\lambda x. |M|) |N|$
  \end{itemize}
\end{defin}

\begin{defin} Reduction rules:

\begin{itemize}
  \item $(\lambda x. M) N \rightarrow_{\underline{\beta}} M [x := N]$;
  \item $\begin{array}{llll}
  & {\bf let \: pure \:} \vec{x}, y, \vec{z} = \vec{M}, {\bf let \: pure \: } \vec{w} = \vec{N} {\bf \: in \: } Q, \vec{P} {\: in \:} R \rightarrow_{\underline{\beta}} & \\
  & {\bf let \: pure \:} \vec{x}, \vec{w}, \vec{z} = \vec{M}, \vec{N}, \vec{P} \: { \bf in } \: R [y := Q]
  \end{array}$;
  \item ${\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N \rightarrow_{\underline{\beta}} {\bf pure \:} N [\vec{x} := \vec{M}]$;
  \item ${\bf let \: pure \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M \rightarrow_{\underline{\beta}} {\bf pure \:} M$
  \item $(\lambda x_i. M) N \rightarrow_{\underline{\beta}} M [x := N]$
\end{itemize}
\end{defin}

$\twoheadrightarrow_{\underline{\beta}}$ is a reflexive-transitive closure of $\rightarrow_{\underline{\beta}}$.

\begin{defin} Indexed redex erasing:

  Let us define the next map $\phi : \underline{\Lambda} \to \Lambda$:

  \begin{itemize}
    \item $\phi(x) = x$;
    \item $\phi(\lambda x. M) = \lambda x. \phi(M)$;
    \item $\phi(M N) = \phi(M) \phi(N)$;
    \item $\phi({\bf pure \:} M) = {\bf pure \:} \phi(M)$;
    \item $\phi({\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \:} N) = {\bf let \: pure \:} \vec{x} = \vec{\phi(M)} {\: \bf in \:} \phi(N)$;
    \item $\phi((\lambda_i x. M) N) = \phi(M) [x := \phi(N)]$
  \end{itemize}
\end{defin}

\begin{ex}
  $ $

  $\phi((\lambda_i x. {\bf let \: pure \:} y = x {\: \bf in \:} x) N) = {\bf let \: pure \:} y = \phi(N) {\: \bf in \:} \phi(N)$
\end{ex}

\begin{lemma}

  $\forall \underline{M}, \underline{N} \in \underline{\Lambda} \: \forall M, N \in \Lambda, \text{if } |\underline{M}| = M, |\underline{N}| = N, \text{then}$
  \begin{itemize}
    \item If $M \twoheadrightarrow_{\beta} N$, then $\underline{M} \twoheadrightarrow_{\underline{\beta}} \underline{N}$
    \item Vice versa
  \end{itemize}
\end{lemma}

\begin{proof}

  Induction on the generation $\rightarrow_{\beta}$ and $\rightarrow_{\underline{\beta}}$ correspondently. The general statement follows from transitivity
  of multi-step reductions of both types.
\end{proof}

\begin{lemma}
  $\phi(M [x := N]) = \phi(M) [x := \phi(N)]$.
\end{lemma}

\begin{proof}
  We treat only cases with {\bf pure} and with {\bf let}. For the rest cases see \cite{Baren}.

  1)
  $ $

  $\begin{array}{lll}
  & \phi({\bf pure \:} (M [x := N])) = & \text{By the definition of $\phi$}\\
  & {\bf pure \:} (\phi(M [x := N])) = & \text{Induction hypothesis} \\
  & {\bf pure \:} (\phi(M) [x := \phi(N)]) = & \text{Substitution definition}\\
  & ({\bf pure \:} \phi (M)) [x := \phi(N)]&
  \end{array}$

  2)
  $ $

  $\begin{array}{lll}
  &\phi(({\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \:} N) [y := P]) = & \text{Substitution definition}\\
  &\phi({\bf let \: pure \:} \vec{x} = (\vec{M}[y := P]) {\: \bf in \:} N) = & \text{By the definition of $\phi$}\\
  &{\bf let \: pure \:} \vec{x} = \phi(\vec{M}[y := P]) {\: \bf in \:} \phi(N) = & \text{Induction hypothesis} \\
  &{\bf let \: pure \:} \vec{x} = (\phi(\vec{M}) [y := \phi(P)]) {\: \bf in \:} \phi(N) =& \text{Substitution definition} \\
  &({\bf let \: pure \:} \vec{x} = \phi(\vec{M}) {\: \bf in \:} \phi(N))[y := \phi(P)]
  \end{array}$

\end{proof}

\begin{lemma}
  $ $

  \begin{itemize}
  \item If $M \twoheadrightarrow_{\underline{\beta}} N$, then $\phi(M) \twoheadrightarrow_{\beta} \phi(N)$
  \item If $|M| = N$ and $\phi(M) = P$, then $N \twoheadrightarrow_{\beta} P$.
  \end{itemize}
\end{lemma}

\begin{proof}
  $ $

  i) Induction on the generation of $\twoheadrightarrow_{\underline{\beta}}$ using previous lemma.

  ii) Induction on the structure of $M$.
\end{proof}

\begin{lemma} Strip lemma.

$ $

If $M \rightarrow_{\beta} N$ and $M \twoheadrightarrow_{\beta} P$. Then there exists some term $Q$, such that
$N \twoheadrightarrow_{\beta} Q$ and $P \twoheadrightarrow_{\beta} Q$.
\end{lemma}

\begin{proof}

Proof is similar to \cite{Baren} \cite{Baren2}. We build the following diagram, which commutes by lemmas 8 and 10.

\vspace{\baselineskip}

\xymatrix{
&&& M \ar[dd]_{\beta} \ar@{->>}[rrr] &&& P \ar@{-->>}[dd]^{\beta} \\
&&&& N' \ar[ul]^{|.|} \ar[dl]_{\phi} \ar@{-->>}[rrr]^{\underline{\beta}} &&& P' \ar[ul]^{|.|} \ar[dl]_{\phi} \\
&&& N \ar@{-->>}[rrr]_{\beta} &&& Q
}
\end{proof}

\begin{col}
$ $
If $M \twoheadrightarrow_{\beta} N$ and $M \twoheadrightarrow_{\beta} P$. Then there exists some term $Q$, such that
$N \twoheadrightarrow_{\beta} Q$ and $P \twoheadrightarrow_{\beta} Q$.
\end{col}

\begin{proof}

  Unfold $M \twoheadrightarrow_{\beta} N$ as the sequence of one-step reductions and apply strip lemma on the every step.
\end{proof}

\end{proof}

\begin{theorem}
  $ $

  Normal form in call-by-name $\lambda_{{\bf K}}$ has the subformula property: if $M$ is in normal formal, then its all subterms are in normal form too.

\end{theorem}

\begin{proof}
  By induction on the structure of $M$.
  Case with ${\bf let \: pure\:} \vec{x} = \vec{M} {\: \bf in \:} N$ was considered by Kakutani \cite{ModalK} \cite{ModalK1}.

  If ${\bf pure \:} M$ is in normal form, so $M$ is in normal form and its subterms are in normal form too by hypothesis.

  Thus if ${\bf pure \:} M$ is in normal form, then all its subterms are in normal form too.
\end{proof}

\section{Categorical semantics}

\begin{defin} Lax monoidal functor

  Let $\langle \mathcal{C}, \otimes_1, \mathds{1} \rangle$ and $\langle \mathcal{D}, \otimes_2, \mathds{1}' \rangle$ are monoidal categories.

  A lax monoidal functor $\mathcal{F} : \langle \mathcal{C}, \otimes_1, \mathds{1} \rangle \to \langle \mathcal{D}, \otimes_2, \mathds{1}' \rangle$ is a functor
  $\mathcal{F} : \mathcal{C} \to \mathcal{D}$ with additional natural transformations, which satisfy the well-known conditions described in \cite{ElKelly}:

  1) $u : \mathds{1}' \to \mathcal{F}\mathds{1}$;

  2) $\ast_{A, B} : \mathcal{F}A \otimes_2 \mathcal{F}B \to \mathcal{F}(A \otimes_1 B)$.

\end{defin}

\begin{defin}

Strong endofunctor on a monoidal category is a with a natural transformation so called tensorial strength

\begin{equation}
  \tau_{A, B} : A \otimes \mathcal{K}B \rightarrow \mathcal{K}(A \otimes B)
\end{equation}

making two diagrams commute:

\xymatrix{
(A \otimes B) \otimes \mathcal{K}C \ar[d]_{\alpha_{A, B, \mathcal{K}C}}\ar[rrrr]^{\tau_{A \otimes B, C}} &&&& \mathcal{K}((A \otimes B) \otimes C) \ar[d]^{\mathcal{K}(\alpha_{A,B,C})}\\
A \otimes (B \otimes \mathcal{K}C) \ar[rr]_{id_A \otimes \tau_{B,C}} && A \otimes \mathcal{K}(B \otimes C) \ar[rr]_{\quad \tau_{A, (B \otimes C)}} && \mathcal{K}(A \otimes (B \otimes C)) \\
}

\xymatrix{
&&& \mathds{1} \otimes \mathcal{K}A \ar[drr]_{\rho_{\mathcal{K}A}} \ar[rr]^{\mu_{\mathds{1}, A}} && \mathcal{K}(\mathds{1} \otimes A) \ar[d]^{\mathcal{K}(\rho_A)}\\
&&&&& \mathcal{K}A
}
\end{defin}

\begin{defin} Applicative functor

  An applicative functor is a triple $\langle \mathcal{C}, \mathcal{K}, \eta \rangle$,
where $\mathcal{C}$ is a monoidal category, $\mathcal{K}$ is a strong lax monoidal endofunctor and $\eta : Id_{\mathcal{C}} \Rightarrow \mathcal{K}$ is a natural transformation (similar to unit in monad), such that:

1) $u = \eta_{\mathds{1}}$;

2) $\ast_{A,B} \circ (\eta_A \otimes \eta_B) = \eta_{A \otimes B}$, i.e. the following diagram commutes:

\xymatrix
{
&&& A \otimes B \ar[rr]^{\eta_A \otimes \eta_B} \ar[drr]_{\eta_{A \otimes B}} && \mathcal{K}A \otimes \mathcal{K}B \ar[d]^{\ast_{A,B}} \\
&&&&& \mathcal{K}(A \otimes B)
}

3) $\tau_{A, B} = \ast_{A, B} \circ \eta_{A} \otimes id_{\mathcal{K}B}$.
\end{defin}

By default we will consider a strong functor on cartesian closed category with $\eta$ \cite{Cons}.

\subsection{Soundness and completeness}

\begin{theorem} Soundness

  Let $\Gamma \vdash M : A$ and $M =_{\beta\eta} N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$
\end{theorem}

\begin{proof}

\begin{defin} Semantical translation from $\lambda_{{\bf K}}$ to some cartesian closed category $\mathcal{C}$ with applicative functor $\mathcal{K}$:

1) Interpretation for types:

$[\![A]\!] := \hat{A}, A \in \mathbb{T}$, where $\hat{A}$ is an object of $\mathcal{C}$ obtained by some given assignment;

$[\![A \to B]\!] := [\![B]\!]^{[\![A]\!]}$;

$[\![A \times B]\!] := [\![A]\!] \times [\![B]\!]$.

2) Interpretation for modal types: $[\![{\bf K}A]\!] = \mathcal{K}[\![A]\!]$;

3) Interpretaion for contexts:

$[\![\Gamma = \{ x_1 : A_1, ..., x_n : A_n\}]\!] := [\![\Gamma]\!] = [\![A_1]\!] \times ... \times [\![A_n]\!]$;

4) Interpretation for typing assignment: $[\![\Gamma \vdash M : A]\!] := [\![M]\!] : [\![\Gamma]\!] \to
[\![A]\!]$.

5) Interpretation for typing rules:

\begin{prooftree}
\AxiomC{$ $}
\UnaryInfC{$[\![\Gamma, x : A \vdash x : A]\!] = \pi_2 : [\![\Gamma]\!] \times [\![A]\!] \rightarrow
[\![A]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma, x : A \vdash M : B]\!] = f : [\![\Gamma]\!] \times [\![A]\!] \rightarrow [\![B]\!]$}
\UnaryInfC{$[\![\Gamma \vdash (\lambda x. M) : A \to B]\!] = \Lambda(f) : [\![\Gamma]\!]
\rightarrow[\![B]\!]^{[\![A]\!]}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A \to B]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![B]\!]^{[\![A]\!]}$}
\AxiomC{$[\![\Gamma \vdash N : A]\!] = [\![N]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M N) : B]\!] = [\![\Gamma]\!] \xrightarrow{\langle [\![M]\!], [\![N]\!]
\rangle} [\![B]\!]^{[\![A]\!]} \times [\![A]\!] \xrightarrow{\epsilon} [\![B]\!] $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A ]\!] = f : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\AxiomC{$[\![\Gamma \vdash N : B ]\!] = g : [\![\Gamma]\!] \rightarrow [\![B]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M, N) : A \times B]\!] = \langle f, g \rangle : [\![\Gamma]\!] \rightarrow
[\![A]\!] \times [\![B]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash p : A_1 \times A_2]\!] = f : [\![\Gamma]\!] \rightarrow [\![A_1]\!] \times
[\![A_2]\!]$}
\RightLabel{$i \in \{1,2\}$}
\UnaryInfC{$[\![\Gamma \vdash \pi_i p : A_i]\!] = [\![\Gamma]\!] \xrightarrow{f} [\![A_1]\!] \times
[\![A_2]\!] \xrightarrow{\pi_i} [\![A_i]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\UnaryInfC{$[\![\Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] := [\![\Gamma]\!] \xrightarrow{[\![M]\!]}
[\![A]\!] \xrightarrow{\eta_{[\![A]\!]}} \mathcal{K}[\![A]\!]$}
\end{prooftree}

  \begin{prooftree}
    \AxiomC{$[\![\Gamma \vdash \vec{M} : {\bf K} \vec{A}]\!] = \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \prod \limits_{i=1}^n \mathcal{K}[\![A_i]\!]$}
    \AxiomC{$[\![\vec{x} : \vec{A} \vdash N : B]\!] = [\![N]\!] : \prod \limits_{i=1}^n [\![A_i]\!] \rightarrow [\![B]\!]$}
    \BinaryInfC{$[\![\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } M : {\bf K} B]\!] = \mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \mathcal{K}[\![B]\!]$}
  \end{prooftree}

\end{defin}

\begin{defin} Simultaneous substitution

Let $\Gamma = \{ x_1 : A_1, ..., x_n : A_n \}$, $\Gamma \vdash M : A$ and for all $i \in \{ 1,..., n \}$,
$\Gamma \vdash M_i : A_i$.

We define simultaneous substitution $M [ \vec{x} := \vec{M}]$ recursively by:

1) $x_i [ \vec{x} := \vec{M}] = M_i $;

2) $(\lambda x. M) [ \vec{x} := \vec{M}] = \lambda x. (M [ \vec{x} := \vec{M}])$;

3) $(M N) [ \vec{x} := \vec{M}] = (M [ \vec{x} = \vec{M}]) (N [ \vec{x} := \vec{M}])$;

4) $\langle M, N \rangle = \langle (M [ \vec{x} = \vec{M}]), (N [ \vec{x} := \vec{M}])\rangle$;

5) $(\pi_i P) [ \vec{x} := \vec{M}] = \pi_i (P [ \vec{x} = \vec{M}])$;

6) $({\bf pure \:} M) [ \vec{x} := \vec{M}] = {\bf pure \:} (M [ \vec{x} = \vec{M}])$;

7) $({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] =
{\bf let \: pure} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N$

\end{defin}

\begin{lemma}
$ $

$[\![M [x_1 := M_1,\dots, x_n := M_n]]\!] = [\![M]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle$.

\end{lemma}

\begin{proof}

$ $

1) $[\![\Gamma \vdash ({\bf pure \:} M) [ \vec{x} := \vec{M}] : {\bf K}A ]\!] = [\![ \Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle$.

\vspace{\baselineskip}

$\begin{array}{lll}
& [\![\Gamma \vdash ({\bf pure \:} M) [ \vec{x} := \vec{M}] : {\bf K}A]\!] = [\![ \Gamma \vdash {\bf pure \:} (M [ \vec{x} := \vec{M}]) : {\bf K}A]\!] &
\text{Substitution definition} \\
& \quad\quad\quad\quad\quad\quad\quad = \eta_{[\![A]\!]} \circ [\![(M [ \vec{x} := \vec{M}])]\!]&
\text{Translation for pure}\\
& \quad\quad\quad\quad\quad\quad\quad = \eta_{[\![A]\!]} \circ ([\![M]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle) & \text{Induction hypothesis} \\
& \quad\quad\quad\quad\quad\quad\quad = (\eta_{[\![A]\!]} \circ [\![M]\!]) \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle & \text{Associativity of composition}\\
& \quad\quad\quad\quad\quad\quad\quad = [\![ \Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle& \text{Translation for pure}\\
\end{array}$

\vspace{\baselineskip}

2) $\begin{array}{lll}&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : {\bf K} B]\!]
=[\![\Gamma \vdash {\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N : {\bf K}B]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle& \end{array}$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : {\bf K} B]\!] =& \text{Substitution definition}\\
&[\![\Gamma \vdash {\bf let \: pure} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N : {\bf K}B]\!] =& \text{Interpretaion for $let_{\bf K}$} \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ [\![\Gamma \vdash (\vec{M} [\vec{y} := \vec{P}]) : {\bf K}\vec{A}]\!] =& \text{Induction hypothesis} \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ ([\![\vec{M}]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle) = & \text{Associativity of composition} \\
&(\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ [\![\vec{M}]\!]) \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle = & \text{By interpretation} \\
&[\![\Gamma \vdash {\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N : {\bf K}B]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle&
\end{array}$

\end{proof}

\begin{lemma}
  $ $

  Let $\Gamma \vdash M : A$ and $M \twoheadrightarrow_{\beta \eta} N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$;
\end{lemma}

\begin{proof}
  $ $

Cases with $\beta$-reductions for $let_{\bf K}$ are shown in \cite{ModalK1}. Let us consider cases with ${\bf pure}$.

\vspace{\baselineskip}

1) $[\![\Gamma \vdash {\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N : {\bf K}B]\!] = [\![\Gamma \vdash {\bf pure \:} N [\vec{x} := \vec{M}] : {\bf K}B]\!]$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N : {\bf K}B]\!] = & \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By interpretation}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ \langle \eta_{[\![A_1]\!]} \circ [\![M_1]\!],\dots,\eta_{[\![A_n]\!]} \circ [\![M_n]\!] \rangle = \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By the property of a pair of morphisms}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ (\eta_{[\![A_1]\!]} \times \dots \times \eta_{[\![A_n]\!]}) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]\rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Associativity of composition}& \\
&\mathcal{K}([\![N]\!]) \circ (\ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ (\eta_{[\![A_1]\!]} \times \dots \eta_{[\![A_n]\!]})) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By the definition of an applicative functor}& \\
&\mathcal{K}([\![N]\!]) \circ \eta_{[\![A_1]\!] \times \dots \times [\![A_n]\!]} \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Naturality of $\eta$}& \\
&\eta_{[\![B]\!]} \circ [\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Associativity of composition}& \\
&\eta_{[\![B]\!]} \circ ([\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]) \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Simultaneous substitution lemma}& \\
&\eta_{[\![B]\!]} \circ [\![N [\vec{x} := \vec{M}]]\!]& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By interpetation}& \\
&[\![\Gamma \vdash {\bf pure \:} (N [\vec{x} := \vec{M}]) : {\bf K}B]\!]&
\end{array}$

\vspace{\baselineskip}

2) $[\![\vdash {\bf let \: pure \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : {\bf K} A]\!] = [\![\vdash {\bf pure \:} M : {\bf K} A]\!]$

$\begin{array}{lll}
&[\![\vdash {\bf let \: pure \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : {\bf K} A]\!] = & \text{By interpretation} \\
&\mathcal{K}([\![M]\!]) \circ u_{\mathds{1}} = & \text{By the definition of an applicative functor} \\
&\mathcal{K}([\![M]\!]) \circ \eta_{\mathds{1}} = & \text{By naturality of $\eta$} \\
&\eta_{[\![A]\!]} \circ [\![M]\!] = & \text{By interpretation} \\
&[\![\vdash {\bf pure \:} M : {\bf K} A]\!]&
\end{array}$
\end{proof}

\end{proof}

\begin{theorem} Completeness

Let $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$, then $M =_{\beta \eta} N$.
\end{theorem}

\begin{proof}

$ $

We will consider term model for simply typed lambda calculus $\times$ and $\to$ standardly described in \cite{LambekScott}:

\begin{defin} Equivalence on term pairs:
  $ $

  Let us define relation $\sim_{A, B} \subseteq \mathbb{V} \times \Lambda_{{\bf K}}$, such that:

  $(x, M) \sim_{A, B} (y, N) \Leftrightarrow x : A \vdash M : B \:\: \& \:\: y : A \vdash N : A \:\: \& \:\: M =_{\beta \eta} N [y := x]$;
\end{defin}

We will denote equivalence class as $[x, M]_{A, B} = \{ (y, N) \: | \: (x, M) \sim_{A, B} (y, N) \}$ (we will drop indices below).


\begin{defin} Category $\mathcal{C}(\lambda)$:
\begin{itemize}
  \item $Ob_{\mathcal{C}} = \{ \hat{A} \: | \: A \in \mathbb{T} \} \cup \{ \mathds{1} \}$;
  \item $Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B}) = (\mathbb{V} \times \Lambda_{{\bf K}})/_{\sim_{A, B}}$;
  \item Let $[x, M] \in Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B})$ and $[y,N] \in Hom_{\mathcal{C}(\lambda)}(\hat{B},\hat{C})$, then $[y,M] \circ [x, M] = [x, N [y := M]]$;
  \item Identity morphism $id_{\hat{A}} = [x,x] \in Hom_{\mathcal{C}(\lambda)(\hat{A})}$;
  \item $\mathds{1}$ is a terminal object;
  \item $\widehat{A \times B} = \hat{A} \times \hat{B}$;
  \item Canonical projection is defined as $[x, \pi_i x] \in Hom_{\mathcal{C}(\lambda)}(\hat{A_1} \times \hat{A_2},\hat{A_i})$ for $i \in \{ 1, 2 \}$;
  \item $\widehat{A \to B} = \hat{B}^{\hat{A}}$;
  \item Evaluation arrow $\epsilon = [x, (\pi_2 x) (\pi_1 x)] \in Hom_{\mathcal{C}(\lambda)(\hat{B}^{\hat{A}} \times \hat{A}, \hat{B})}$.
\end{itemize}
\end{defin}

It is sufficient to show ${\bf K}$ is an applicative functor on $\mathcal{C}(\lambda)$.

\begin{defin}
  Let us define an endofunctor $\mathcal{K} : \mathcal{C}(\lambda) \to \mathcal{C}(\lambda)$, such that
forall $[x,M] \in Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B}), {\bf K}([x,M]) = [y, {\bf let \: pure \:} x = y {\: \bf in \:} M] \in Hom_{\mathcal{C}(\lambda)}({\bf K} \hat{A}, {\bf K} \hat{B})$ (denotation: $\text{fmap } f$ for an arbitrary arrow $f$).

\end{defin}

\begin{lemma} Functoriality

\begin{itemize}
  \item $\text{fmap }(g \circ f) = \text{fmap }(g) \circ \text{fmap }(f)$;
  \item $\text{fmap }(id_{\hat{A}}) = id_{{\bf K}\hat{A}}$.
\end{itemize}
\end{lemma}

\begin{proof}

Easy checking using reduction rules.

\end{proof}

\begin{defin}

  Let us define natural transformations:

  1) $\eta:Id \Rightarrow \mathcal{K}$, s. t. $\forall \hat{A} \in Ob_{\mathcal{C}(\lambda)}$, $\eta_{\hat{A}} = [x, {\bf pure \:} x] \in Hom_{\mathcal{C}(\lambda)}(\hat{A}, {\bf K}\hat{A})$;

  2) $\ast_{A,B}:{\bf K}\hat{A} \times {\bf K}\hat{B} \to {\bf K}(\hat{A} \times \hat{B})$, s. t. $\forall \hat{A}, \hat{B} \in Ob_{\mathcal{C}(\lambda)}, \ast_{\hat{A},\hat{B}} = [p, {\bf let \: pure \:} x,y = \pi_1 p, \pi_2 p {\: \bf in \:} \langle x, y \rangle] \in Hom_{\mathcal{C}(\lambda)}({\bf K}A \times {\bf K}B, {\bf K}(A \times B))$.
\end{defin}

Implementation for $\ast$ in our term model is a modification of ${\text{let}_{\bf K}}$-rule:

\begin{prooftree}
\AxiomC{$p : {\bf K}A \times {\bf K}B \vdash p : {\bf K}A \times {\bf K}B$}
\UnaryInfC{$p : {\bf K}A \times {\bf K}B \vdash \pi_1 p : {\bf K} A$}
\AxiomC{$p : {\bf K}A \times {\bf K}B \vdash p : {\bf K}A \times {\bf K}B$}
\UnaryInfC{$p : {\bf K}A \times {\bf K}B \vdash \pi_2 p : {\bf K} B$}
\AxiomC{$x : A \vdash x : A$}
\AxiomC{$y : B \vdash y : B$}
\BinaryInfC{$x : A, y : B \vdash \langle x, y \rangle : A \times B$}
\TrinaryInfC{$p : {\bf K}A \times {\bf K}B \vdash {\bf let \: pure \:} x,y = \pi_1 p, \pi_2 p {\: \bf in \:} \langle x, y \rangle : {\bf K}(A \times B)$}
\end{prooftree}

\begin{lemma}
  $ $

  {\bf K} is a monoidal endofunctor
\end{lemma}

\begin{proof}
$ $

See \cite{ModalK}
\end{proof}

\begin{lemma} Properties of $\eta$:

\begin{itemize}
  \item $\text{fmap } f \circ \eta_A = \eta_B \circ f$;
  \item $\ast_{\hat{A},\hat{B}} \circ (\eta_{A} \times \eta_{B}) = \eta_{\hat{A} \times \hat{B}}$;
\end{itemize}
\end{lemma}

\begin{proof}
  $ $

  i) $\text{fmap } f \circ \eta_{\hat{A}} = \eta_{\hat{B}} \circ f$

\vspace{\baselineskip}

$\begin{array}{lll}
&\eta_{\hat{B}} \circ f = & \text{By the definition} \\
&[y, {\bf pure \:} y] \circ [x, M] = & \text{By the definition of composition}\\
&[x, {\bf pure \:} y [y := M]] = & \text{By substitution}\\
&[x, {\bf pure \:} M]& \\
& &\\
&\text{On the other hand:}& \\
&\text{fmap } f \circ \eta_{\hat{A}} = & \text{By the definiton} \\
&[z, {\bf let \: pure \:} x = z {\: \bf in \:} M] \circ [x, {\bf pure \: x}] = & \text{By the definition of composition}\\
&[x, {\bf let \: pure \:} x = z {\: \bf in \:} M [z := {\bf pure \:} x]] = & \text{By substitution} \\
&[x, {\bf let \: pure \:} x = {\bf pure \:} x {\: \bf in \:} M] = & \text{$\beta$-reduction rule}\\
&[x, {\bf pure \:} M [x := x]] = & \text{By substitution}\\
&[x, {\bf pure \:} M]&
\end{array}$

\vspace{\baselineskip}

ii) $\ast_{\hat{A},\hat{B}} \circ (\eta_{\hat{A}} \times \eta_{\hat{B}}) = \eta_{\hat{A} \times \hat{B}}$

\vspace{\baselineskip}

$\begin{array}{lll}
& \ast_{\hat{A},\hat{B}} \circ (\eta_{\hat{A}} \times \eta_{\hat{B}}) = & \\
& \text{By unfolding} & \\
& [q, {\bf let \: pure \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle] \circ [p, \langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle] = & \\
& \text{Composition}& \\
& [p, {\bf let \: pure \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle [q := \langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle]] = & \\
& \text{By substitution}& \\
& [p, {\bf let \: pure \:} x, y = \pi_1 (\langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle), \pi_2 (\langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle) {\: \bf in \:} \langle x, y \rangle] = & \\
& \text{Reduction rules}& \\
& [p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) {\: \bf in \:} \langle x, y \rangle] = & \\
& \text{Reduction rule}& \\
& [p, {\bf pure \:} (\langle x,y \rangle [x := \pi_1 p, y := \pi_2 p])] = & \\
& \text{Substitution}& \\
& [p, {\bf pure \:} \langle \pi_1 p, \pi_2 p \rangle] = & \\
& \text{$\eta$-reduction}& \\
& [p, {\bf pure \:} p] =& \\
& \text{By definition}& \\
& \eta_{\hat{A} \times \hat{B}}&
\end{array}$

\end{proof}

\begin{defin}
  $ $

  $u_{\mathds{1}} = [\sqbullet, {\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} \sqbullet] \in Hom_{\mathcal{C}(\lambda)}(\mathds{1}, {\bf K}\mathds{1})$.
\end{defin}

\begin{lemma}
  $ $

  $u_{\mathds{1}} = \eta_{\mathds{1}}$

\end{lemma}

\begin{proof}

  Immediately.
\end{proof}

  Tensorial strength is defined as follows:

\begin{defin} Tensorial strength
  $ $

  Let $[p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle] \in Hom_{\mathcal{C}(\lambda)}(\hat{A} \times {\bf K}\hat{B}, {\bf K}\hat{A} \times {\bf K}\hat{B})$.

  So tensorial strength is defined as $\tau_{\hat{A}, \hat{B}} = \ast_{\hat{A}, \hat{B}} \circ [p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle]$.
\end{defin}

It is clearly that tensorial strength defined above can be simplified as follows:

$\begin{array}{lll}
&\ast_{\hat{A}, \hat{B}} \circ [p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle] = & \text{By definition} \\
&[p^{'}, {\bf let \: pure \:} x, y = \pi_1 p^{'}, \pi_2 p^{'} {\: \bf in \:} \langle x, y \rangle] \circ [p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle] = & \text{By composition} \\
&[p, {\bf let \: pure \:} x, y = \pi_1 p^{'}, \pi_2 p^{'} {\: \bf in \:} \langle x, y \rangle [p^{'} := \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle]] = & \text{By substitution} \\
&[p, {\bf let \: pure \:} x, y = \pi_1 (\langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle), \pi_2 (\langle \pi_1 p, {\bf pure \:} (\pi_2 p) \rangle) {\: \bf in \:} \langle x, y \rangle] = & \text{By $\beta$-reduction rules} \\
&[p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle x, y \rangle]&
\end{array}$

\begin{lemma} Coherence for tensorial strength

  \begin{itemize}
    \item $\text{fmap } \alpha_{\hat{A},\hat{B},\hat{C}} \circ \tau_{\hat{A} \times \hat{B}, \hat{C}} = \tau_{\hat{A}, \hat{B} \times \hat{C}} \circ (id_{\hat{A}} \times \tau_{\hat{B}, \hat{C}}) \circ \alpha_{\hat{A}, \hat{B}, {\bf K}\hat{C}}$;
    \item ${\bf K}(\rho_{\hat{A}}) \circ \tau_{\mathds{1}, \hat{A}} = \rho_{{\bf K}\hat{A}}$.
  \end{itemize}
  where $\alpha_{\hat{A},\hat{B},\hat{C}} = [p, \langle \pi_1 (\pi_1 p), \langle \pi_1 (\pi_2 p), \pi_2 p \rangle \rangle]$ and
  $\rho = \pi_2$.
\end{lemma}

\begin{proof}
  $ $

Simple, but routine checking.
\end{proof}

\begin{lemma}

  {\bf K} is an applicative functor
\end{lemma}

\begin{proof}
  Immediately follows from previous lemmas in the section.
\end{proof}

Similar to \cite{Abramsky}, we apply the translation from $\lambda_{{\bf K}}$ to some cartesian closed category with an abritraty applicative functor $\mathcal{K}$, then
we have $[\![\Gamma \vdash M : A]\!] = [x, M [x_i := \pi_i x]]$, so $M =_{\beta \eta} N \Leftrightarrow [\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$.

\end{proof}


  \addcontentsline{toc}{section}{References}

  \begin{thebibliography}{}

  \bibitem{Artemov} Artemov S. and Protopopescu T., \/ ``Intuitionistic Epistemic Logic'', \textit{The
  Review of Symbolic Logic}, 2016, vol. 9, no 2. pp. 266-298.\parskip=1mm

  \bibitem{Krupski} Krupski V. N. and Yatmanov A., \/ ``Sequent Calculus for Intuitionistic Epistemic Logic
  IEL'', \textit{Logical Foundations of Computer Science: International Symposium, LFCS 2016, Deerfield
  Beach, FL, USA, January 4-7, 2016. Proceedings}, 2016, pp. 187-201.\parskip=1mm

  \bibitem{Haskell} Haskell Language. // URL: https://www.haskell.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Idris} Idris. A Language with Dependent Types.// URL:https://www.idris-lang.org. (Date:
  1.08.2017) \parskip=1mm

  \bibitem{Purs} Purescript. A strongly-typed functional programming language that compiles to JavaScript.
  URL: http://www.purescript.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Elm} Elm. A delightful language for reliable webapps. // URL: http://elm-lang.org. (Date:
  1.08.2017) \parskip=1mm

  \bibitem{Base} Hackage, \/ ``The base package'' // URL: https://hackage.haskell.org/package/base-4.10.0.0
  (Date: 1.08.2017) \parskip=1mm

  \bibitem{Miran} Lipovaca M, \/ ``Learn you a Haskell for Great Good!''. //URL:
  http://learnyouahaskell.com/chapters (Date: 1.08.2017) \parskip=1mm

  \bibitem{McP} McBride C. and Paterson R., ``Applicative programming with effects", \textit{Journal of
  Functional Programming}, 2008, vol. 18, no 01. pp 1-13. \parskip=1mm

  \bibitem{McP2} McBride C. and Paterson R, ``Functional Pearl. Idioms: applicative programming with
  effects'', \textit{Journal of Functional Programming}, 2005. vol. 18, no 01. pp 1-20. \parskip=1mm

  \bibitem{Neder} R. Nederpelt and H. Geuvers, ``Type Theory and Formal Proof: An Introduction''.
  \textit{Cambridge University Press}, New York, NY, USA, 2014. pp. 436. \parskip=1mm

  \bibitem{Morten} Sorensen M. H. and Urzyczyn P, ``Lectures on the Curry-Howard isomorphism'',
  \textit{Studies in Logic and the Foundations of Mathematics}, vol. 149, \textit{Elsevier Science}, 1998.
  pp 261. \parskip=1mm

  \bibitem{Pierce} Pierce B. C., ``Types and Programming Languages''. \textit{Cambridge, Mass: The MIT
  Press}, 2002. pp. 605. \parskip=1mm

  \bibitem{Girard} Girard J.-Y., Taylor P. and  Lafont Y, ``Proofs and Types'', \textit{Cambridge University
  Press}, New York, NY, USA, 1989. pp. 175. \parskip=1mm

  \bibitem{Baren} Barendregt. H. P., ``Lambda calculi with types" // Abramsky S., Gabbay Dov M., and S. E.
  Maibaum, ``Handbook of logic in computer science (vol. 2), Osborne Handbooks Of Logic In Computer
  Science'', Vol. 2. \textit{Oxford University Press, Inc.}, New York, NY, USA, 1993. pp 117-309.
  \parskip=1mm

  \bibitem{Hindley} Hindley J. Roger, ``Basic Simple Type Theory''. \textit{Cambridge University Press}, New
  York, NY, USA, 1997. pp. 185. \parskip=1mm

  \bibitem{Lax} Pfenning F. and Davies R., ``A judgmental reconstruction of modal logic'',
  \textit{Mathematical Structures in Computer Science}, vol. 11, no 4, 2001, pp. 511-540. \parskip=1mm

  \bibitem{Baren2} H.P. Barendregt. The Lambda Calculus --- Its Syntax and Semantics. Studies in Logic and
  the Foundations of Mathematics, vol. 103. Amsterdam: North-Holland, 1985.

  \bibitem{ModalK} Yoshihiko KAKUTANI, A Curry-Howard Correspondence for Intuitionistic Normal Modal Logic, Computer Software, Released February 29, 2008, Online ISSN , Print ISSN 0289-6540.

  \bibitem{ModalK1} Kakutani Y. (2007) Call-by-Name and Call-by-Value in Normal Modal Logic. In: Shao Z. (eds) Programming Languages and Systems. APLAS 2007. Lecture Notes in Computer Science, vol 4807. Springer, Berlin, Heidelberg

  \bibitem{Abe} T. Abe. Completeness of modal proofs in first-order predicate logic. Computer Software, JSSST Journal, 24:165 -- 177, 2007.

  \bibitem{LambekScott} Lambek, J. and Scott P.J. (1986) Introduction to Higher Order Categorical Logic, Cambridge Studies in Advanced Mathematics 7, Cambridge: Cambridge University Press.

  \bibitem{ElKelly} Samuel Eilenberg and Max Kelly, Closed categories. Proc. Conf. Categorical Algebra (La Jolla, Calif., 1965).

  \bibitem{Abramsky} Samson Abramsky and Nikos Tzevelekos, Introduction to Categories and Categorical Logic

  \bibitem{ModalLa} G. A. Kavvos. The Many Worlds of Modal $\Lambda$--calculi: I. Curry-Howard for Necessity, Possibility and Time

  \bibitem{Cons} Ross Paterson. in Mathematics of Program Construction, Madrid, 2012, Lecture Notes in Computer Science, vol. 7342, pp. 300--323, Springer, 2012.
\end{thebibliography}

\end{document}
