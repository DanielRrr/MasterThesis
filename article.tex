\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{dsfont}
\usepackage[all, 2cell]{xy}
\usepackage[all]{xy}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{defin}{Definition}
\newtheorem{ex}{Example}
\newtheorem{col}{Corollary}
\newtheorem{con}{Consequence}
\usepackage{listings} 		% for source code
\date{}
\title{Modal type theory based on the intuitionistic epistemic logic}

\begin{document}
\maketitle

\begin{abstract}
Modal intuitionistic epistemic logic IEL$^{-}$ was proposed by S.Artemov and T. Protopopescu as the formal
foundation for the intuitionistic theory of knowledge. We construct a modal simply typed lambda-calculus
which is Curry-Howard isomorphic to IEL$^{-}$ as formal theory of calculations with applicative functors in
functional programming languages like Haskell or Idris. We prove that this typed lambda-calculus has the
strong normalization and Church-Rosser properties.
\end{abstract}


  % This is a comment, not shown in final output.
  % The following shows typesetting  power of LaTeX:

  \section{Introduction}

  Modal intutionistic epistemic logic IEL was proposed by S. Artemov and T. Proropopescu \cite{Artemov}. IEL
  provides the epistimology and the theory of knowledge as based on BHK-semantics of intuitionistic logic.
  IEL$^{-}$  is a variant of IEL, that corresponds to intuitionistic belief.
  Informally, ${\bf K}A$ denotes that $A$ is verified intuitionistically.

  Intuitionistic epistemic logic IEL$^{-}$ is defined with by following axioms and derivation rules:

  \begin{defin} Intuitionistic epistemic logic IEL:

    1) IPC axioms;

    2) ${\bf K}(A \to B) \to ({\bf K}A \to {\bf K}B)$ (normality);

    3) $A \to {\bf K}A$ (co-reflection);

    Rule: MP.

  \end{defin}

  We have the deduction theorem and necessitation rule which is derivable.

  V. Krupski and  A. Yatmanov provided the sequential calculus for IEL and proved that this calculus is
  PSPACE-complete \cite{Krupski}.

  It's not difficult to see that modal axioms in $IEL^{-}$ and types of the methods of Applicative class in
  Haskell-like languages (which is described below) are syntactically similar and we are going to show that
  this coincidence has a
  non-trivial computational meaning.

  Functional programming languages such as Haskell \cite{Haskell}, Idris \cite{Idris}, Purescript \cite{Purs}
  or Elm \cite{Elm} have special type classes\footnote{Type class in Haskell is a general interface for
  special group of datatypes.} for calculations with container types like \verb"Functor" and
  \verb"Applicative" \footnote{Reader may read more about container types in the Haskell standard library documentation\cite{Base} or in the next one textbook
  \cite{Miran}}:

  \begin{lstlisting}[language=Haskell]
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    class Functor f => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}

  By \emph{container} (or \emph{computational context}) type we mean some type-operator $f$, where $f$ is a
  ``function'' from $*$ to $*$: type operator takes a simple type (which has kind $*$) and returns another
  simple type type with kind \verb"*". For more detailed description of the type system with kinds used in
  Haskell see \cite{Morten}.


  The main goal of our research is a relationship between intuitionistic epistemic logic $IEL^{-}$ and
  functional programming with effects. We show that relationship by building the type system (which is called $\lambda_{\textbf{K}}$) which is Curry-Howard isomorphic to $IEL^{-}$. So we will consider $\textbf{K}$-modality as an arbitrary applicative functor.

  $\lambda_{{\bf K}}$ consists of the rules for simply typed lambda-calculus and special typing rules for
  lifting types into the applicative functor $\textbf{K}$. We assume that our type system will
  axiomatize the simplest case of computation with effects with one container. We provide proof-theoretical
  view on
  this kind of computations in functional programming and prove strong normalization and confluence.

  \section{Typed lambda-calculus based on IEL$^{-}$}

  At first we define the natural deduction for IEL$^{-}$ with $\textbf{K}$-modality and binary connectives
  $\to$ and $\land$ (we call that calculus NIEL$^{-}_{\land, \to}$):

  \begin{defin} Natural deduction NIEL$^{-}_{\land, \to}$ for IEL$^{-}$ with $\to$ and $\wedge$:

  \begin{center}
  \begin{prooftree}
  \AxiomC{}
  \RightLabel{\scriptsize{ax}}
  \UnaryInfC{$\Gamma , A \vdash A$}
  \end{prooftree}
  \end{center}

  \begin{minipage}{0.5\textwidth}
    \begin{flushleft}
  	\begin{prooftree}
  	\AxiomC{$\Gamma, A \vdash B$}
  	\RightLabel{$\rightarrow_i$}
  	\UnaryInfC{$\Gamma \vdash A \to B$}
    	\end{prooftree}

  	\begin{prooftree}
  	\AxiomC{ $\Gamma \vdash A$ }
  	\AxiomC{ $\Gamma \vdash B$ }
  	\RightLabel{$\land_i$}
  	\BinaryInfC{$\Gamma \vdash A \land B$}
  	\end{prooftree}

  	\begin{prooftree}
    	\AxiomC{$\Gamma \vdash A$}
    	\RightLabel{$\textbf{K}_I$}
    	\UnaryInfC{$\Gamma \vdash \textbf{K}A$}
  \end{prooftree}
    \end{flushleft}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \begin{flushright}
    	\begin{prooftree}
  	\AxiomC{$\Gamma \vdash A \to B$}
  	\AxiomC{$\Gamma \vdash A$}
  	\RightLabel{$\rightarrow_i$}
  	\BinaryInfC{$\Gamma \vdash B$}
    	\end{prooftree}

  	\begin{prooftree}
  	\AxiomC{ $\Gamma \vdash A_1 \land A_2$ }
  	\RightLabel{$\land_e, i \in \{ 1, 2 \}$}
  	\UnaryInfC{$\Gamma \vdash A_i$}
  	\end{prooftree}

  	\begin{prooftree}
    \AxiomC{$\Gamma \vdash {\bf K} \vec{A}$}
    \AxiomC{$\vec{A} \vdash B$}
    \BinaryInfC{$\Gamma \vdash {\bf K} B$}
  	\end{prooftree}
    \end{flushright}
  \end{minipage}
  \end{defin}

Where $\Gamma \vdash {\bf K} \vec{A}$ is a syntax sugar for $\Gamma \vdash {\bf K} A_1 ,\dots, \Gamma \vdash {\bf K} A_n$.

  \vspace{\baselineskip}

  \begin{lemma}
    $\Gamma \vdash_{\text{NIEL}^{-}_{\land, \to}} A \Rightarrow$ IEL$^{-} \vdash \bigwedge \Gamma \rightarrow A$.
  \end{lemma}

  \begin{proof}
Induction on the derivation.

  \vspace{\baselineskip}

Let us consider cases with modality.

\vspace{\baselineskip}

1) If $\Gamma \vdash_{NIEL^{-}_{\land, \to}} A$, then $IEL^{-} \vdash \bigwedge \Gamma \rightarrow \textbf{K}A$.

$\begin{array}{lll}
(1) & \bigwedge \Gamma \rightarrow A & \text{assumption}\\
(2) & A \rightarrow \textbf{K}A &\text{co-reflection}\\
(3) & (\bigwedge \Gamma \rightarrow A) \rightarrow ((A \rightarrow \textbf{K}A) \rightarrow (\bigwedge \Gamma \rightarrow \textbf{K}A))&\text{IPC theorem}\\
(4) & (A \rightarrow \textbf{K}A) \rightarrow (\bigwedge \Gamma \rightarrow \textbf{K}A) &\text{from (1), (3) and MP}\\
(5) & \bigwedge \Gamma \rightarrow \textbf{K}A &\text{from (2), (4) and MP}\\
\end{array}$

\vspace{\baselineskip}

2) If $\Gamma \vdash_{NIEL^{-}_{\land, \to}} {\bf K} \vec{A}$ and $\vec{A} \vdash B$, then $IEL^{-} \vdash \bigwedge \Gamma \rightarrow \textbf{K}B$.

$\begin{array}{lll}
(1) &\bigwedge \Gamma \rightarrow \bigwedge \limits_{i = 1}^{n} {\bf K} A_i & \text{assumption} \\
(2) &\bigwedge \limits_{i = 1}^{n} {\bf K} A_i \rightarrow {\bf K} \bigwedge \limits_{i = 1}^{n} A_i& \text{IEL theorem} \\
(3) &\bigwedge \Gamma \rightarrow {\bf K} \bigwedge \limits_{i = 1}^{n} A_i & \text{from (1), (2) and transitivity} \\
(4) &\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B& \text{assumption} \\
(5) &(\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B) \rightarrow {\bf K} (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{co-reflection}\\
(6) &{\bf K} (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{from (2), (3) and MP} \\
(7) &{\bf K} \bigwedge \limits_{i = 1}^{n} A_i \rightarrow {\bf K} B & \text{from (6) and normality} \\
(8) &\bigwedge \Gamma \rightarrow {\bf K} B & \text{from (3), (7) and transitivity}
\end{array}$

  \end{proof}

\begin{lemma}
  $ $
  If $\text{IEL}^{-} \vdash A$, then $\text{NIEL}^{-} \vdash A$.
\end{lemma}

\begin{proof}
  Straightforward derivation of modal axioms in $\text{NIEL}^{-}$. We consider this derivation below using terms.
\end{proof}

  \vspace{\baselineskip}

  At the next step we build the typed lambda-calculus based on NIEL$^{-}_{\land, \to}$ by proof-assingment in
  rules.

  At first, we define lambda-terms and types for this lambda-calculus.

  \vspace{\baselineskip}

  \begin{defin} The set of terms:

  Let $\mathbb{V}$ be the set of variables. The set $\Lambda_{{\bf K}}$ of terms is defined by the grammar:

$\begin{array}{lll}
& \Lambda_{{\bf K}} ::= \mathbb{V} \: | \:  (\lambda \Lambda.\Lambda_{{\bf K}}) \: | \: (\Lambda_{{\bf K}}\Lambda_{{\bf K}}) \: | \: (\Lambda_{{\bf K}} , \Lambda_{{\bf K}}) \: | \: (\pi_1 \Lambda_{{\bf K}}) \: | \: (\pi_2 \Lambda_{{\bf K}}) \: | & \\
& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ({\bf pure \: } \: \Lambda_{{\bf K}}) \: | \: ({\bf let \:\: pure} \:\: \Lambda_{{\bf K}} = \Lambda_{{\bf K}} \:\: {\bf in} \:\: \Lambda_{{\bf K}})
\end{array}$

  \end{defin}

  \begin{defin} The set of types:

  Let $\mathbb{T}$ be the set of atomic types. The set $\mathbb{T}_{{\bf K}}$ of types with applicative
  functor ${\bf K}$ is generated by the grammar:
  \begin{equation}
    \mathbb{T}_{{\bf K}} ::= \mathbb{T} \: | \: (\mathbb{T}_{{\bf K}} \to \mathbb{T}_{{\bf K}}) \: |
    \: (\mathbb{T}_{{\bf K}} \times \mathbb{T}_{{\bf K}}) \: | \: ({\bf K}\mathbb{T}_{{\bf K}})
  \end{equation}
  \end{defin}

  Context, domain of context and range of context are defined standardly \cite{Neder}\cite{Morten}.

  Our type system is based on the Curry-style typing rules:

  \begin{defin} Modal typed lambda calculus $\lambda_{{\bf K}}$ based on NIEL$^{-}_{\land, \to}$:

    \begin{center}
    \begin{prooftree}
    \AxiomC{$ $}
    \RightLabel{\scriptsize{ax}}
    \UnaryInfC{$\Gamma , x : A \vdash x : A$}
    \end{prooftree}
    \end{center}

    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
      \AxiomC{$\Gamma, x : A \vdash M : B$}
      \RightLabel{$\rightarrow_i$}
      \UnaryInfC{$\Gamma \vdash \lambda x. M : A \to B$}
      \end{prooftree}

      \begin{prooftree}
      \AxiomC{ $\Gamma \vdash M : A$ }
      \AxiomC{ $\Gamma \vdash N : B$ }
      \RightLabel{$\times_i$}
      \BinaryInfC{$\Gamma \vdash \langle x, y \rangle : A \times B$}
      \end{prooftree}

      \begin{prooftree}
        \AxiomC{$\Gamma \vdash x : A$}
        \RightLabel{$\textbf{K}_I$}
        \UnaryInfC{$\Gamma \vdash {\bf pure \: } \: x : {\bf K}A $}
      \end{prooftree}
  \end{minipage}%
  \hfill
  \begin{minipage}{0.45\textwidth}
  \begin{tabular}{p{\textwidth}}
    \begin{prooftree}
    \AxiomC{$\Gamma \vdash f : A \to B$}
    \AxiomC{$\Gamma \vdash x : A$}
    \RightLabel{$\rightarrow_e$}
    \BinaryInfC{$\Gamma \vdash fx : B$}
    \end{prooftree}

    \begin{prooftree}
    \AxiomC{ $\Gamma \vdash M : A_1 \times A_2$ }
    \RightLabel{$\times_e$, $i \in \{ 1, 2 \}$}
    \UnaryInfC{$\Gamma \vdash \pi_i M : A_i$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \vec{M} : {\bf K} \vec{A}$}
      \AxiomC{$\vec{x} : \vec{A} \vdash M : B$}
      \RightLabel{$\text{let}_{{\bf K}}$}
      \BinaryInfC{$\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } M : {\bf K} B$}
    \end{prooftree}
  \end{tabular}
  \end{minipage}%

  \end{defin}

  ${\bf K}_I$-typing rule is the same as $\bigcirc$-introduction in lax logic (also known as monadic
  metalanguage \cite{Lax}) and in typed lambda-calculus which is derived by proof-assignment for lax-logic
  proofs.
  ${\bf K}_I$ allows to inject an object of type $\alpha$ into the functor. ${\bf K}_I$  reflects the
  Haskell method {\bf pure} for Applicative class. It plays the same role as the {\bf return} method in Monad class.

  $\text{let}_{{\bf K}}$ is the same as the $\Box$-rule in typed lambda calculus for intuitionistic normal modal logic {\bf IK}, which is described in \cite{ModalK}.

  In fact, our calculus is the extention of typed lambda calculus for {\bf IK} with typing rule appropriate to co-reflection.

  \vspace{\baselineskip}

Here are some examples of derivation trees.

  \begin{prooftree}
  \AxiomC{$x : A \vdash x : A$}
  \RightLabel{$\textbf{K}_I$}
  \UnaryInfC{$x : A \vdash {\bf pure \: } x : \textbf{K} A$}
  \RightLabel{$\rightarrow_i$}
  \UnaryInfC{$\vdash (\lambda x. {\bf pure \: } x) : A \to \textbf{K}A$}
  \end{prooftree}


  \begin{prooftree}
    \AxiomC{$f : {\bf K} (A \to B) \vdash f : {\bf K} (A \to B)$}
    \AxiomC{$x : {\bf K} A \vdash x : {\bf K} A $}
    \AxiomC{$g : A \to B$}
    \AxiomC{$y : A$}
    \BinaryInfC{$g : A \to B, y : A \vdash g y : B$}
    \TrinaryInfC{$f : {\bf K} (A \to B), x : {\bf K} A \vdash {\bf let \:\: pure} \:\: \langle g, y \rangle = \langle f, x \rangle \:\: {\bf in } \:\: g y : {\bf K} B$}
    \UnaryInfC{$f : {\bf K} (A \to B) \vdash \lambda x. {\bf let \:\: pure} \:\: \langle g, y \rangle = \langle f, x \rangle \:\: {\bf in } \:\: g y : {\bf K} A \to {\bf K} B$}
    \UnaryInfC{$\vdash \lambda f. \lambda x. {\bf let \:\: pure} \:\: \langle g, y \rangle = \langle f, x \rangle \:\: {\bf in } \:\: g y : {\bf K}(A \to B) \to {\bf K} A \to {\bf K} B$}
  \end{prooftree}

\begin{prooftree}
  \AxiomC{$f : A \to B \vdash f : A \to B$}
  \UnaryInfC{$f : A \to B \vdash {\bf pure \:\:} f : {\bf K }(A \to B)$}
  \AxiomC{$x : {\bf K} A \vdash x : {\bf K} A $}
  \AxiomC{$g : A \to B$}
  \AxiomC{$y : A$}
  \BinaryInfC{$g : A \to B, y : A \vdash g y : B$}
  \TrinaryInfC{$f : A \to B, x : {\bf K} A \vdash {\bf let \:\: pure} \:\: \langle g, y \rangle = \langle {\bf pure \:\:} f, x \rangle \:\: {\bf in } \:\: g y : {\bf K} B$}
  \UnaryInfC{$f : A \to B \vdash \lambda x. {\bf let \:\: pure} \:\: \langle g, y \rangle = \langle {\bf pure \:\:} f, x \rangle \:\: {\bf in } \:\: g y : {\bf K} A \to {\bf K} B$}
  \UnaryInfC{$\lambda f. \lambda x. {\bf let \:\: pure} \:\: \langle g, y \rangle = \langle {\bf pure \:\:} f, x \rangle \:\: {\bf in } \:\: g y : (A \to B) \to {\bf K} A \to {\bf K} B$}
\end{prooftree}




  \vspace{\baselineskip}

  Now we define free variables and substitutions. $\beta$-reduction, multi-step $\beta$-reduction and $\beta$-equality are defined standardly:

  \begin{defin} Set $FV(M)$ of free variables for arbitrary term $M$:

  1) $FV(x) = \{ x \}$;

  2) $FV(\lambda x. M) = FV(M) \setminus \{ x\}$;

  3) $FV(M N) = FV(M) \cup FV(N);$

  4) $FV(\langle M,N \rangle) = FV(M) \cup FV(N)$;

  5) $FV(\pi_i M) \subseteq FV(M)$, $i \in \{ 1, 2\}$;

  6) $FV(\text{pure } M) = FV(M)$;

  7) $FV({\bf let \:\: pure} \:\: \vec{N} = \vec{M} \:\: {\bf in} \:\: M) = \bigcup \limits_{i = 1}^n FV(M), \text{where $n = |\vec{M}|$}$.
  \end{defin}

  \begin{defin} Substitution:

  1) $x [x := N] = N$, $x [y := N] = x$;

  2) $(M N) [x := N] = M[x := N] N [x := N]$;

  3) $(\lambda x. M) [x := N] = \lambda x. M [x := N]$;

  4) $(M, N)[x := P] = (M[x := P], N [x := P])$;

  5) $(\pi_i M) [x := P] = \pi_i (M[x := P])$, $i \in \{ 1, 2\}$;

  6) $({\bf pure \: } M) [x := P] = {\bf pure \: } (M [x := P])$;

  7) $({\bf let \:\: pure} \:\: \vec{x} = \vec{M} \:\: {\bf in} \:\: M) [y := P] = {\bf let \:\: pure} \:\: \vec{x} = (\vec{M} [y := P]) \:\: {\bf in} \:\: M$.
  \end{defin}

  \begin{defin} $\beta$-reduction and $\eta$-reduction rules for \emph{$\lambda \textbf{K}$}.

  1) $(\lambda x. M) N \rightarrow_{\beta} M [x := N]$;

  2) $\pi_1 \langle M, N \rangle \rightarrow_{\beta} M$;

  3) $\pi_2 \langle M, N \rangle \rightarrow_{\beta} N$;

  4) $\begin{array}{llll}
  & {\bf let \: pure \:} \langle \vec{x}, y, \vec{z} \rangle = \langle \vec{M}, {\bf let \: pure \: } \vec{w} = \vec{N} {\bf \: in \: } Q, \vec{P} \rangle {\: in \:} R \rightarrow_{\beta} & \\
  & {\bf let \: pure \:} \langle \vec{x}, \vec{w}, \vec{z} \rangle = \langle \vec{M}, \vec{N}, \vec{P} \rangle \: { \bf in } \: R [y := Q]
  \end{array}$

  5) $M \rightarrow_{\beta} N \Rightarrow {\bf pure \: M} \rightarrow_{\beta} {\bf pure \: N}$

  6) $\lambda x. f x \rightarrow_{\eta} f$;

  7) $\langle \pi_1 P, \pi_2 P \rangle \rightarrow_{\eta} P$;

  10) ${\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N \rightarrow_{\eta} {\bf pure \:} N$;

  11) ${\bf let \: pure \:} x = M {\: \bf in \: } x \rightarrow_{\eta} M$;

  12) $M \rightarrow_{\beta} N \Rightarrow {\bf pure \: M} \rightarrow_{\eta} {\bf pure \: N}$
  \end{defin}

  Let us show the next simple observation, which immeadelty follows from the previous definition.

  \begin{lemma}
    $ $

    If $M \rightarrow_{\beta \eta} N$, then ${\bf pure \:} M \rightarrow_{\beta \eta} {\bf pure \:} N$.
  \end{lemma}



  \section{Basic lemmas}

  Now we will prove standard lemmas for contexts in type systems\footnote{We will not prove cases with
  $\to$-constructor, they are proved standardly in the same lemmas for simply typed lambda calculus, for
  example see \cite{Neder}\cite{Morten}\cite{Girard}. We will consider only modal cases}:



\section{Strong normalization}

\section{Confluence}

\section{Categorical semantics}

\begin{defin} Lax monoidal functor

  Let $\langle \mathcal{C}, \oplus_1, \mathds{1} \rangle$ and $\langle \mathcal{D}, \oplus_2, \mathds{1}' \rangle$ are monoidal categories.

  A lax monoidal functor $\mathcal{F} : \langle \mathcal{C}, \oplus_1, \mathds{1} \rangle \to \langle \mathcal{D}, \oplus_2, \mathds{1}' \rangle$ is a functor
  $\mathcal{F} : \mathcal{C} \to \mathcal{D}$ with additional natural transformations:

  1) $u : \mathds{1}' \to \mathcal{F}\mathds{1}$;

  2) $\ast_{A, B} : \mathcal{F}A \otimes_2 \mathcal{F}B \to \mathcal{F}(A \otimes_1 B)$

\end{defin}

\begin{defin} Applicative functor

  An applicative functor is a triple $\langle \mathcal{C}, \mathcal{K}, \eta \rangle$,
where $\mathcal{C}$ is a symmetric monoidal category, $\mathcal{K}$ is a lax monoidal endofunctor and $\eta$ is a natural transformation, such that:

1) $u = \eta_{\mathds{1}}$;

2) $\ast_{A,B} \circ (\eta_A \otimes \eta_B) = \eta_{A \otimes B}$;

3) Weak commutativity condition holds:

\xymatrix{
A \otimes \mathcal{K}B & \mathcal{K}A \otimes \mathcal{K}B & \mathcal{K}(A \otimes B) \\
\mathcal{K}B \otimes A & \mathcal{K}B \otimes \mathcal{K}A & \mathcal{K}(B \otimes A)
}
\end{defin}

By default we will consider an arbitrary closed functor on some cartersian closed category, which is the special case of an applicative functor.

We identify terminal objects. So $\mathcal{K}(\mathds{1}) = \mathds{1}$ and $\eta_{\mathds{1}} = id_{\mathds{1}}$ since $\mathcal{K}$ is an endofunctor.

\subsection{Soundness}

\begin{defin} Semantical translation from $\lambda_{\textbf{K}}$ to CCC with applicative functor $\mathcal{K}$:

1) Interpretation for types:

$[\![A]\!] := \hat{A}, A \in \mathbb{T}$;

$[\![A \to B]\!] := [\![A]\!] \to [\![B]\!]$;

$[\![A \times B]\!] := [\![A]\!] \times [\![B]\!]$.

2) Interpretation for modal types: $[\![\textbf{K}A]\!] = \mathcal{K}[\![A]\!]$;

3) Interpretaion for contexts:

$[\![\Gamma = \{ x_1 : A_1, ..., x_n : A_n\}]\!] := [\![\Gamma]\!] = [\![A_1]\!] \times ... \times [\![A_n]\!]$;

4) Interpretation for typing assignment: $[\![\Gamma \vdash M : A]\!] := [\![M]\!] : [\![\Gamma]\!] \to
[\![A]\!]$.

5) Interpretation for typing rules:

\begin{prooftree}
\AxiomC{$ $}
\UnaryInfC{$[\![\Gamma, x : A \vdash x : A]\!] = \pi_2 : [\![\Gamma]\!] \times [\![A]\!] \rightarrow
[\![A]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma, x : A \vdash M : B]\!] = f : [\![\Gamma]\!] \times [\![A]\!] \rightarrow [\![B]\!]$}
\UnaryInfC{$[\![\Gamma \vdash (\lambda x. M) : A \to B]\!] = \Lambda(f) : [\![\Gamma]\!]
\rightarrow[\![B]\!]^{[\![A]\!]}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A \to B]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![B]\!]^{[\![A]\!]}$}
\AxiomC{$[\![\Gamma \vdash N : A]\!] = [\![N]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M N) : B]\!] = [\![\Gamma]\!] \xrightarrow{\langle [\![M]\!], [\![N]\!]
\rangle} [\![B]\!]^{[\![A]\!]} \times [\![A]\!] \xrightarrow{\epsilon} [\![B]\!] $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A ]\!] = f : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\AxiomC{$[\![\Gamma \vdash N : B ]\!] = g : [\![\Gamma]\!] \rightarrow [\![B]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M, N) : A \times B]\!] = \langle f, g \rangle : [\![\Gamma]\!] \rightarrow
[\![A]\!] \times [\![B]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash p : A_1 \times A_2]\!] = f : [\![\Gamma]\!] \rightarrow [\![A_1]\!] \times
[\![A_2]\!]$}
\RightLabel{$i \in \{1,2\}$}
\UnaryInfC{$[\![\Gamma \vdash \pi_i p : A_i]\!] = [\![\Gamma]\!] \xrightarrow{f} [\![A_1]\!] \times
[\![A_2]\!] \xrightarrow{\pi_i} [\![A_i]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\UnaryInfC{$[\![\Gamma \vdash {\bf pure \:} M : \textbf{K}A]\!] := [\![\Gamma]\!] \xrightarrow{[\![M]\!]}
[\![A]\!] \xrightarrow{\eta_{[\![A]\!]}} \mathcal{K}[\![A]\!]$}
\end{prooftree}

  \begin{prooftree}
    \AxiomC{$[\![\Gamma \vdash \vec{M} : {\bf K} \vec{A}]\!] = \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \prod \limits_{i=1}^n \mathcal{K}[\![A_i]\!]$}
    \AxiomC{$[\![\vec{x} : \vec{A} \vdash N : B]\!] = [\![N]\!] : \prod \limits_{i=1}^n [\![A_i]\!] \rightarrow [\![B]\!]$}
    \BinaryInfC{$[\![\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } M : {\bf K} B]\!] = \mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \mathcal{K}[\![B]\!]$}
  \end{prooftree}

\end{defin}

\begin{defin} Simultaneous substitution

Let $\Gamma = \{ x_1 : A_1, ..., x_n : A_n \}$, $\Gamma \vdash M : A$ and for all $i \in \{ 1,..., n \}$,
$\Gamma \vdash M_i : A_i$.

We define simultaneous substitution $M [ \vec{x} := \vec{M}]$ recursively by:

1) $x_i [ \vec{x} := \vec{M}] = M_i $;

2) $(\lambda x. M) [ \vec{x} := \vec{M}] = \lambda x. (M [ \vec{x} := \vec{M}])$;

3) $(M N) [ \vec{x} := \vec{M}] = (M [ \vec{x} = \vec{M}]) (N [ \vec{x} := \vec{M}])$;

4) $\langle M, N \rangle = \langle (M [ \vec{x} = \vec{M}]), (N [ \vec{x} := \vec{M}])\rangle$;

5) $(\pi_i P) [ \vec{x} := \vec{M}] = \pi_i (P [ \vec{x} = \vec{M}])$;

6) $({\bf pure \:} M) [ \vec{x} := \vec{M}] = {\bf pure \:} (M [ \vec{x} = \vec{M}])$;

7) $({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] =
{\bf let \: pure} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N$

\end{defin}

\begin{lemma}
$ $

$[\![M [x_1 := M_1,\dots, x_n := M_n]]\!] = [\![M]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle$.

\end{lemma}

\begin{proof}

$ $

1) $[\![\Gamma \vdash ({\bf pure \:} M) [ \vec{x} := \vec{M}] : {\bf K}A ]\!] = [\![ \Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle$.

\vspace{\baselineskip}

$\begin{array}{lll}
& [\![\Gamma \vdash ({\bf pure \:} M) [ \vec{x} := \vec{M}] : {\bf K}A]\!] = [\![ \Gamma \vdash {\bf pure \:} (M [ \vec{x} := \vec{M}]) : {\bf K}A]\!] &
\text{Substitution definition} \\
& \quad\quad\quad\quad\quad\quad\quad = \eta_{[\![A]\!]} \circ [\![(M [ \vec{x} := \vec{M}])]\!]&
\text{Translation for pure}\\
& \quad\quad\quad\quad\quad\quad\quad = \eta_{[\![A]\!]} \circ ([\![M]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle) & \text{Induction hypothesis} \\
& \quad\quad\quad\quad\quad\quad\quad = (\eta_{[\![A]\!]} \circ [\![M]\!]) \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle & \text{Associativity of composition}\\
& \quad\quad\quad\quad\quad\quad\quad = [\![ \Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle& \text{Translation for pure}\\
\end{array}$

\vspace{\baselineskip}

2) $\begin{array}{lll}&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : {\bf K} B]\!]
=[\![\Gamma \vdash {\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N : {\bf K}B]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle& \end{array}$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : {\bf K} B]\!] =& \\
&\text{Substitution definition}& \\
&[\![\Gamma \vdash {\bf let \: pure} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N : {\bf K}B]\!] =& \\
&\text{Interpretaion for $let_{\bf K}$}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ [\![\Gamma \vdash (\vec{M} [\vec{y} := \vec{P}]) \vdash : {\bf K}\vec{A}]\!] =& \\
&\text{Induction hypothesis}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ ([\![\vec{M}]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle) = & \\
&\text{Associativity of composition}& \\
&(\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ [\![\vec{M}]\!]) \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle = & \\
&\text{By interpretation}&\\
&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle&
\end{array}$

\end{proof}

\begin{lemma}
  $ $

  i) Let $\Gamma \vdash M : A$ and $M \twoheadrightarrow_{\beta} N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$;

  ii) Let $\Gamma \vdash M : A$ and $M \twoheadrightarrow_{\eta} N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$;
\end{lemma}

\begin{proof}
  $ $

  i) For $\beta$-reduction

\vspace{\baselineskip}

Cases with $\beta$-reductions for $let_{\bf K}$ are shown in \cite{ModalK1}. Let us consider cases with ${\bf pure}$.

\vspace{\baselineskip}

1) $[\![\Gamma \vdash {\bf pure \:} ((\lambda x. M) N) : {\bf K}B]\!] = [\![\Gamma \vdash {\bf pure \:} (M [x := N]]) : {\bf K}B]\!]$

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf pure \:} (\lambda x. M) N : {\bf K}B]\!] = & \text{By interpretation} \\
&\eta_{[\![B]\!]} \circ (\epsilon \circ \langle \Lambda([\![M]\!]), [\![N]\!]\rangle) =& \text{Property of $\times$} \\
&\eta_{[\![B]\!]} \circ (\epsilon \circ (\Lambda([\![M]\!]) \times id_{[\![A]\!]}) \circ \langle id_{[\![\Gamma]\!]}, [\![N]\!] \rangle) = & \text{Associativity of composition} \\
&\eta_{[\![B]\!]} \circ ((\epsilon \circ (\Lambda([\![M]\!]) \times id_{[\![A]\!]})) \circ \langle id_{[\![\Gamma]\!]}, [\![N]\!] \rangle) = & \text{Exponentiation property} \\
&\eta_{[\![B]\!]} \circ ([\![M]\!] \circ \langle id_{[\![\Gamma]\!]}, [\![N]\!] \rangle) = & \text{Substitution lemma} \\
&\eta_{[\![B]\!]} \circ [\![M [\vec{x}, x := \vec{x}, N]]\!] =& \text{By interpretation} \\
&[\![\Gamma \vdash {\bf pure \:} (M [x := N]]) : {\bf K}B]\!]&
\end{array}$

\vspace{\baselineskip}

2) $[\![\Gamma \vdash {\bf pure \:} (\pi_i \langle [\![M_1]\!], [\![M_2]\!] \rangle) : {\bf K}A_i ]\!] = [\![\Gamma \vdash {\bf \: pure} M_i : {\bf K}A_i ]\!]$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf pure \:} (\pi_i \langle M_1, M_2] \rangle) : {\bf K}A_i ]\!] = & \text{By interpretation} \\
&\eta_{[\![A_i]\!]} \circ \pi_i \circ \langle [\![M_1]\!], [\![M_2]\!] \rangle = & \text{Property of $\times$} \\
&\eta_{[\![A_i]\!]} \circ [\![M_i]\!] =& \text{By interpetation} \\
&[\![\Gamma \vdash {\bf pure \:} M_i : {\bf K}A_i]\!]&
\end{array}$

\vspace{\baselineskip}

ii) For $\eta$-reduction.

\vspace{\baselineskip}

1) $[\![\Gamma \vdash {\bf pure \:} (\lambda x. M x) : {\bf K}(A \to B)]\!] = [\![\Gamma \vdash {\bf pure \:} M : {\bf K}(A \to B)]\!]$.

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf pure \:} (\lambda x. M x) : {\bf K}(A \to B)]\!] = & \text{By interpetation} \\
&\eta_{[\![B]\!]^{[\![A]\!]}} \circ \Lambda(\epsilon \circ [\![M]\!] \times id_{[\![A]\!])}& \text{Exponentiation property} \\
&\eta_{[\![B]\!]^{[\![A]\!]}} \circ [\![M]\!] = & \text{By interpretation} \\
&[\![\Gamma \vdash {\bf pure \:} M : {\bf K}(A \to B)]\!]&
\end{array}$

\vspace{\baselineskip}

2) $[\![\Gamma \vdash {\bf pure \:} \langle \pi_1 M, \pi_2 M \rangle : {\bf K}(A \times B)]\!] = [\![\Gamma \vdash {\bf pure \:} M : {\bf K}(A \times B)]\!]$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf pure \:} \langle \pi_1 M, \pi_2 M \rangle : {\bf K}(A \times B)]\!] = & \text{By interpetation} \\
&\eta_{[\![A]\!] \times [\![B]\!]} \circ \langle \pi_1 \circ [\![M]\!], \pi_2 \circ [\![M]\!] \rangle  = & \text{By the property of a product of morphisms} \\
&\eta_{[\![A]\!] \times [\![B]\!]} \circ [\![M]\!] = & \text{By interpetation} \\
&[\![\Gamma \vdash {\bf pure \:} M : {\bf K}(A \times B)]\!]&
\end{array}$

\vspace{\baselineskip}

3) $[\![\vdash {\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N : {\bf }K A ]\!] = [\![\vdash {\bf pure \:} N : {\bf K A}]\!]$.

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\vdash {\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N : {\bf }K A ]\!] = & \text{By interpetation}\\
&\mathcal{K}([\![N]\!]) \circ \eta_{\mathds{1}} =& \text{Naturality for $\eta$} \\
&\eta_{[\![A]\!]} \circ [\![N]\!] =& \text{By interpretation} \\
&[\![\vdash {\bf pure \:} N : {\bf K} A]\!]&
\end{array}$

\end{proof}

\begin{theorem} Soundness

  Let $\Gamma \vdash M : A$ and $M =_{\beta\eta} N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$
\end{theorem}

\begin{proof}
$ $
Straightforwardly follows from two previous lemmas.
\end{proof}

  \addcontentsline{toc}{section}{References}

  %далее сам список используевой литературы
  \begin{thebibliography}{}

  \bibitem{Artemov} Artemov S. and Protopopescu T., \/ ``Intuitionistic Epistemic Logic'', \textit{The
  Review of Symbolic Logic}, 2016, vol. 9, no 2. pp. 266-298.\parskip=1mm

  \bibitem{Krupski} Krupski V. N. and Yatmanov A., \/ ``Sequent Calculus for Intuitionistic Epistemic Logic
  IEL'', \textit{Logical Foundations of Computer Science: International Symposium, LFCS 2016, Deerfield
  Beach, FL, USA, January 4-7, 2016. Proceedings}, 2016, pp. 187-201.\parskip=1mm

  \bibitem{Haskell} Haskell Language. // URL: https://www.haskell.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Idris} Idris. A Language with Dependent Types.// URL:https://www.idris-lang.org. (Date:
  1.08.2017) \parskip=1mm

  \bibitem{Purs} Purescript. A strongly-typed functional programming language that compiles to JavaScript.
  URL: http://www.purescript.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Elm} Elm. A delightful language for reliable webapps. // URL: http://elm-lang.org. (Date:
  1.08.2017) \parskip=1mm

  \bibitem{Base} Hackage, \/ ``The base package'' // URL: https://hackage.haskell.org/package/base-4.10.0.0
  (Date: 1.08.2017) \parskip=1mm

  \bibitem{Miran} Lipovaca M, \/ ``Learn you a Haskell for Great Good!''. //URL:
  http://learnyouahaskell.com/chapters (Date: 1.08.2017) \parskip=1mm

  \bibitem{McP} McBride C. and Paterson R., ``Applicative programming with effects", \textit{Journal of
  Functional Programming}, 2008, vol. 18, no 01. pp 1-13. \parskip=1mm

  \bibitem{McP2} McBride C. and Paterson R, ``Functional Pearl. Idioms: applicative programming with
  effects'', \textit{Journal of Functional Programming}, 2005. vol. 18, no 01. pp 1-20. \parskip=1mm

  \bibitem{Neder} R. Nederpelt and H. Geuvers, ``Type Theory and Formal Proof: An Introduction''.
  \textit{Cambridge University Press}, New York, NY, USA, 2014. pp. 436. \parskip=1mm

  \bibitem{Morten} Sorensen M. H. and Urzyczyn P, ``Lectures on the Curry-Howard isomorphism'',
  \textit{Studies in Logic and the Foundations of Mathematics}, vol. 149, \textit{Elsevier Science}, 1998.
  pp 261. \parskip=1mm

  \bibitem{Pierce} Pierce B. C., ``Types and Programming Languages''. \textit{Cambridge, Mass: The MIT
  Press}, 2002. pp. 605. \parskip=1mm

  \bibitem{Girard} Girard J.-Y., Taylor P. and  Lafont Y, ``Proofs and Types'', \textit{Cambridge University
  Press}, New York, NY, USA, 1989. pp. 175. \parskip=1mm

  \bibitem{Baren} Barendregt. H. P., ``Lambda calculi with types" // Abramsky S., Gabbay Dov M., and S. E.
  Maibaum, ``Handbook of logic in computer science (vol. 2), Osborne Handbooks Of Logic In Computer
  Science'', Vol. 2. \textit{Oxford University Press, Inc.}, New York, NY, USA, 1993. pp 117-309.
  \parskip=1mm

  \bibitem{Hindley} Hindley J. Roger, ``Basic Simple Type Theory''. \textit{Cambridge University Press}, New
  York, NY, USA, 1997. pp. 185. \parskip=1mm

  \bibitem{Lax} Pfenning F. and Davies R., ``A judgmental reconstruction of modal logic'',
  \textit{Mathematical Structures in Computer Science}, vol. 11, no 4, 2001, pp. 511-540. \parskip=1mm

  \bibitem{Baren2} H.P. Barendregt. The Lambda Calculus --- Its Syntax and Semantics. Studies in Logic and
  the Foundations of Mathematics, vol. 103. Amsterdam: North-Holland, 1985.

  \bibitem{ModalK} Yoshihiko KAKUTANI, A Curry-Howard Correspondence for Intuitionistic Normal Modal Logic, Computer Software, Released February 29, 2008, Online ISSN , Print ISSN 0289-6540.

  \bibitem{ModalK1} Kakutani Y. (2007) Call-by-Name and Call-by-Value in Normal Modal Logic. In: Shao Z. (eds) Programming Languages and Systems. APLAS 2007. Lecture Notes in Computer Science, vol 4807. Springer, Berlin, Heidelberg

  \bibitem{Abe} T. Abe. Completeness of modal proofs in first-order predicate logic. Computer Software, JSSST Journal, 24:165 -- 177, 2007.
  \end{thebibliography}


\end{document}
