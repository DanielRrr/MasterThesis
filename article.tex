\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{dsfont}
\usepackage{mathabx}
\usepackage{stmaryrd}
\usepackage[all, 2cell]{xy}
\usepackage[all]{xy}
\usepackage{authblk}
\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{defin}{Definition}
\newtheorem{ex}{Example}
\newtheorem{col}{Corollary}
\newtheorem{con}{Consequence}
\usepackage{listings} 		% for source code
\date{}
\author[1]{Daniel Rogozin}
\affil[1]{Moscow State University, Moscow, Russia}
\affil[1]{Serokell O\"{U}, Tallinn, Estonia}
\title{Modal type theory as based on the intuitionistic modal logic IEL$^{-}$}

\begin{document}
\maketitle

\begin{abstract}
Modal intuitionistic epistemic logic IEL$^{-}$ was proposed by S. Artemov and T. Protopopescu as the formal
foundation for the intuitionistic theory of knowledge. We construct a modal simply typed lambda-calculus
which is Curry-Howard isomorphic to IEL$^{-}$ as the formal theory of calculations with applicative functors in
functional programming.
\end{abstract}


  \section{Introduction}

  Modal intutionistic epistemic logic IEL was proposed by S. Artemov and T. Proropopescu \cite{Artemov}. IEL
  provides the epistimology and the theory of knowledge as based on BHK-semantics of intuitionistic logic.
  IEL$^{-}$  is a variant of IEL, that corresponds to intuitionistic belief.
  Informally, $\Box A$ denotes that the agent believes in $A$.

  Intuitionistic epistemic logic IEL$^{-}$ is defined by following axioms and derivation rules:

  \begin{defin} Intuitionistic epistemic logic IEL:

    1) IPC axioms;

    2) $\Box (A \to B) \to (\Box A \to \Box B)$ (normality);

    3) $A \to \Box A$ (co-reflection);

    Rule: MP.

  \end{defin}

  V. Krupski and  A. Yatmanov provided the sequential calculus for IEL and proved that this calculus is
  PSPACE-complete \cite{Krupski}.

  Functional programming languages such as Haskell, Idris or Purescript
  have special type classes \footnote{Type class in Haskell is a general interface for
  special group of datatypes.} for calculations with type operators like \verb"Functor" and
  \verb"Applicative" \footnote{Reader may read more about these types in the Haskell standard library documentation.}:

  \begin{lstlisting}[language=Haskell]
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    class Functor f => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}

  By \emph{container} (or \emph{computational context}) type we mean some type operator $f$, where $f$ is a
  ``function'' from $*$ to $*$: type operator takes a simple type (ща kind $*$) and returns another
  simple type of kind \verb"*". For more detailed description of the type system with kinds used in
  Haskell see \cite{Morten}.

Applicative functor allows to generalize the action of a functor for functions with arbitrary number of arguments, for instance:
  \begin{lstlisting}[language=Haskell]
  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
  liftA2 f x y = ((pure f) <*> x) <*> y
  \end{lstlisting}

  It's not difficult to see that modal axioms in $IEL^{-}$ and types of the methods of Applicative class in
  Haskell-like languages (which is described below) are syntactically similar and we are going to show that
  this coincidence has a non-trivial computational meaning.

  We investigate the relationship between intuitionistic epistemic logic IEL$^{-}$ and applicative programming with side-effects
  by constructing the type system (which is called $\lambda_{\text{IEL}^{-}}$) which is Curry-Howard isomorphic to $IEL^{-}$.
  So we will consider IEL$^{-}$ modality as an arbitrary applicative functor and we prove that the obtained type system
  is sound and complete for an applicative functor on cartesian closed category
  (using the categorical definition proposed by Paterson \cite{Cons}).

  $\lambda_{\text{IEL}^{-}}$ consists of the rules for simply typed lambda-calculus and special typing rules for
  lifting types into the applicative functor $\Box$. We assume that our type system will
  axiomatize the simplest case of computation with effects with one container. We provide a proof-theoretical
  view at this kind of computations in functional programming and prove strong normalization and confluence.

  \section{Typed lambda-calculus based on IEL$^{-}$}

  The first is to define the natural deduction calculus for NIEL$^{-}$ :

  \begin{defin} Natural deduction NIEL$^{-}$ for IEL$^{-}$ is an extenstion of intuitionistic natural deduction calculus
    with additional inference rules for modality:

  \begin{center}
    \begin{prooftree}
      \AxiomC{$ $}
      \RightLabel{\bf{ax}}
      \UnaryInfC{$\Gamma, A \vdash A$}
    \end{prooftree}
  \end{center}

  \begin{minipage}{0.5\textwidth}
    \begin{flushleft}
    \begin{prooftree}
      \AxiomC{$\Gamma, A \vdash B$}
      \RightLabel{$\to_I$}
      \UnaryInfC{$\Gamma \vdash A \to B$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A$}
      \AxiomC{$\Gamma \vdash B$}
      \RightLabel{$\land_I$}
      \BinaryInfC{$\Gamma \vdash A \land B$}
    \end{prooftree}
  	\begin{prooftree}
    	\AxiomC{$\Gamma \vdash A$}
    	\RightLabel{${\Box_I}_1$}
    	\UnaryInfC{$\Gamma \vdash \Box A$}
  \end{prooftree}
    \end{flushleft}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \begin{flushright}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A \to B$}
      \AxiomC{$\Gamma \vdash A$}
      \RightLabel{$\to_E$}
      \BinaryInfC{$\Gamma \vdash B$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash A_1 \land A_2$}
      \RightLabel{$\land_E, i = 1,2$}
      \UnaryInfC{$\Gamma \vdash A_i$}
    \end{prooftree}
  	\begin{prooftree}
    \AxiomC{$\Gamma \vdash \Box A_1, \dots, \Gamma \vdash \Box A_n $}
    \AxiomC{$A_1,\dots,A_n \vdash B$}
    \RightLabel{${\Box_I}_2$}
    \BinaryInfC{$\Gamma \vdash \Box B$}
  	\end{prooftree}
    \end{flushright}
  \end{minipage}
  \end{defin}

Without loss of generality we will consider the calculus without inference rule for disjunction and negation.
Obtained calculus is equivalent to Hilbert-style IEL$^{-}$ without axioms for negation and disjunction.

The first modal rule allows to derive co-reflextion. The second modal rule is a counterpart of $\Box_I$
rule in natural deduction calculus for constructive K (see \cite{ModalLa}).

We will denote $\Gamma \vdash \Box A_1, \dots, \Gamma \vdash \Box A_n$ and $A_1,\dots,A_n \vdash B$ as $\Gamma \vdash \Box \vec{A}$ and $\vec{A} \vdash B$ for brevity.

  \vspace{\baselineskip}

  \begin{lemma}
    $\Gamma \vdash_{\text{NIEL}^{-}} A \Rightarrow$ IEL$^{-} \vdash \bigwedge \Gamma \rightarrow A$.
  \end{lemma}

  \begin{proof}
Induction on the derivation.

  \vspace{\baselineskip}

Let us consider cases with modality.

\vspace{\baselineskip}

1) If $\Gamma \vdash_{\text{NIEL}^{-}} A$, then $\text{IEL}^{-} \vdash \bigwedge \Gamma \rightarrow \Box A$.

$\begin{array}{lll}
(1) & \bigwedge \Gamma \rightarrow A & \text{assumption}\\
(2) & A \rightarrow \Box A &\text{co-reflection}\\
(3) & (\bigwedge \Gamma \rightarrow A) \rightarrow ((A \rightarrow \Box A) \rightarrow (\bigwedge \Gamma \rightarrow \Box A))&\text{IPC theorem}\\
(4) & (A \rightarrow \Box A) \rightarrow (\bigwedge \Gamma \rightarrow \Box A) &\text{from (1), (3) and MP}\\
(5) & \bigwedge \Gamma \rightarrow \Box A &\text{from (2), (4) and MP}\\
\end{array}$

\vspace{\baselineskip}

2) If $\Gamma \vdash_{\text{NIEL}^{-}} \Box \vec{A}$ and $\vec{A} \vdash B$, then $\text{IEL}^{-} \vdash \bigwedge \Gamma \rightarrow \Box B$.

$\begin{array}{lll}
(1) &\bigwedge \Gamma \rightarrow \Box A_1, \dots, \bigwedge \Gamma \rightarrow \Box A_1 & \text{assumption} \\
(2) &\bigwedge \Gamma \rightarrow \bigwedge \limits_{i = 1}^{n} \Box A_i & \text{IEL$^{-}$ theorem} \\
(3) &\bigwedge \limits_{i = 1}^{n} \Box A_i \rightarrow \Box \bigwedge \limits_{i = 1}^{n} A_i & \text{IEL$^{-}$ theorem} \\
(4) &\bigwedge \Gamma \rightarrow \Box \bigwedge \limits_{i = 1}^{n} A_i & \text{from (2), (3) and transitivity} \\
(5) &\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B& \text{assumption} \\
(6) &(\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B) \rightarrow \Box (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{co-reflection}\\
(7) &\Box (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{from (5), (6) and MP} \\
(8) &\Box \bigwedge \limits_{i = 1}^{n} A_i \rightarrow \Box B & \text{from (7) and normality} \\
(9) &\bigwedge \Gamma \rightarrow \Box B & \text{from (4), (8) and transitivity}
\end{array}$

  \end{proof}

\begin{lemma}
  $ $
  If $\text{IEL}^{-} \vdash A$, then $\text{NIEL}^{-} \vdash A$.
\end{lemma}

\begin{proof}
  Straightforward derivation of modal axioms in $\text{NIEL}^{-}$. We shall consider these derivations using terms below.
\end{proof}

  \vspace{\baselineskip}

  At the next step we build the typed lambda-calculus based on the NIEL$^{-}$.
by proof-assingment in rules.

  At first, we define lambda-terms and types for this lambda-calculus.

  \vspace{\baselineskip}

  \begin{defin} The set of terms:

  Let $\mathbb{V}$ be the set of variables. The set $\Lambda_{\Box}$ of terms is defined by the grammar:

$\begin{array}{lll}
& \Lambda_{\Box} ::= \mathbb{V} \: | \:  (\lambda \mathbb{V}.\Lambda_{\Box}) \: | \: (\Lambda_{\Box} \Lambda_{\Box}) \: | \: \langle \Lambda_{\Box} , \Lambda_{\Box} \rangle \: | \: (\pi_1 \Lambda_{\Box}) \: | \: (\pi_2 \Lambda_{\Box}) \: | & \\
& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ({\bf box \: } \:\Lambda_{\Box}) \: | \: ({\bf let \: box \:} \mathbb{V}^{*} = \Lambda_{\Box}^{*} \:\: {\bf in} \:\: \Lambda_{\Box})
\end{array}$

  \end{defin}

Where $\mathbb{V}^{*}$ and $\Lambda_{\Box}^{*}$ denote the set of finite sequences of variables $\bigcup \limits_{i=0}^{\infty} \mathbb{V}^i$
and the set of finite sequences of terms $\bigcup \limits_{i = 0}^{\infty} \Lambda_{\Box}^i $. Note that the sequence of variables $\vec{x}$ and the sequence of terms $\vec{M}$ should have the same length.
Otherwise, term is not well-formed.

  \begin{defin} The set of types:

  Let $\mathbb{T}$ be the set of atomic types. The set $\mathbb{T}_{\Box}$ of types with applicative
  functor $\Box$ is generated by the grammar:
  \begin{equation}
    \mathbb{T}_{\Box} ::= \mathbb{T} \: | \: (\mathbb{T}_{\Box} \to \mathbb{T}_{\Box} \: |
    \: (\mathbb{T}_{\Box} \times \mathbb{T}_{\Box}) \: | \: (\Box \mathbb{T}_{\Box})
  \end{equation}
  \end{defin}

  Context, domain of context and range of context are defined standardly \cite{Neder}\cite{Morten}.

  Our type system is based on the Curry-style typing rules:

  \begin{defin} Modal typed lambda calculus $\lambda_{\text{IEL}^{-}}$ based on NIEL$^{-}_{\land, \to}$:

    \begin{center}
    \begin{prooftree}
    \AxiomC{$ $}
    \RightLabel{\scriptsize{ax}}
    \UnaryInfC{$\Gamma , x : A \vdash x : A$}
    \end{prooftree}
    \end{center}

    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
      \AxiomC{$\Gamma, x : A \vdash M : B$}
      \RightLabel{$\rightarrow_i$}
      \UnaryInfC{$\Gamma \vdash \lambda x. M : A \to B$}
      \end{prooftree}

      \begin{prooftree}
      \AxiomC{ $\Gamma \vdash M : A$ }
      \AxiomC{ $\Gamma \vdash N : B$ }
      \RightLabel{$\times_i$}
      \BinaryInfC{$\Gamma \vdash \langle M, N \rangle : A \times B$}
      \end{prooftree}

      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : A$}
        \RightLabel{$\Box_I$}
        \UnaryInfC{$\Gamma \vdash {\bf box \: } \: M : \Box A $}
      \end{prooftree}
  \end{minipage}%
  \hfill
  \begin{minipage}{0.45\textwidth}
  \begin{tabular}{p{\textwidth}}
    \begin{prooftree}
    \AxiomC{$\Gamma \vdash M : A \to B$}
    \AxiomC{$\Gamma \vdash N : A$}
    \RightLabel{$\rightarrow_e$}
    \BinaryInfC{$\Gamma \vdash MN : B$}
    \end{prooftree}

    \begin{prooftree}
    \AxiomC{ $\Gamma \vdash M : A_1 \times A_2$ }
    \RightLabel{$\times_e$, $i = 1, 2$}
    \UnaryInfC{$\Gamma \vdash \pi_i M : A_i$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \vec{M} : \Box \vec{A}$}
      \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
      \RightLabel{$\text{let}_{\Box}$}
      \BinaryInfC{$\Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } N : \Box B$}
    \end{prooftree}
  \end{tabular}
  \end{minipage}%

  \end{defin}

  $\Box_I$-typing rule is the same as $\bigcirc$-introduction in monadic
  metalanguage \cite{Lax}. $\Box_I$ allows to inject an object of type $A$ into the functor $\Box$. $\Box_I$ reflects the
  Haskell method {\bf box} for Applicative class. It plays the same role as the {\bf return} method in Monad class.

  $\text{let}_{\Box}$ is similar to the $\Box$-rule in typed lambda calculus for intuitionistic normal modal logic {\bf IK}, which is described in \cite{ModalK}.

$\Gamma \vdash \vec{M} : \Box \vec{A}$ is a syntax sugar for the sequence $\Gamma \vdash M_1 : \Box A_1,\dots,\Gamma \vdash M_n : \Box A_n$ and $\vec{x} : \vec{A} \vdash N : B$ is a short form for $x_1 : A_1, \dots, x_n : A_n \vdash N : B$.
${\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } N$ is a simultaneous local binding in $N$.
We use this short form instead of ${\bf let \: box \:} x_1,\dots,x_n = M_1,\dots,M_n {\: \bf in \:} N$.

In fact, our calculus is the extention of typed lambda calculus for {\bf IK} by $\Box_I$-rule that is appropriate to co-reflection.

  \vspace{\baselineskip}

Here are some examples of derivation trees:

\begin{prooftree}
\AxiomC{$x : A \vdash x : A$}
\RightLabel{$\Box_I$}
\UnaryInfC{$x : A \vdash {\bf box \:} x : \Box A$}
\RightLabel{$\to_I$}
\UnaryInfC{$\vdash (\lambda x. {\bf box \: } x) : A \to \Box A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$f : \Box (A \to B) \vdash f : \Box (A \to B)$}
\AxiomC{$x : \Box A \vdash x : \Box A $}
\AxiomC{$g : A \to B \vdash g : A \to B$}
\AxiomC{$y : A \vdash y : A$}
\RightLabel{$\to_e$}
\BinaryInfC{$g : A \to B, y : A \vdash g y : B$}
\RightLabel{$\text{let}_{\Box}$}
\TrinaryInfC{$f : \Box (A \to B), x : \Box A \vdash {\bf let \: box \:} g, y  = f, x {\: \bf in \:} g y : \Box B$}
\RightLabel{$\to_I$}
\UnaryInfC{$f : \Box (A \to B) \vdash \lambda x. {\bf let \: box \:} g, y = f, x {\: \bf in \:} g y : \Box A \to \Box B$}
\RightLabel{$\to_I$}
\UnaryInfC{$\vdash \lambda f. \lambda x. {\bf let \: box \:} g, y = f, x {\: \bf in \:} g y : \Box (A \to B) \to \Box A \to \Box B$}
\end{prooftree}

  \vspace{\baselineskip}

  Now we define free variables and substitutions:

  \begin{defin} The set $FV(M)$ of free variables for a term $M$:

\begin{enumerate}
  \item $FV(x) = \{ x \}$;
  \item $FV(\lambda x. M) = FV(M) \setminus \{ x\}$;
  \item $FV(M N) = FV(M) \cup FV(N);$
  \item $FV(\langle M,N \rangle) = FV(M) \cup FV(N)$;
  \item $FV(\pi_i M) = FV(M)$, $i = 1, 2$;
  \item $FV(\text{\bf box } M) = FV(M)$;
  \item $FV({\bf let \: box} \: \vec{x} = \vec{M} {\: \bf in \:} N) = \bigcup \limits_{i = 1}^n FV(M), \text{where $n = |\vec{M}|$}$.
\end{enumerate}
  \end{defin}

  \begin{defin} Substitution:

\begin{enumerate}
  \item $x [x := N] = N$, $x [y := N] = x$;
  \item $(M N) [x := N] = M[x := N] N [x := N]$;
  \item $(\lambda x. M) [x := N] = \lambda x. M [y := N]$, $y \in FV(M)$;
  \item $(M, N)[x := P] = (M[x := P], N [x := P])$;
  \item $(\pi_i M) [x := P] = \pi_i (M[x := P])$, $i = 1, 2$;
  \item $({\bf box \: } M) [x := P] = {\bf box \: } (M [x := P])$;
  \item $({\bf let \: box \:}\vec{x} = \vec{M} {\: \bf in \:} N) [y := P] = {\bf let \: box \:} \vec{x} = (\vec{M} [y := P]) {\: \bf in \:} N$.
\end{enumerate}
  \end{defin}

Substitution and free variable for terms of kind ${\bf let \: box}$ are defined similary to \cite{ModalK}.

  \begin{defin} $\beta$-reduction and $\eta$-reduction rules for $\lambda_{\text{IEL}^{-}}$.

\begin{enumerate}
  \item $(\lambda x. M) N \rightarrow_{\beta} M [x := N]$;
  \item $\pi_1 \langle M, N \rangle \rightarrow_{\beta} M$;
  \item $\pi_2 \langle M, N \rangle \rightarrow_{\beta} N$;
  \item ${\bf let \: box \:} \vec{x}, y, \vec{z} = \vec{M}, {\bf let \: box \: } \vec{w} = \vec{N} {\: \bf in \: } Q, \vec{P} {\: in \:} R \rightarrow_{\beta} \\
  {\bf let \: box \:} \vec{x}, \vec{w}, \vec{z} = \vec{M}, \vec{N}, \vec{P} {\: \bf in \: } R [y := Q]$;
  \item ${\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N \rightarrow_{\beta} {\bf box \:} N [\vec{x} := \vec{M}]$;
  \item ${\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M \rightarrow_{\beta} {\bf box \:} M$, where \underline{\quad} is an empty sequence of terms;
  \item $\lambda x. f x \rightarrow_{\eta} f$;
  \item $\langle \pi_1 P, \pi_2 P \rangle \rightarrow_{\eta} P$;
  \item ${\bf let \: box \:} x = M {\: \bf in \: } x \rightarrow_{\eta} M$;
\end{enumerate}
  \end{defin}

By default we use call-by-name evaluation strategy.

Now we will prove standard lemmas for contexts in type systems\footnote{Cases with
$\to$-constructor are proven standardly in similar lemmas for simply typed lambda calculus, for
example see \cite{Neder} \cite{Morten} \cite{Pierce}. We will consider only modal cases}:

\begin{lemma} Generation for $\Box_I$.

  Let $\Gamma \vdash {\bf box \:} M : \Box A$, then $\Gamma \vdash M : A$;
\end{lemma}

\begin{proof}
  Straightforwardly.
\end{proof}

\begin{lemma} Basic lemmas.

\begin{enumerate}
  \item If $\Gamma \vdash M : A$ and $\Gamma \subseteq \Delta$, then $\Delta \vdash M : A$;
  \item If $\Gamma \vdash M : A$, then $\Delta \vdash M : A$, where $\Delta = \{ x : A \: | \: (x : A) \in \Gamma \: \& \: x \in FV(M) \}$
  \item If $\Gamma, x : A \vdash M : B$ and $\Gamma \vdash N : A$, then $\Gamma \vdash M [x := N] : B$.
\end{enumerate}
\end{lemma}

\begin{proof}
  $ $

1--3) Induction on the derivation of $\Gamma \vdash M : A$.

\end{proof}

\begin{theorem} Subject reduction

  If $\Gamma \vdash M : A$ and $M \twoheadrightarrow_r N$, then $\Gamma \vdash N : A$.

\end{theorem}

\begin{proof}

Induction on the derivation $\Gamma \vdash M : A$ and on the generation of $\rightarrow_r$.

\begin{enumerate}

\item If $\Gamma \vdash {\bf let \: box \:} \vec{x}, y, \vec{z} = \vec{M}, {\bf let \: box \: } \vec{w} = \vec{N} {\bf \: in \: } Q, \vec{P}  {\: \bf in \:} R : \Box B$,
  then $\Gamma \vdash {\bf let \: box \:} \vec{x}, \vec{w}, \vec{z} = \vec{M}, \vec{N}, \vec{P} \: { \bf in } \: R [y := Q] : \Box B$ by rule 4).
\item Let $\Gamma \vdash {\bf let \: box \:} x = M {\: \bf in \: } x : \Box A$,
then $\Gamma \vdash M : \Box A$ by rule 9). \\ See \cite{ModalK}.
\item The derivation ends in
\begin{prooftree}
\AxiomC{$\Gamma \vdash {\bf box \:} \vec{M} : \Box \vec{A}$}
\AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
\BinaryInfC{$\Gamma \vdash {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N : \Box B$}
\end{prooftree}
So $\Gamma \vdash \vec{M} : \vec{A}$ by Lemma 4 and $\Gamma \vdash N [\vec{x} := \vec{M}] : B$ by Lemma 4, part 3.
Then we can transform this into the following derivation:
\begin{prooftree}
\AxiomC{$\Gamma \vdash N [\vec{x} := \vec{M}] : B$}
\RightLabel{$\Box_I$}
\UnaryInfC{$\Gamma \vdash {\bf box \:} N [\vec{x} := \vec{M}] : \Box B$}
\end{prooftree}
\item The derivation ends in
\begin{prooftree}
\AxiomC{$\vdash M : A$}
\UnaryInfC{$\vdash {\bf let \: box \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : \Box A$}
\end{prooftree}
So, if $\vdash M : A$, then $\vdash {\bf box \:} M : \Box A$.
\end{enumerate}
\end{proof}

\begin{theorem}
  $ $

  $\twoheadrightarrow_r$ is strongly normalizing;
\end{theorem}

\begin{proof}
  $ $

  Let us define the transformation from $\lambda_{\text{IEL}^{-}}$ into the simple type theory with
  $\to$, $\times$ and natural number type $\mathbb{N}$ with additional typing and reduction rules\footnote{Strong normalization for stronger system was shown here \cite{Girard}}:

  \begin{prooftree}
  \AxiomC{$ $}
  \RightLabel{{\bf zero}}
  \UnaryInfC{$\Gamma \vdash 0 : \mathbb{N}$}
  \end{prooftree}

\begin{minipage}{0.45\textwidth}
\begin{flushleft}
  \begin{prooftree}
  \AxiomC{$\Gamma \vdash n : \mathbb{N}$}
  \RightLabel{{\bf succ}}
  \UnaryInfC{$\Gamma \vdash {\bf succ \:} n : \mathbb{N}$}
  \end{prooftree}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{flushright}
  \begin{prooftree}
  \AxiomC{$\Gamma \vdash n : \mathbb{N}$}
  \AxiomC{$\Gamma \vdash m : \mathbb{N}$}
  \RightLabel{{\bf add}}
  \BinaryInfC{$\Gamma \vdash n + m : \mathbb{N}$}
  \end{prooftree}
\end{flushright}
\end{minipage}

  \begin{enumerate}
    \item $n + 0 \rightarrow_{\beta} n$;
    \item $(n + {\bf succ \:} m) \rightarrow_{\beta} {\bf succ \:} (n + m)$
  \end{enumerate}

  The transformation $|.|$ is defined as follows:

  \begin{defin} Interpretaion of types:

    \begin{enumerate}
      \item $A \in \mathbb{T} \Rightarrow |A| = A$;
      \item $|A \to B| = |A| \to |B|$;
      \item $|A \times B| = |A| \times |B|$;
      \item $|\Box A| = \mathbb{N} \times |A|$.
    \end{enumerate}
  \end{defin}

  \begin{defin} Interpretation of terms:
    \begin{enumerate}
      \item $x \in \mathbb{V} \Rightarrow |x| = x$;
      \item $|\lambda x. M| = \lambda x. |M|$;
      \item $|(M N)| = |M| |N|$;
      \item $|\langle M, N \rangle| = \langle |M|, |N| \rangle$;
      \item $|\pi_i M| = \pi_i |M|$, $i = 1, 2$;
      \item $|{\bf box \:} M| = \langle 0, |M| \rangle$;
      \item $|{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M| = \langle 0, |M| \rangle$;
      \item $|{\bf let \: box \:} x = N {\: \bf in \:} M| = \langle \pi_1 |N| , |M| [x := \pi_2 |N|] \rangle$
      \item $|{\bf let \: box \:} \vec{x} = \vec{N} {\: \bf in \:} M| = \langle \sum \limits_{i = 1}^n \pi_1 |N|, |M| [\vec{x} := \pi_2 |\vec{N}|] \rangle$
    \end{enumerate}
  \end{defin}

  Let us consider the interpretation for $\text{let}_{\Box}$ rule:

  \begin{prooftree}
    \AxiomC{$|\Gamma \vdash \vec{N} : \Box \vec{A}| = |\Gamma| \vdash \vec{|N|} : \mathbb{N} \times \vec{|A|}$}
    \AxiomC{$|\vec{x} : \vec{A} \vdash M : B| = \vec{x} : \vec{|A|} \vdash |M| : |B|$}
    \RightLabel{$\text{let}_{\Box}$}
    \BinaryInfC{$|\Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{N} {\: \bf in \: } M : \Box B| = |\Gamma| \vdash \langle \sum \limits_{i = 1}^n \pi_1 |N|, |M| [\vec{x} := \pi_2 \vec{N}] \rangle : \mathbb{N} \times |B|$}
  \end{prooftree}

  \begin{lemma}:

    $|M [x := N]| = |M| [x := |N|]$ for any term $M$.
  \end{lemma}

  \begin{proof}

    Induction on the structure of $M$.
  \end{proof}

  \begin{lemma}

    $M \twoheadrightarrow_{r} N \Rightarrow |M| \twoheadrightarrow_{\beta\eta} |N|$
  \end{lemma}

  \begin{proof}

    Let us consider cases with $\beta \Box$, $\beta \Box {\bf box}$ and $\Box id$.

\begin{enumerate}
\item $|{\bf let \: box \:} x = ({\bf let \: box \:} y = N {\: \bf in \:} P) {\: \bf in \:} M| = \\
\quad\quad\quad\quad |{\bf let \: box \:} y = N {\: \bf in \:} M [x := P]|$

  $\begin{array}{lll}
  &|{\bf let \: box \:} x = ({\bf let \: box \:} y = N {\: \bf in \:} P) {\: \bf in \:} M| = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &\langle \pi_1 |N|, |M| [x := |P| [y := \pi_2 |N|]] \rangle& \\
  &|{\bf let \: box \:} y = N {\: \bf in \:} M [x := P]| = & \\
  &\langle \pi_1 |N|, |M| [x := |P|] [y := \pi_2 |N|]\rangle \equiv & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{So far as $y \notin FV(M)$} & \\
  &\langle \pi_1 |N|, |M| [x := |P| [y := \pi_2 |N|]]&
  \end{array}$

\item $|{\bf let \: box \:} \vec{x} = {\bf box \:} \vec{N} {\: \bf in \:} M| = |{\bf box \:} M [\vec{x} := \vec{N}]|$\\

  $\begin{array}{lll}
  &|{\bf let \: box \:} \vec{x} = {\bf box \:} \vec{N} {\: \bf in \:} M| = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &\langle 0 + \dots + 0, |M| [\vec{x} := \vec{|N|}]\rangle \twoheadrightarrow_{\beta}& \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Multistep reduction for natural numbers}& \\
  &\langle 0, |M| [\vec{x} := \vec{|N|}] \rangle = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &|{\bf box \:} M [\vec{x} := \vec{N}]|&
  \end{array}$

\item $|{\bf let \: box \:} x = M {\: \bf in \:} x| = |M|$\\

  $\begin{array}{lll}
  &|{\bf let \: box \:} x = M {\: \bf in \:} x| = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &\langle \pi_1 |M|, x [x := \pi_2 |M|] \rangle = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Substitution}& \\
  &\langle \pi_1 |M|, \pi_2 |M| \rangle \rightarrow_{\eta}& \\
  &\quad\quad\quad\quad\quad\quad\quad \text{$\eta$-reduction for pairs}& \\
  &|M|&
  \end{array}$

\item $\begin{array}{lll}
  &|{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M| = \langle 0 , |M| \rangle = |{\bf box \:} M|&
  \end{array}$
\end{enumerate}

  Hence $\lambda_{\text{IEL}^{-}}$ sounds for $\lambda_{\to, \times, \mathbb{N}}$,
  then multistep reduction in $\lambda_{\text{IEL}^{-}}$ is strongly normalizing, so far as multistep reduction in $\lambda_{\to, \times, \mathbb{N}}$ is strongly normalizing.

  \end{proof}
\end{proof}


\begin{theorem}
  $ $

  $\twoheadrightarrow_r$ is confluent.
\end{theorem}

\begin{proof}
  $ $

By Newman's lemma \cite{Morten}, if relation is strongly normalizing and locally conluent, then this relation is confluent.

It is sufficient to show that $\twoheadrightarrow_r$ is locally confluent.

\begin{lemma} Local confluence

If $M \rightarrow_{r} N$ and $M \rightarrow_{r} Q$, then there exists some term $P$,
such that $N \twoheadrightarrow_{r} P$ and $Q \twoheadrightarrow_{r} P$.

\end{lemma}

\begin{proof}

Let us consider the following critical pairs and show that they are joinable:

\begin{enumerate}
\item $ $ \\

\xymatrix{
{\bf let \: box \:} x = ({\bf let \: box \:} \vec{y} = {\bf box \:} \vec{N} {\: \bf in \:} P) {\: \bf in \:} M \ar[d]_{\beta \Box} \ar[dr]^{\beta \Box {\bf box}} \\
{\bf let \: box \:} \vec{y} = {\bf box \:} \vec{N} {\: \bf in \:} M [x := P] & {\bf let \: box \:} x = {\bf box \:} P [\vec{y} := \vec{N}] {\: \bf in \:} M
}

\vspace{\baselineskip}

$\begin{array}{lll}
&{\bf let \: box \:} \vec{y} = {\bf box \:} \vec{N} {\: \bf in \:} M [x := P] \rightarrow_{\beta \Box {\bf box}}& \\
&\quad\quad\quad\quad\quad\quad\quad {\bf box \:} M [x := P] [\vec{y} := \vec{N}]& \\
&{\bf let \: box \:} x = {\bf box \:} P [\vec{y} := \vec{N}] {\: \bf in \:} M \rightarrow_{\beta \Box {\bf box}}& \\
&\quad\quad\quad\quad\quad\quad\quad {\bf box \:} M [x := P[\vec{y} := \vec{N}]] \equiv & \\
&\text{So far as $x \notin \vec{y}$}& \\
&\quad\quad\quad\quad\quad\quad\quad {\bf box \:} M [x := P] [\vec{y} := \vec{N}] & \\
\end{array}$

\item $ $ \\

\xymatrix{
{\bf let \: box \:} x = ({\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N) {\: \bf in \:} M \ar[d]^{\beta \Box} \ar[dr]^{\beta \Box \underline{\quad}} \\
{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M [x := N] & {\bf let \: box \:} x = {\bf box \:} N {\: \bf in \:} M
}

$\begin{array}{lll}
&{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M [x := N] \rightarrow_{\beta \Box \underline{\quad}} {\bf box \:} (M [x := N])& \\
&{\bf let \: box \:} x = {\bf box \:} N {\: \bf in \:} M \rightarrow_{\beta \Box {\bf box}} {\bf box \:} (M [x := N])&
\end{array}$
\end{enumerate}
\end{proof}

Also we may consider four critical pairs which are considered in
confluence proof for lambda-calculus as based on {\bf IK} \cite{ModalK}.

\end{proof}

\begin{theorem}
  $ $

  Normal form in call-by-name $\lambda_{\text{IEL}^{-}}$ has the subformula property: if $M$ is in normal formal, then its all subterms are in normal form too.

\end{theorem}

\begin{proof}
  $ $

  By induction on the structure of $M$.
  Case with ${\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \:} N$ was considered by Kakutani \cite{ModalK} \cite{ModalK1}.

  If ${\bf box \:} M$ is in normal form, so $M$ is in normal form and its subterms are in normal form too by hypothesis.

  Thus if ${\bf box \:} M$ is in normal form, then all its subterms are in normal form too.
\end{proof}

\section{Categorical semantics}

\begin{defin} Monoidal category

  Monoidal category is a category $\mathcal{C}$ with the following additional structure:
  \begin{enumerate}
    \item A bifunctor $\otimes : \mathcal{C} \times \mathcal{C} \to C$ called tensor product;
    \item Identity object $\mathds{1}$;
    \item A natural isomorphism called associator: $\alpha_{A,B,C}: (A \otimes B) \otimes C \cong A \otimes (B \otimes C)$;
    \item A natural isomorphism called left unitor: $L_A : \mathds{1} \otimes A \cong A$;
    \item A natural isomorphism called right unitor $R_A : A \otimes \mathds{1} \cong A$;
    \item A coherence condition called MacLane pentagon, i.e. the following diagram commutes:

    \xymatrix{
      & (A \otimes (B \otimes C)) \otimes D \ar[dr]^{\alpha_{A,B \otimes C,D}}\\
      ((A \otimes B) \otimes C) \otimes D \ar[d]_{\alpha_{A \otimes B, C, D}} \ar[ur]^{\alpha_{A,B,C} \otimes id_D \quad} && A \otimes ((B \otimes C) \otimes D) \ar[d]^{id_A \otimes \alpha_{B,C,D}}\\
      (A \otimes B) \otimes (C \otimes D) \ar[rr]_{\alpha_{A,B,C \otimes D}}&& A \otimes (B \otimes (C \otimes D))
    }
    \item A coherence condition called triangle identity:

    \xymatrix{
    && (A \otimes \mathds{1}) \otimes B \ar[rr]^{\alpha_{A, \mathds{1}, B}} \ar[dr]_{R_A \otimes id_B} && A \otimes (\mathds{1} \otimes B) \ar[dl]^{id_A \otimes L_B} \\
    &&& A \otimes B
    }
  \end{enumerate}
\end{defin}

\begin{defin} Cartesian closed category

  Cartesian closed category is a category with a terminal object, finite products and exponentiation.
\end{defin}

Note that, any cartesian closed category is the special case of a monoidal category, where tensor is a product and identity object is a terminal object.

\begin{defin} Monoidal functor

  Let $\langle \mathcal{C}, \otimes_1, \mathds{1}_{\mathcal{C}} \rangle$ and $\langle \mathcal{D}, \otimes_2, \mathds{1}_{\mathcal{D}} \rangle$ are monoidal categories.

  A monoidal functor $\mathcal{F} : \langle \mathcal{C}, \otimes_1, \mathds{1} \rangle \to \langle \mathcal{D}, \otimes_2, \mathds{1}' \rangle$ is a functor
  $\mathcal{F} : \mathcal{C} \to \mathcal{D}$ with natural transformations:

  \begin{enumerate}
  \item $u : \mathds{1}_{\mathcal{D}} \to \mathcal{F}\mathds{1}_{\mathcal{C}}$;
  \item $A \varoast B : \mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}B \to \mathcal{F}(A \otimes_{\mathcal{C}} B)$.
\end{enumerate}

  and coherence maps:

  \begin{itemize}
    \item Associativity:

  \xymatrix{
    && (\mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}B) \otimes_{\mathcal{D}} \mathcal{F}C \ar[d]_{(A \varoast B) \otimes_{\mathcal{D}} id_{\mathcal{F}B}}
    \ar[rr]^{\alpha^{\mathcal{D}}_{{\mathcal{F}A, \mathcal{F}B, \mathcal{F}C}}} && \mathcal{F}A \otimes_{\mathcal{D}} (\mathcal{F}B \otimes_{\mathcal{D}} \mathcal{F}C) \ar[d]^{id_{\mathcal{F}A} \otimes_{\mathcal{D}} B \varoast C}\\
    && \mathcal{F}(A \otimes_{\mathcal{C}} B) \otimes_{\mathcal{D}} \mathcal{C} \ar[d]_{(A \otimes_{\mathcal{C}} B) \varoast C} && \mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}(B \otimes_{\mathcal{C}} C) \ar[d]^{A \varoast (B \otimes_{\mathcal{C}} C) }\\
    && \mathcal{F}((A \otimes_{\mathcal{C}} B) \otimes_{\mathcal{C}} C) \ar[rr]_{\mathcal{F}(\alpha^{\mathcal{C}}_{A,B,C})}&& \mathcal{F}(A \otimes_{\mathcal{C}} (B \otimes_{\mathcal{C}} C))
  }

    \item Left unitality:

    \xymatrix{
    &&  \mathds{1}_{\mathcal{D}} \otimes_{\mathcal{D}} \mathcal{F}A \ar[d]_{L^{\mathcal{D}}_{\mathcal{F}A}}\ar[rr]^{u \otimes_{\mathcal{D}} id_{\mathcal{F}A}} && \mathcal{F}\mathds{1}_{\mathcal{C}} \otimes_{\mathcal{D}} \mathcal{F}A \ar[d]^{\mathds{1}_{\mathcal{C}} \varoast A} \\
    &&  \mathcal{F}A && \mathcal{F}(\mathds{1}_{\mathcal{C}} \otimes_{\mathcal{C}} A) \ar[ll]_{\mathcal{F}(L^{\mathcal{C}}_A)}
    }

    \item Right unitality:

    \xymatrix{
    &&  \mathcal{F}A \otimes_{\mathcal{D}} \mathds{1}_{\mathcal{D}} \ar[d]_{R^{\mathcal{D}}_{\mathcal{F}A}}\ar[rr]^{id_{\mathcal{F}A} \otimes_{\mathcal{D}} u} && \mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}\mathds{1}_{\mathcal{C}} \ar[d]^{A \varoast \mathds{1}_{\mathcal{C}}} \\
    &&  \mathcal{F}A && \mathcal{F}(A \otimes_{\mathcal{C}} \mathds{1}_{\mathcal{C}} ) \ar[ll]^{\mathcal{F}(R^{\mathcal{C}}_A)}
    }
  \end{itemize}
\end{defin}

\begin{defin} Applicative functor

  An applicative functor is a triple $\langle \mathcal{C}, \mathcal{F}, \eta \rangle$,
where $\mathcal{C}$ is a monoidal category, $\mathcal{F}$ is a monoidal endofunctor and $\eta : Id_{\mathcal{C}} \Rightarrow \mathcal{F}$ is a natural transformation (similar to unit in monad), such that:

\begin{enumerate}
\item $u = \eta_{\mathds{1}}$;
\item $A \varoast B \circ (\eta_A \otimes \eta_B) = \eta_{A \otimes B}$, i.e. the following diagram commutes:

\xymatrix
{
&&& A \otimes B \ar[rr]^{\eta_A \otimes \eta_B} \ar[drr]_{\eta_{A \otimes B}} && \mathcal{F}A \otimes \mathcal{F}B \ar[d]^{A \varoast B} \\
&&&&& \mathcal{F}(A \otimes B)
}
\end{enumerate}
\end{defin}


By default we will consider an arbitrary monoidal functor on cartesian closed category below.

\subsection{Soundness and completeness}

\begin{defin} Semantical translation from $\lambda_{\text{IEL}^{-}}$ to some cartesian closed category $\mathcal{C}$ with an applicative functor $\langle \mathcal{C}, \boxdot, \eta \rangle$:

\begin{enumerate}
\item Interpretation for types:
  \begin{itemize}
    \item $[\![A]\!] := \hat{A}, A \in \mathbb{T}$, where $\hat{A}$ is an object of $\mathcal{C}$ obtained by some given assignment;
    \item $[\![A \to B]\!] := [\![B]\!]^{[\![A]\!]}$;
    \item $[\![A \times B]\!] := [\![A]\!] \times [\![B]\!]$.
  \end{itemize}
\item Interpretation for modal types:
  \begin{enumerate}
    \item $[\![\Box A]\!] = \boxdot [\![A]\!]$;
  \end{enumerate}
\item Interpretaion for contexts:
  \begin{enumerate}
    \item $[\![ \quad ]\!] = \mathds{1}$, where $\mathds{1}$ is a terminal object of a given ccc;
    \item $[\![\Gamma, x : A]\!] = [\![\Gamma]\!] \times [\![A]\!]$
  \end{enumerate}
\item Interpretation for typing assignment:
  \begin{enumerate}
    \item $[\![\Gamma \vdash M : A]\!] := [\![M]\!] : [\![\Gamma]\!] \to [\![A]\!]$.
  \end{enumerate}
\item Interpretation for typing rules:

\begin{prooftree}
\AxiomC{$ $}
\UnaryInfC{$[\![\Gamma, x : A \vdash x : A]\!] = \pi_2 : [\![\Gamma]\!] \times [\![A]\!] \rightarrow
[\![A]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma, x : A \vdash M : B]\!] = [\![M]\!] : [\![\Gamma]\!] \times [\![A]\!] \rightarrow [\![B]\!]$}
\UnaryInfC{$[\![\Gamma \vdash (\lambda x. M) : A \to B]\!] = \Lambda([\![M]\!]) : [\![\Gamma]\!]
\rightarrow[\![B]\!]^{[\![A]\!]}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A \to B]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![B]\!]^{[\![A]\!]}$}
\AxiomC{$[\![\Gamma \vdash N : A]\!] = [\![N]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M N) : B]\!] = [\![\Gamma]\!] \xrightarrow{\langle [\![M]\!], [\![N]\!]
\rangle} [\![B]\!]^{[\![A]\!]} \times [\![A]\!] \xrightarrow{\epsilon_{[\![A]\!],[\![B]\!]}} [\![B]\!] $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A ]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\AxiomC{$[\![\Gamma \vdash N : B ]\!] = [\![N]\!] : [\![\Gamma]\!] \rightarrow [\![B]\!]$}
\BinaryInfC{$[\![\Gamma \vdash \langle M, N \rangle : A \times B]\!] = \langle [\![M]\!], [\![N]\!] \rangle : [\![\Gamma]\!] \rightarrow
[\![A]\!] \times [\![B]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A_1 \times A_2]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A_1]\!] \times
[\![A_2]\!]$}
\RightLabel{$i = 1,2$}
\UnaryInfC{$[\![\Gamma \vdash \pi_i M : A_i]\!] = [\![\Gamma]\!] \xrightarrow{[\![M]\!]} [\![A_1]\!] \times
[\![A_2]\!] \xrightarrow{\pi_i} [\![A_i]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\UnaryInfC{$[\![\Gamma \vdash {\bf box \:} M : \Box A]\!] := [\![\Gamma]\!] \xrightarrow{[\![M]\!]}
[\![A]\!] \xrightarrow{\eta_{[\![A]\!]}} \boxdot [\![A]\!]$}
\end{prooftree}

\begin{small}
  \begin{prooftree}
    \AxiomC{$[\![\Gamma \vdash \vec{M} : \Box \vec{A}]\!] = \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \prod \limits_{i=1}^n \boxdot [\![A_i]\!]$}
    \AxiomC{$[\![\vec{x} : \vec{A} \vdash N : B]\!] = [\![N]\!] : \prod \limits_{i=1}^n [\![A_i]\!] \rightarrow [\![B]\!]$}
    \BinaryInfC{$[\![\Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } M : \Box B]\!] = \boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \boxdot [\![B]\!]$}
  \end{prooftree}
\end{small}
\end{enumerate}
\end{defin}

Interpretation for ${\bf let \: box\:}$-rule is similar to interpretation for $\Box$-rule in term calculus for intutionistic {\bf K} \cite{Paiva}.

\begin{theorem} Soundness

  Let $\Gamma \vdash M : A$ and $M =_r N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$
\end{theorem}

\begin{proof}


\begin{lemma}
$ $

$[\![M [x_1 := M_1,\dots, x_n := M_n]]\!] = [\![M]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle$.

\end{lemma}

\begin{proof}

$ $

1)

$\begin{array}{lll}
& [\![\Gamma \vdash ({\bf box \:} M) [ \vec{x} := \vec{M}] : \Box A]\!] = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By substitution definition}& \\
&[\![ \Gamma \vdash {\bf box \:} (M [ \vec{x} := \vec{M}]) : \Box A]\!]& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Interpretation for {\bf box}}\\
&\eta_{[\![A]\!]} \circ [\![(M [ \vec{x} := \vec{M}])]\!]& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Assumption} \\
&\eta_{[\![A]\!]} \circ ([\![M]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle) = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}&\\
&(\eta_{[\![A]\!]} \circ [\![M]\!]) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle = & \\
&\quad\quad\quad\quad\quad\quad\quad  \text{Interpretation for {\bf box}}& \\
&[\![ \Gamma \vdash {\bf box \:} M : \Box A]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle = & \\
\end{array}$

\vspace{\baselineskip}

2)

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash ({\bf let \: box} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : \Box B]\!] =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Substitution} &\\
&[\![\Gamma \vdash {\bf let \: box} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N : \Box B]\!] =& \\
&\quad\quad\quad\quad\quad\quad\quad  \text{Interpretation for $let_{\Box}$} \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ [\![\Gamma \vdash (\vec{M} [\vec{y} := \vec{P}]) : \Box \vec{A}]\!] =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Induction hypothesis}& \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ ([\![\vec{M}]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle) = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}& \\
&(\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ [\![\vec{M}]\!]) \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{Interpretaion}& \\
&[\![\Gamma \vdash {\bf let \: box} \: \vec{x} = \vec{M} {\: \bf in \:} N : \Box B]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle&
\end{array}$

\end{proof}

\begin{lemma}
  $ $

  Let $\Gamma \vdash M : A$ and $M \to_r N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$;
\end{lemma}

\begin{proof}
  $ $

Cases with $\beta$-reductions for $let_{\Box}$ are shown in \cite{ModalK1}. Let us consider cases with ${\bf box}$.

\vspace{\baselineskip}

1) $[\![\Gamma \vdash {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N : \Box B]\!] = [\![\Gamma \vdash {\bf box \:} N [\vec{x} := \vec{M}] : \Box B]\!]$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N : \Box B]\!] = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpretation}& \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ \langle \eta_{[\![A_1]\!]} \circ [\![M_1]\!],\dots,\eta_{[\![A_n]\!]} \circ [\![M_n]\!] \rangle = \\
&\quad\quad\quad\quad\quad\quad\quad \text{By the property of a pair of morphisms}& \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ (\eta_{[\![A_1]\!]} \times \dots \times \eta_{[\![A_n]\!]}) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]\rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}& \\
&\boxdot ([\![N]\!]) \circ (([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ (\eta_{[\![A_1]\!]} \times \dots \times \eta_{[\![A_n]\!]})) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{By the definition of an applicative functor}& \\
&\boxdot ([\![N]\!]) \circ \eta_{[\![A_1]\!] \times \dots \times [\![A_n]\!]} \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Naturality of $\eta$}& \\
&\eta_{[\![B]\!]} \circ [\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}& \\
&\eta_{[\![B]\!]} \circ ([\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]) \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Substitution lemma}& \\
&\eta_{[\![B]\!]} \circ [\![\Gamma \vdash N [\vec{x} := \vec{M}] : \Box B]\!]& \\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpetation}& \\
&[\![\Gamma \vdash {\bf box \:} (N [\vec{x} := \vec{M}]) : \Box B]\!]&
\end{array}$

\vspace{\baselineskip}

2) $[\![\vdash {\bf let \: box \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : \Box A]\!] = [\![\vdash {\bf box \:} M : \Box A]\!]$

$\begin{array}{lll}
&[\![\vdash {\bf let \: box \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : \Box A]\!] = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpretation}& \\
&\boxdot ([\![M]\!]) \circ u_{\mathds{1}} = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By the definition of an applicative functor}& \\
&\boxdot ([\![M]\!]) \circ \eta_{\mathds{1}} = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By naturality of $\eta$} & \\
&\eta_{[\![A]\!]} \circ [\![M]\!] = &\\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpretation} & \\
&[\![\vdash {\bf box \:} M : \Box A]\!]&
\end{array}$
\end{proof}

\end{proof}

\begin{theorem} Completeness

Let $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$, then $M =_r N$.
\end{theorem}

\begin{proof}

$ $

We will consider term model for simply typed lambda calculus $\times$ and $\to$ standardly described in \cite{LambekScott}:

\begin{defin} Equivalence on term pairs:
  $ $

  Let us define relation $\sim_{A, B} \subseteq (\mathbb{V} \times \Lambda_{\Box})^2$, such that:

  $(x, M) \sim_{A, B} (y, N) \Leftrightarrow x : A \vdash M : B \:\: \& \:\: y : A \vdash N : A \:\: \& \:\: M =_r N [y := x]$;
\end{defin}

We will denote equivalence class as $[x, M]_{A, B} = \{ (y, N) \: | \: (x, M) \sim_{A, B} (y, N) \}$ (we will drop indices below).


\begin{defin} Category $\mathcal{C}(\lambda)$:
\begin{enumerate}
  \item $Ob_{\mathcal{C}} = \{ \hat{A} \: | \: A \in \mathbb{T} \} \cup \{ \mathds{1} \}$;
  \item $Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B}) = \{ [x, M] \: | \: x : A \vdash_{\lambda_{\text{IEL}^{-}}} M : B \}$;
  \item Let $[x, M] \in Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B})$ and $[y,N] \in Hom_{\mathcal{C}(\lambda)}(\hat{B},\hat{C})$, then $[y,M] \circ [x, M] = [x, N [y := M]]$;
  \item Identity morphism $id_{\hat{A}} = [x,x] \in Hom_{\mathcal{C}(\lambda)(\hat{A}, \hat{A})}$;
  \item $\mathds{1}$ is a terminal object;
  \item $\widehat{A \times B} = \hat{A} \times \hat{B}$;
  \item Canonical projection is defined as $[x, \pi_i x] \in Hom_{\mathcal{C}(\lambda)}(\hat{A_1} \times \hat{A_2},\hat{A_i})$ for $i = 1, 2$;
  \item $\widehat{A \to B} = \hat{B}^{\hat{A}}$;
  \item Evaluation arrow $\epsilon_{\hat{A},\hat{B}} = [x, (\pi_1 x) (\pi_2 x)] \in Hom_{\mathcal{C}(\lambda)}(\hat{B}^{\hat{A}} \times \hat{A}, \hat{B})$.
\end{enumerate}
\end{defin}

We define endofunctor $\boxdot$ on $\mathcal{C}(\lambda)$ and natural transformation $\eta$ from $id_{\mathcal{C}(\lambda)}$ to this endofunctor.
It is sufficient to show $\boxdot$ and $\eta$ form the relevant structure on $\mathcal{C}(\lambda)$.

\begin{defin}
  Let us define an endofunctor $\boxdot : \mathcal{C}(\lambda) \to \mathcal{C}(\lambda)$, such that
forall $[x,M] \in Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B}), \boxdot ([x,M]) = [y, {\bf let \: box \:} x = y {\: \bf in \:} M] \in Hom_{\mathcal{C}(\lambda)}(\boxdot \hat{A}, \boxdot \hat{B})$.

\end{defin}

\begin{lemma} Functoriality

\begin{enumerate}
  \item $\boxdot(g \circ f) = \boxdot g \circ \boxdot f$;
  \item $\boxdot (id_{\hat{A}}) = id_{\boxdot \hat{A}}$.
\end{enumerate}
\end{lemma}

\begin{proof}

Easy checking using reduction rules.

\end{proof}

\begin{defin}

  Let us define natural transformations:

\begin{enumerate}
  \item $\eta: Id_{\mathcal{C}(\lambda)} \Rightarrow \boxdot\text{, s. t. }\forall \hat{A} \in Ob_{\mathcal{C}(\lambda)}$, $\eta_{\hat{A}} = [x, {\bf box \:} x] \in Hom_{\mathcal{C}(\lambda)}(\hat{A}, \boxdot \hat{A})$;
  \item $\hat{A} \varoast \hat{B} : \boxdot \hat{A} \times \boxdot \hat{B} \to \boxdot (\hat{A} \times \hat{B})\text{, s. t. } \forall \hat{A}, \hat{B} \in Ob_{\mathcal{C}(\lambda)}, \hat{A} \varoast \hat{B} = [p, {\bf let \: box \:} x,y = \pi_1 p, \pi_2 p {\: \bf in \:} \langle x, y \rangle] \in Hom_{\mathcal{C}(\lambda)}(\boxdot \hat{A} \times \boxdot \hat{B}, \boxdot (\hat{A} \times \hat{B}))$.
\end{enumerate}
\end{defin}

Implementation for $\varoast$ in our term model is the instance of ${\text{let}_{\Box}}$-rule:

\begin{small}
\begin{prooftree}
\AxiomC{$p : \Box A \times \Box B \vdash p : \Box A \times \Box B$}
\RightLabel{$\times_E$}
\UnaryInfC{$p : \Box A \times \Box B \vdash \pi_1 p : \Box A$}
\AxiomC{$p : \Box A \times \Box B \vdash p : \Box A \times \Box B$}
\RightLabel{$\times_E$}
\UnaryInfC{$p : \Box A \times \Box B \vdash \pi_2 p : \Box B$}
\AxiomC{$x : A \vdash x : A$}
\AxiomC{$y : B \vdash y : B$}
\RightLabel{$\times_I$}
\BinaryInfC{$x : A, y : B \vdash \langle x, y \rangle : A \times B$}
\RightLabel{${\bf let}_{\Box}$}
\TrinaryInfC{$p : \Box A \times \Box B \vdash {\bf let \: box \:} x,y = \pi_1 p, \pi_2 p {\: \bf in \:} \langle x, y \rangle : \Box (A \times B)$}
\end{prooftree}
\end{small}

\begin{lemma}
  $ $

  $\boxdot$ is a monoidal endofunctor
\end{lemma}

\begin{proof}
$ $

See \cite{ModalK}
\end{proof}

\begin{lemma} Naturality and coherence for $\eta$:

\begin{enumerate}
  \item $\boxdot f \circ \eta_A = \eta_B \circ f$;
  \item $(\hat{A} \varoast \hat{B}) \circ (\eta_{A} \times \eta_{B}) = \eta_{\hat{A} \times \hat{B}}$;
\end{enumerate}
\end{lemma}

\begin{proof}
  $ $

\begin{enumerate}
\item $\boxdot f \circ \eta_{\hat{A}} = \eta_{\hat{B}} \circ f$ \\

$\begin{array}{lll}
&\eta_{\hat{B}} \circ f = & \\
&[y, {\bf box \:} y] \circ [x, M] = &\\
&\quad\quad\quad\quad\quad\quad \text{Composition} & \\
&[x, {\bf box \:} y [y := M]] = &\\
&\quad\quad\quad\quad\quad\quad \text{By substitution}& \\
&[x, {\bf box \:} M]& \\
& &\\
&\text{On the other hand:}& \\
&\boxdot f \circ \eta_{\hat{A}} = & \\
&[z, {\bf let \: box \:} x = z {\: \bf in \:} M] \circ [x, {\bf box \:} x] = &\\
&\quad\quad\quad\quad\quad\quad \text{By the definition of composition}& \\
&[x, {\bf let \: box \:} x = z {\: \bf in \:} M [z := {\bf box \:} x]] = & \\
&\quad\quad\quad\quad\quad\quad \text{By substitution}& \\
&[x, {\bf let \: box \:} x = {\bf box \:} x {\: \bf in \:} M] = & \\
&\quad\quad\quad\quad\quad\quad \text{$\beta$-reduction rule}& \\
&[x, {\bf box \:} M [x := x]] = &\\
&\quad\quad\quad\quad\quad\quad \text{By substitution} & \\
&[x, {\bf box \:} M]&
\end{array}$

\item $(\hat{A} \varoast \hat{B}) \circ (\eta_{A} \times \eta_{B}) = \eta_{\hat{A} \times \hat{B}}$ \\

$\begin{array}{lll}
& (\hat{A} \varoast \hat{B}) \circ (\eta_{A} \times \eta_{B}) = & \\
& [q, {\bf let \: box \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle] \circ [p, \langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{Composition}& \\
& [p, {\bf let \: box \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle [q := \langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle]] = & \\
& \quad\quad\quad\quad\quad\quad \text{By substitution}& \\
& [p, {\bf let \: box \:} x, y = \pi_1 (\langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle), \pi_2 (\langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle) {\: \bf in \:} \langle x, y \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{Reduction rules}& \\
& [p, {\bf let \: box \:} x, y = {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) {\: \bf in \:} \langle x, y \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{Reduction rule}& \\
& [p, {\bf box \:} (\langle x,y \rangle [x := \pi_1 p, y := \pi_2 p])] = & \\
& \quad\quad\quad\quad\quad\quad \text{Substitution}& \\
& [p, {\bf box \:} \langle \pi_1 p, \pi_2 p \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{$\eta$-reduction}& \\
& [p, {\bf box \:} p] =& \\
& \quad\quad\quad\quad\quad\quad \text{By definition}& \\
& \eta_{\hat{A} \times \hat{B}}&
\end{array}$
\end{enumerate}
\end{proof}

\begin{defin}
  $ $

  $u_{\mathds{1}} = [\sqbullet, {\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} \sqbullet] \in Hom_{\mathcal{C}(\lambda)}(\mathds{1}, \boxdot \mathds{1})$.
\end{defin}

\begin{lemma}
  $ $

  $u_{\mathds{1}} = \eta_{\mathds{1}}$

\end{lemma}

\begin{proof}

  Immediately.
\end{proof}

\begin{lemma}

  $\langle \mathcal{C}(\lambda), \boxdot, \eta \rangle$ is an applicative functor
\end{lemma}

\begin{proof}
  Immediately follows from previous lemmas in the section.
\end{proof}

\end{proof}

\section{Relation with Moggi's monadic metalanguage}

\begin{defin} Monadic metalanguage

  Monadic metalanguage is a simply typed lambda calculus with additional typing rules \cite{Moggi}:

\begin{minipage}{0.45\textwidth}
\begin{prooftree}
  \AxiomC{$\Gamma \vdash M : A$}
  \RightLabel{$\bigcirc_I$}
  \UnaryInfC{$\Gamma \vdash {\bf val \:} M : \bigcirc A$}
\end{prooftree}
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}
\begin{tabular}{p{\textwidth}}
\begin{prooftree}
  \AxiomC{$\Gamma \vdash M : \bigcirc A$}
  \AxiomC{$\Gamma, x : A \vdash N : \bigcirc B$}
  \RightLabel{$\bigcirc_E$}
  \BinaryInfC{$\Gamma \vdash {\bf let \: val \:} x = M {\: \bf in \:} N : \bigcirc B$}
\end{prooftree}
\end{tabular}
\end{minipage}

\end{defin}

\begin{defin} Reduction rules for monadic metalanguage
  \begin{enumerate}
    \item ${\bf let \: val \:} x = {\bf val \:} M {\: \bf in \:} N \rightarrow_{\beta} N [x := M]$;
    \item ${\bf let \: val \:} x = ({\bf let \: val \:} y = N {\: \bf in \:} P) {\: \bf in \:} M \rightarrow_{\beta} {\bf let \: val \:} y = N {\: \bf in \:} ({\bf let \: val \:} x = P {\: \bf in \:} M)$;
    \item ${\bf let \: val \:} x = M {\: \bf in \:} {\bf val} x \rightarrow_{\eta} M$.
  \end{enumerate}
\end{defin}

Let us define translation $\ulcorner . \urcorner$ from $\lambda_{\text{IEL}^{-}}$ into monadic metalanguage.
Without loss of generality we will consider $\lambda_{\text{IEL}^{-}}$ with $\to$ and $\Box$:

\begin{defin} Translation for types
  \begin{enumerate}
    \item $\ulcorner A \urcorner = A$ for an atomic $A$;
    \item $\ulcorner A \to B \urcorner = \ulcorner A \urcorner \to \ulcorner B \urcorner$;
    \item $\ulcorner \Box A \urcorner = \bigcirc \ulcorner A \urcorner$
  \end{enumerate}
\end{defin}

\begin{defin} Translation for terms
  \begin{enumerate}
    \item $\ulcorner x \urcorner = x$ for $x \in \mathbb{V}$;
    \item $\ulcorner \lambda x. M \urcorner = \lambda x. \ulcorner M \urcorner$;
    \item $\ulcorner M N \urcorner = \ulcorner M \urcorner \ulcorner N \urcorner$;
    \item $\ulcorner {\bf box \:} M \urcorner = {\bf val \:} \ulcorner M \urcorner$
    \item $\ulcorner {\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N \urcorner = {\bf val \:} \ulcorner N \urcorner$;
    \item $\ulcorner {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \:} N \urcorner = {\bf let \: val \:} \vec{x} = \ulcorner \vec{M} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner N \urcorner$;
  \end{enumerate}
\end{defin}

Where $\ulcorner \Gamma \urcorner \vdash {\bf let \: val \:} \vec{x} = \ulcorner \vec{M} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner N \urcorner$
denotes ${\bf let \: val \:} x_1 = \ulcorner M_1 \urcorner {\: \bf in \:} ( \dots {\: \bf in \:} ({\bf let \: val \:} x_n = \ulcorner M_n \urcorner {\: \bf in \:} {\bf val \:} \ulcorner N \urcorner) \dots )$.
\begin{defin} Interpretation for modal rules
  \begin{prooftree}
    \AxiomC{$\ulcorner \Gamma \vdash M : A \urcorner = \ulcorner \Gamma \urcorner \vdash \ulcorner M \urcorner : \ulcorner A \urcorner$}
    \UnaryInfC{$\ulcorner \Gamma \vdash {\bf box \:} M : \Box A \urcorner = \ulcorner \Gamma \urcorner \vdash {\bf val \:} \ulcorner M \urcorner : \bigcirc \ulcorner A \urcorner$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ulcorner \Gamma \vdash \vec{M} : \Box \vec{A} \urcorner = \ulcorner \Gamma \urcorner \vdash \ulcorner \vec{M} \urcorner : \bigcirc \ulcorner \vec{A} \urcorner$}
    \AxiomC{$\ulcorner \vec{x} : \vec{A} \vdash N : B \urcorner = \vec{x} : \ulcorner \vec{A} \urcorner \vdash \ulcorner N \urcorner : \ulcorner B \urcorner$}
    \UnaryInfC{$\vec{x} : \ulcorner \vec{A} \urcorner \vdash {\bf val \:} \ulcorner N \urcorner : \bigcirc \ulcorner B \urcorner$}
    \BinaryInfC{$\ulcorner \Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \:} N : \Box B \urcorner = \ulcorner \Gamma \urcorner \vdash {\bf let \: val \:} \vec{x} = \ulcorner \vec{M} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner N \urcorner : \bigcirc \ulcorner B \urcorner$}
  \end{prooftree}
\end{defin}


\begin{lemma}
  $ $

  $\ulcorner M [x := N] \urcorner = \ulcorner M \urcorner [x := \ulcorner N \urcorner]$
\end{lemma}

\begin{proof}
  Induction on the structure of $M$.
\end{proof}

\begin{lemma}
  $ $

  If $M =_{r} N$, then $\ulcorner M \urcorner =_{\beta \eta} \ulcorner N \urcorner$.
\end{lemma}

\begin{proof}
$ $

1) \\
$\begin{array}{lll}
&\ulcorner {\bf let \: box \:} x = ({\bf let \: box \:} \vec{y} = \vec{N} {\: \bf in \:} P) {\: \bf in \:} M \urcorner = & \\
&\quad {\bf let \: val \:} x = ({\bf let \: val \:} \vec{y} = \ulcorner \vec{N} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner P \urcorner) {\: \bf in \:} {\bf val \:} \ulcorner M \urcorner \rightarrow_{\beta} & \\
&\quad {\bf let \: val \:} \vec{y} = \ulcorner \vec{N} \urcorner {\: \bf in \:} ({\bf let \: val \:} x = \ulcorner P \urcorner {\: \bf in \:} {\bf val \:} \ulcorner M \urcorner) \rightarrow_{\beta} & \\
&\quad {\bf let \: val \:} \vec{y} = \ulcorner \vec{N} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner M \urcorner [x := \ulcorner P \urcorner] = & \\
&\ulcorner {\bf let \: box \:} \vec{y} = \vec{N} {\: \bf in \:} M [x := P] \urcorner&
\end{array}$

\vspace{\baselineskip}

2) \\
$\begin{array}{lll}
&\ulcorner {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{N} {\: \bf in \:} M \urcorner = & \\
&\quad {\bf let \: val \:} \vec{x} = {\bf val \:} \ulcorner \vec{N} \urcorner {\: \bf in \:} {\bf val} \ulcorner M \urcorner \rightarrow_{\beta} & \\
&\quad {\bf val \:} \ulcorner M \urcorner [\vec{x} := \ulcorner \vec{N} \urcorner] =& \\
&\ulcorner {\bf box \:} M [\vec{x} := \vec{N}] \urcorner&
\end{array}$

\vspace{\baselineskip}

3) \\
$\begin{array}{lll}
&\ulcorner {\bf let \: box \:} x = M {\: \bf in \:} x \urcorner = & \\
&\quad {\bf let \: val \:} x = \ulcorner M \urcorner {\: \bf in \:} {\bf val \:} x \rightarrow_{\eta}& \\
&\ulcorner M \urcorner&
\end{array}$

\end{proof}

\begin{theorem}
  $ $

  If $\Gamma \vdash M : A$, then $\ulcorner \Gamma \urcorner \vdash \ulcorner M \urcorner : \ulcorner A \urcorner$
\end{theorem}

\begin{proof}
  Follows from lemmas above.
\end{proof}


\section{Acknowledgment}

  We are grateful to Neel Krishnaswami, Vladimir Krupski, Valeria de Paiva, Valerii Plisko and Vladimir Vasyukov for consulting and advice.

  The research described in this paper was supported by Russian Foundation for Basic Research (grant 16-03-00364).

  \addcontentsline{toc}{section}{References}

  \begin{thebibliography}{}

  \bibitem{Abe} T. Abe, Completeness of modal proofs in first-order predicate logic, Computer Software, JSSST Journal. 24 (2007).

  \bibitem{Abramsky} S. Abramsky and N. Tzevelekos, Introduction to Categories and Categorical Logic, in: B. Coecke, ed., New Structures for Physics.
  Lecture Notes in Physics, vol. 813 (Springer-Verlag, Berlin, 2011).

  \bibitem{Artemov} S. Artemov and T. Protopopescu, Intuitionistic Epistemic Logic, The
  Review of Symbolic Logic. 9 (2016).

  \bibitem{Awodey} S. Awodey, Category Theory (2nd ed.), Oxford University Press, 2010.

  \bibitem{Baren2} H. P. Barendregt, The Lambda Calculus --- Its Syntax and Semantics, North-Holland, 1985.

  \bibitem{Baren} H.P. Barendregt. Lambda calculi with types, in: S. Abramsky, Dov M. Gabbay, and S. E.
  Maibaum, eds., Handbook of logic in computer science (vol. 2), Osborne Handbooks Of Logic In Computer
  Science, vol. 2. (Oxford University Press, New York, 1993).

  \bibitem{Paiva} G. Bellin, V. C. V. de Paiva, and E. Ritter. Extended Curry-Howard correspondence for a basic constructive modal logic, Proceedings of Methods for Modalities, 2001.

  \bibitem{ElKelly} S. Eilenberg and M. Kelly. Closed categories, Proc. Conf. Categorical Algebra, La Jolla, (1965).

  \bibitem{Girard} J.-Y. Girard, P. Taylor and Y. Lafont, Proofs and Types, Cambridge University
  Press, 1989.

  \bibitem{Hindley} J. Roger Hindley, Basic Simple Type Theory, Cambridge University Press, 1997.

  \bibitem{ModalK} Y. Kakutani. A Curry-Howard Correspondence for Intuitionistic Normal Modal Logic. // Computer Software, 2008.

  \bibitem{ModalK1} Y. Kakutani, Call-by-Name and Call-by-Value in Normal Modal Logic, in: Shao Z. (eds)
  Programming Languages and Systems, Lecture Notes in Computer Science, vol 4807 (2016).

  \bibitem{ModalLa} G. A. Kavvos. The Many Worlds of Modal $\lambda$--calculi: I. Curry-Howard for Necessity, Possibility and Time. // [Электронный ресурс] URL: https://arxiv.org/abs/1605.08106

  \bibitem{Krupski} V. N. Krupski and A. Yatmanov. Sequent Calculus for Intuitionistic Epistemic Logic IEL,
   in: Artemov S., Nerode A. (eds), Logical Foundations of Computer Science. Lecture Notes in Computer Science, vol 9537. Springer, Cham (2016).

  \bibitem{LambekScott} J. Lambek and P.J. Scott, Introduction to Higher Order Categorical Logic, Cambridge University Press, 1986.

  \bibitem{MacLane} S. MacLane. Categories for the Working Mathematician, Graduate Texts in Mathematics, Springer-Verlag, 1998.

  \bibitem{McP} C. McBride and R. Paterson, Applicative programming with effects, Journal of
  Functional Programming, 18 (2008).

  \bibitem{McP2} C. McBride and R. Paterson, Functional Pearl. Idioms: applicative programming with
  effects, Journal of Functional Programming, 18 (2005).

  \bibitem{Moggi} E. Moggi, Notions of computation and monads, Inf. Comput., 93 (1) (1991).

  \bibitem{Neder} R. Nederpelt and H. Geuvers, Type Theory and Formal Proof: An Introduction.
  Cambridge University Press, 2014.

  \bibitem{Cons} R. Paterson, Constructing applicative functors,
  in: Mathematics of Program Construction, Lecture Notes in Computer Science (Springer, Berlin, 2012).

  \bibitem{Lax} F. Pfenning and R. Davies. A judgmental reconstruction of modal logic.
  Mathematical Structures in Computer Science, vol. 11 (2001).

  \bibitem{Pierce} B. C. Pierce, Types and Programming Languages, The MIT
  Press, 2002.

  \bibitem{Morten} M. H. Sorensen and P. Urzyczyn, Lectures on the Curry-Howard isomorphism, Elsevier Science, 1998.
  pp 261.

  \bibitem{Troelstra} A.S. Troelstra and H. Schwichtenberg, Basic Proof Theory, Cambridge University Press, 1996.
  \end{thebibliography}

\end{document}
