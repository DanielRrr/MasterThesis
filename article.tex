\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{dsfont}
\usepackage{mathabx}
\usepackage{stmaryrd}
\usepackage[all, 2cell]{xy}
\usepackage[all]{xy}
\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{defin}{Definition}
\newtheorem{ex}{Example}
\newtheorem{col}{Corollary}
\newtheorem{con}{Consequence}
\usepackage{listings} 		% for source code
\date{}
\title{Modal type theory based on the intuitionistic epistemic logic}

\begin{document}
\maketitle

\begin{abstract}
Modal intuitionistic epistemic logic IEL$^{-}$ was proposed by S.Artemov and T. Protopopescu as the formal
foundation for the intuitionistic theory of knowledge. We construct a modal simply typed lambda-calculus
which is Curry-Howard isomorphic to IEL$^{-}$ as formal theory of calculations with applicative functors in
functional programming languages like Haskell or Idris.
\end{abstract}


  \section{Introduction}

  Modal intutionistic epistemic logic IEL was proposed by S. Artemov and T. Proropopescu \cite{Artemov}. IEL
  provides the epistimology and the theory of knowledge as based on BHK-semantics of intuitionistic logic.
  IEL$^{-}$  is a variant of IEL, that corresponds to intuitionistic belief.
  Informally, $\Box A$ denotes that $A$ is verified intuitionistically.

  Intuitionistic epistemic logic IEL$^{-}$ is defined by following axioms and derivation rules:

  \begin{defin} Intuitionistic epistemic logic IEL:

    1) IPC axioms;

    2) $\Box (A \to B) \to (\Box A \to \Box B)$ (normality);

    3) $A \to \Box A$ (co-reflection);

    Rule: MP.

  \end{defin}

  V. Krupski and  A. Yatmanov provided the sequential calculus for IEL and proved that this calculus is
  PSPACE-complete \cite{Krupski}.

  Functional programming languages such as Haskell \cite{Haskell}, Idris \cite{Idris} or Purescript \cite{Purs}
  have special type classes\footnote{Type class in Haskell is a general interface for
  special group of datatypes.} for calculations with container types like \verb"Functor" and
  \verb"Applicative" \footnote{Reader may read more about container types in the Haskell standard library documentation\cite{Base} or in the next one textbook
  \cite{Miran}}:

  \begin{lstlisting}[language=Haskell]
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    class Functor f => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}

  By \emph{container} (or \emph{computational context}) type we mean some type-operator $f$, where $f$ is a
  ``function'' from $*$ to $*$: type operator takes a simple type (ща kind $*$) and returns another
  simple type of kind \verb"*". For more detailed description of the type system with kinds used in
  Haskell see \cite{Morten}.

Applicative functor allows to generalize the action of a functor for functions with arbitrary number of arguments, for instance:
  \begin{lstlisting}[language=Haskell]
  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
  liftA2 f x y = ((pure f) <*> x) <*> y
  \end{lstlisting}

  It's not difficult to see that modal axioms in $IEL^{-}$ and types of the methods of Applicative class in
  Haskell-like languages (which is described below) are syntactically similar and we are going to show that
  this coincidence has a non-trivial computational meaning.

  We investigate the relationship between intuitionistic epistemic logic IEL$^{-}$ and applicative programming with side-effects
  by constructing the type system (which is called $\lambda_{\text{IEL}^{-}}$) which is Curry-Howard isomorphic to $IEL^{-}$.
  So we will consider IEL$^{-}$ modality as an arbitrary applicative functor and we prove that obtained type system
  is sound and complete for applicative functor on cartesian closed category (using the categorical definition proposed by Paterson \cite{Cons}).

  $\lambda_{\text{IEL}^{-}}$ consists of the rules for simply typed lambda-calculus and special typing rules for
  lifting types into the applicative functor $\Box$. We assume that our type system will
  axiomatize the simplest case of computation with effects with one container. We provide a proof-theoretical
  view at this kind of computations in functional programming and prove strong normalization and confluence.

  \section{Typed lambda-calculus based on IEL$^{-}$}

  The first is to define the natural deduction calculus for NIEL$^{-}$ :

  \begin{defin} Natural deduction NIEL$^{-}$ for IEL$^{-}$ is an extenstion of intuitionistic natural deduction calculus
    with additional inference rules for modality:

  \begin{minipage}{0.5\textwidth}
    \begin{flushleft}
  	\begin{prooftree}
    	\AxiomC{$\Gamma \vdash A$}
    	\RightLabel{$\Box_I$}
    	\UnaryInfC{$\Gamma \vdash \Box A$}
  \end{prooftree}
    \end{flushleft}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \begin{flushright}
  	\begin{prooftree}
    \AxiomC{$\Gamma \vdash \Box A_1, \dots, \Gamma \vdash \Box A_n $}
    \AxiomC{$A_1,\dots,A_n \vdash B$}
    \BinaryInfC{$\Gamma \vdash \Box B$}
  	\end{prooftree}
    \end{flushright}
  \end{minipage}
  \end{defin}

The first rule allows to derive co-reflextion. The second modal rule is a counterpart of $\Box_I$
rule in natural deduction calculus for constructive K (see \cite{ModalLa}).

We will denote $\Gamma \vdash \Box A_1, \dots, \Gamma \vdash \Box A_n$ and $A_1,\dots,A_n \vdash B$ as $\Gamma \vdash \Box \vec{A}$ and $\vec{A} \vdash B$ for brevity.

  \vspace{\baselineskip}

  \begin{lemma}
    $\Gamma \vdash_{\text{NIEL}^{-}} A \Rightarrow$ IEL$^{-} \vdash \bigwedge \Gamma \rightarrow A$.
  \end{lemma}

  \begin{proof}
Induction on the derivation.

  \vspace{\baselineskip}

Let us consider cases with modality.

\vspace{\baselineskip}

1) If $\Gamma \vdash_{\text{NIEL}^{-}} A$, then $\text{IEL}^{-} \vdash \bigwedge \Gamma \rightarrow \Box A$.

$\begin{array}{lll}
(1) & \bigwedge \Gamma \rightarrow A & \text{assumption}\\
(2) & A \rightarrow \Box A &\text{co-reflection}\\
(3) & (\bigwedge \Gamma \rightarrow A) \rightarrow ((A \rightarrow \Box A) \rightarrow (\bigwedge \Gamma \rightarrow \Box A))&\text{IPC theorem}\\
(4) & (A \rightarrow \Box A) \rightarrow (\bigwedge \Gamma \rightarrow \Box A) &\text{from (1), (3) and MP}\\
(5) & \bigwedge \Gamma \rightarrow \Box A &\text{from (2), (4) and MP}\\
\end{array}$

\vspace{\baselineskip}

2) If $\Gamma \vdash_{\text{NIEL}^{-}} \Box \vec{A}$ and $\vec{A} \vdash B$, then $\text{IEL}^{-} \vdash \bigwedge \Gamma \rightarrow \Box B$.

$\begin{array}{lll}
(1) &\bigwedge \Gamma \rightarrow \Box A_1, \dots, \bigwedge \Gamma \rightarrow \Box A_1 & \text{assumption} \\
(2) &\bigwedge \Gamma \rightarrow \bigwedge \limits_{i = 1}^{n} \Box A_i & \text{IEL$^{-}$ theorem} \\
(3) &\bigwedge \limits_{i = 1}^{n} \Box A_i \rightarrow \Box \bigwedge \limits_{i = 1}^{n} A_i & \text{IEL$^{-}$ theorem} \\
(4) &\bigwedge \Gamma \rightarrow \Box \bigwedge \limits_{i = 1}^{n} A_i & \text{from (1), (2) and transitivity} \\
(5) &\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B& \text{assumption} \\
(6) &(\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B) \rightarrow \Box (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{co-reflection}\\
(7) &\Box (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{from (4), (5) and MP} \\
(8) &\Box \bigwedge \limits_{i = 1}^{n} A_i \rightarrow \Box B & \text{from (6) and normality} \\
(9) &\bigwedge \Gamma \rightarrow \Box B & \text{from (3), (7) and transitivity}
\end{array}$

  \end{proof}

\begin{lemma}
  $ $
  If $\text{IEL}^{-} \vdash A$, then $\text{NIEL}^{-} \vdash A$.
\end{lemma}

\begin{proof}
  Straightforward derivation of modal axioms in $\text{NIEL}^{-}$. We consider this derivation below using terms.
\end{proof}

  \vspace{\baselineskip}

  At the next step we build the typed lambda-calculus based on the NIEL$^{-}$ with implication and dijunction
by proof-assingment in rules. Obtained fragment is equivalent to IEL$^{-}$ without axioms for negation and disjunction.

  At first, we define lambda-terms and types for this lambda-calculus.

  \vspace{\baselineskip}

  \begin{defin} The set of terms:

  Let $\mathbb{V}$ be the set of variables. The set $\Lambda_{\Box}$ of terms is defined by the grammar:

$\begin{array}{lll}
& \Lambda_{\Box} ::= \mathbb{V} \: | \:  (\lambda \mathbb{V}.\Lambda_{\Box}) \: | \: (\Lambda_{\Box} \Lambda_{\Box}) \: | \: \langle \Lambda_{\Box} , \Lambda_{\Box} \rangle \: | \: (\pi_1 \Lambda_{\Box}) \: | \: (\pi_2 \Lambda_{\Box}) \: | & \\
& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ({\bf box \: } \:\Lambda_{\Box}) \: | \: ({\bf let \: box \:} \mathbb{V}^{*} = \Lambda_{\Box}^{*} \:\: {\bf in} \:\: \Lambda_{\Box})
\end{array}$

  \end{defin}

Where $\mathbb{V}^{*}$ and $\Lambda_{\Box}^{*}$ denote the set of finite sequences of variables $\bigcup \limits_{i=0}^{\infty} \mathbb{V}^i$
and the set of finite sequences of terms $\bigcup \limits_{i = 0}^{\infty} \Lambda_{\Box}^i $. Note that the sequence of variables $\vec{x}$ and the sequence of terms $\vec{M}$ should have the same length.
Otherwise, term is not well-formed.

  \begin{defin} The set of types:

  Let $\mathbb{T}$ be the set of atomic types. The set $\mathbb{T}_{\Box}$ of types with applicative
  functor $\Box$ is generated by the grammar:
  \begin{equation}
    \mathbb{T}_{\Box} ::= \mathbb{T} \: | \: (\mathbb{T}_{\Box} \to \mathbb{T}_{\Box} \: |
    \: (\mathbb{T}_{\Box} \times \mathbb{T}_{\Box}) \: | \: (\Box \mathbb{T}_{\Box})
  \end{equation}
  \end{defin}

  Context, domain of context and range of context are defined standardly \cite{Neder}\cite{Morten}.

  Our type system is based on the Curry-style typing rules:

  \begin{defin} Modal typed lambda calculus $\lambda_{\text{IEL}^{-}}$ based on NIEL$^{-}_{\land, \to}$:

    \begin{center}
    \begin{prooftree}
    \AxiomC{$ $}
    \RightLabel{\scriptsize{ax}}
    \UnaryInfC{$\Gamma , x : A \vdash x : A$}
    \end{prooftree}
    \end{center}

    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
      \AxiomC{$\Gamma, x : A \vdash M : B$}
      \RightLabel{$\rightarrow_i$}
      \UnaryInfC{$\Gamma \vdash \lambda x. M : A \to B$}
      \end{prooftree}

      \begin{prooftree}
      \AxiomC{ $\Gamma \vdash M : A$ }
      \AxiomC{ $\Gamma \vdash N : B$ }
      \RightLabel{$\times_i$}
      \BinaryInfC{$\Gamma \vdash \langle M, N \rangle : A \times B$}
      \end{prooftree}

      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : A$}
        \RightLabel{$\Box_I$}
        \UnaryInfC{$\Gamma \vdash {\bf box \: } \: M : \Box A $}
      \end{prooftree}
  \end{minipage}%
  \hfill
  \begin{minipage}{0.45\textwidth}
  \begin{tabular}{p{\textwidth}}
    \begin{prooftree}
    \AxiomC{$\Gamma \vdash M : A \to B$}
    \AxiomC{$\Gamma \vdash N : A$}
    \RightLabel{$\rightarrow_e$}
    \BinaryInfC{$\Gamma \vdash MN : B$}
    \end{prooftree}

    \begin{prooftree}
    \AxiomC{ $\Gamma \vdash M : A_1 \times A_2$ }
    \RightLabel{$\times_e$, $i \in \{ 1, 2 \}$}
    \UnaryInfC{$\Gamma \vdash \pi_i M : A_i$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \vec{M} : \Box \vec{A}$}
      \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
      \RightLabel{$\text{let}_{\Box}$}
      \BinaryInfC{$\Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } N : \Box B$}
    \end{prooftree}
  \end{tabular}
  \end{minipage}%

  \end{defin}

  $\Box_I$-typing rule is the same as $\bigcirc$-introduction in monadic
  metalanguage \cite{Lax}. $\Box_I$ allows to inject an object of type $A$ into the functor $\Box$. $\Box_I$ reflects the
  Haskell method {\bf box} for Applicative class. It plays the same role as the {\bf return} method in Monad class.

  $\text{let}_{\Box}$ is similar to the $\Box$-rule in typed lambda calculus for intuitionistic normal modal logic {\bf IK}, which is described in \cite{ModalK}.

$\Gamma \vdash \vec{M} : \Box \vec{A}$ is a syntax sugar for the sequence $\Gamma \vdash M_1 : \Box A_1,\dots,\Gamma \vdash M_n : \Box A_n$ and $\vec{x} : \vec{A} \vdash N : B$ is a short form for $x_1 : A_1, \dots, x_n : A_n \vdash N : B$.
${\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } N$ is a simultaneous local binding in $N$.
We use this short form instead of ${\bf let \: box \:} x_1,\dots,x_n = M_1,\dots,M_n {\: \bf in \:} N$.

In fact, our calculus is the extention of typed lambda calculus for {\bf IK} by $\Box_I$-rule that is appropriate to co-reflection.

  \vspace{\baselineskip}

Here are some examples of derivation trees:

\begin{prooftree}
\AxiomC{$x : A \vdash x : A$}
\UnaryInfC{$x : A \vdash {\bf box \:} x : \Box A$}
\UnaryInfC{$\vdash (\lambda x. {\bf box \: } x) : A \to \Box A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$f : \Box (A \to B) \vdash f : \Box (A \to B)$}
\AxiomC{$x : \Box A \vdash x : \Box A $}
\AxiomC{$g : A \to B \vdash g : A \to B$}
\AxiomC{$y : A \vdash y : A$}
\RightLabel{$\to_e$}
\BinaryInfC{$g : A \to B, y : A \vdash g y : B$}
\RightLabel{$\text{let}_{\Box}$}
\TrinaryInfC{$f : \Box (A \to B), x : \Box A \vdash {\bf let \: box \:} g, y  = f, x {\: \bf in \:} g y : \Box B$}
\UnaryInfC{$f : \Box (A \to B) \vdash \lambda x. {\bf let \: box \:} g, y = f, x {\: \bf in \:} g y : \Box A \to \Box B$}
\UnaryInfC{$\vdash \lambda f. \lambda x. {\bf let \: box \:} g, y = f, x {\: \bf in \:} g y : \Box (A \to B) \to \Box A \to \Box B$}
\end{prooftree}

  \vspace{\baselineskip}

  Now we define free variables and substitutions:

  \begin{defin} The set $FV(M)$ of free variables for a term $M$:

\begin{enumerate}
  \item $FV(x) = \{ x \}$;
  \item $FV(\lambda x. M) = FV(M) \setminus \{ x\}$;
  \item $FV(M N) = FV(M) \cup FV(N);$
  \item $FV(\langle M,N \rangle) = FV(M) \cup FV(N)$;
  \item $FV(\pi_i M) \subseteq FV(M)$, $i \in \{ 1, 2\}$;
  \item $FV(\text{\bf box } M) = FV(M)$;
  \item $FV({\bf let \: box} \: \vec{x} = \vec{M} {\: \bf in \:} N) = \bigcup \limits_{i = 1}^n FV(M), \text{where $n = |\vec{M}|$}$.
\end{enumerate}
  \end{defin}

  \begin{defin} Substitution:

\begin{enumerate}
  \item $x [x := N] = N$, $x [y := N] = x$;
  \item $(M N) [x := N] = M[x := N] N [x := N]$;
  \item $(\lambda x. M) [x := N] = \lambda x. M [y := N]$, $y \in FV(M)$;
  \item $(M, N)[x := P] = (M[x := P], N [x := P])$;
  \item $(\pi_i M) [x := P] = \pi_i (M[x := P])$, $i \in \{ 1, 2\}$;
  \item $({\bf box \: } M) [x := P] = {\bf box \: } (M [x := P])$;
  \item $({\bf let \: box \:}\vec{x} = \vec{M} {\: \bf in \:} N) [y := P] = {\bf let \: box \:} \vec{x} = (\vec{M} [y := P]) {\: \bf in \:} N$.
\end{enumerate}
  \end{defin}

Substitution and free variable for terms of kind ${\bf let \: box}$ are defined similary to \cite{ModalK}.

  \begin{defin} $\beta$-reduction and $\eta$-reduction rules for $\lambda_{\text{IEL}^{-}}$.

\begin{enumerate}
  \item $(\lambda x. M) N \rightarrow_{\beta} M [x := N]$;
  \item $\pi_1 \langle M, N \rangle \rightarrow_{\beta} M$;
  \item $\pi_2 \langle M, N \rangle \rightarrow_{\beta} N$;
  \item ${\bf let \: box \:} \vec{x}, y, \vec{z} = \vec{M}, {\bf let \: box \: } \vec{w} = \vec{N} {\: \bf in \: } Q, \vec{P} {\: in \:} R \rightarrow_{\beta} \\
  {\bf let \: box \:} \vec{x}, \vec{w}, \vec{z} = \vec{M}, \vec{N}, \vec{P} {\: \bf in \: } R [y := Q]$
  \item ${\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N \rightarrow_{\beta} {\bf box \:} N [\vec{x} := \vec{M}]$
  \item ${\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M \rightarrow_{\beta} {\bf box \:} M$, where \underline{\quad} is an empty sequence of terms.
  \item $\lambda x. f x \rightarrow_{\eta} f$;
  \item $\langle \pi_1 P, \pi_2 P \rangle \rightarrow_{\eta} P$;
  \item ${\bf let \: box \:} x = M {\: \bf in \: } x \rightarrow_{\eta} M$;
\end{enumerate}
  \end{defin}

By default we use call-by-name evaluation strategy.

Now we will prove standard lemmas for contexts in type systems\footnote{We will not prove cases with
$\to$-constructor, they are proved standardly in the same lemmas for simply typed lambda calculus, for
example see \cite{Neder} \cite{Morten}. We will consider only modal cases}:

\begin{lemma} Generation for $\Box_I$.

  Let $\Gamma \vdash {\bf box \:} M : \Box A$, then $\Gamma \vdash M : A$;
\end{lemma}

\begin{proof}
  Straightforwardly.
\end{proof}

\begin{lemma} Basic lemmas.

\begin{enumerate}
  \item If $\Gamma \vdash M : A$ and $\Gamma \subseteq \Delta$, then $\Delta \vdash M : A$;
  \item If $\Gamma \vdash M : A$, then $\Delta \vdash M : A$, where $\Delta = \{ x_i : A_i \: | \: (x_i : A_i) \in \Gamma \: \& \: x_i \in FV(M) \}$
  \item If $\Gamma, x : A \vdash M : B$ and $\Gamma \vdash N : A$, then $\Gamma \vdash M [x := N] : B$.
\end{enumerate}
\end{lemma}

\begin{proof}
  $ $

1) The derivation ends in

\begin{prooftree}
  \AxiomC{$\Gamma \vdash \vec{M} : \Box \vec{A}$}
  \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
  \RightLabel{$\text{let}_{\Box}$}
  \BinaryInfC{$\Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } N : \Box B$}
\end{prooftree}

By IH $\Delta \vdash \vec{M} : \Box \vec{A}$, so $\Delta \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } N : \Box B$.

  \vspace{\baselineskip}

2)-3) Similary.

\end{proof}

\begin{theorem} Subject reduction

  If $\Gamma \vdash M : A$ and $M \twoheadrightarrow_r N$, then $\Gamma \vdash N : A$

\end{theorem}

\begin{proof}

Induction on the derivation $\Gamma \vdash M : A$ and on the generation of $\rightarrow_r$.

For cases with axiom, application, abstraction and pairs see \cite{Morten} \cite{Pierce}.

1) If $\Gamma \vdash {\bf let \: box \:} \vec{x}, y, \vec{z} = \vec{M}, {\bf let \: box \: } \vec{w} = \vec{N} {\bf \: in \: } Q, \vec{P}  {\: \bf in \:} R : \Box B$,
  then $\Gamma \vdash {\bf let \: box \:} \vec{x}, \vec{w}, \vec{z} = \vec{M}, \vec{N}, \vec{P} \: { \bf in } \: R [y := Q] : \Box B$ by rule 4).

2) Let $\Gamma \vdash {\bf let \: box \:} x = M {\: \bf in \: } x : \Box A$, then $\Gamma \vdash M : \Box A$ by rule 9).

See \cite{ModalK}.

3) The derivation ends in

\begin{prooftree}
\AxiomC{$\Gamma \vdash {\bf box \:} \vec{M} : \Box \vec{A}$}
\AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
\BinaryInfC{$\Gamma \vdash {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N : \Box B$}
\end{prooftree}

So $\Gamma \vdash \vec{M} : \vec{A}$ by Lemma 4 and $\Gamma \vdash N [\vec{x} := \vec{M}] : B$ by Lemma 4, part 3.

Then we can transform this into the following derivation:

\begin{prooftree}
\AxiomC{$\Gamma \vdash N [\vec{x} := \vec{M}] : B$}
\RightLabel{$\Box_I$}
\UnaryInfC{$\Gamma \vdash {\bf box \:} N [\vec{x} := \vec{M}] : \Box B$}
\end{prooftree}

4) The derivation ends in

\begin{prooftree}
\AxiomC{$\vdash M : A$}
\UnaryInfC{$\vdash {\bf let \: box \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : \Box A$}
\end{prooftree}

So, if $\vdash M : A$, then $\vdash {\bf box \:} M : \Box A$.


\end{proof}

\begin{theorem}
  $ $

  $\twoheadrightarrow_r$ is strongly normalizing;
\end{theorem}

\begin{proof}
  $ $

  Let us define the transformation from $\lambda_{\text{IEL}^{-}}$ into the simple type theory with
  $\to$, $\times$ and natural number type $\mathbb{N}$ \footnote{Strong normalization for stronger system was shown here \cite{Girard}} with additional typing and reduction rules:

  \begin{prooftree}
  \AxiomC{$ $}
  \UnaryInfC{$\Gamma \vdash 0 : \mathbb{N}$}
  \end{prooftree}

  \begin{prooftree}
  \AxiomC{$\Gamma \vdash n : \mathbb{N}$}
  \UnaryInfC{$\Gamma \vdash {\bf succ \:} n : \mathbb{N}$}
  \end{prooftree}

  \begin{prooftree}
  \AxiomC{$\Gamma \vdash n : \mathbb{N}$}
  \AxiomC{$\Gamma \vdash m : \mathbb{N}$}
  \BinaryInfC{$\Gamma \vdash n + m : \mathbb{N}$}
  \end{prooftree}

  \begin{enumerate}
    \item $n + 0 \rightarrow_{\beta} n$;
    \item $(n + {\bf succ \:} m) \rightarrow_{\beta} {\bf succ \:} (n + m)$
  \end{enumerate}

  The transformation $|.|$ is defined as follows:

  \begin{defin} Interpretaion of types:

    \begin{enumerate}
      \item $A \in \mathbb{T} \Rightarrow |A| = A$;
      \item $|A \to B| = |A| \to |B|$;
      \item $|A \times B| = |A| \times |B|$;
      \item $|\Box A| = \mathbb{N} \times |A|$.
    \end{enumerate}
  \end{defin}

  \begin{defin} Interpretation of terms:
    \begin{enumerate}
      \item $x \in \mathbb{V} \Rightarrow |x| = x$;
      \item $|\lambda x. M| = \lambda x. |M|$;
      \item $|(M N)| = |M| |N|$;
      \item $|\langle M, N \rangle| = \langle |M|, |N| \rangle$;
      \item $|\pi_i M| = \pi_i |M|$, $i \in \{ 1, 2\}$;
      \item $|{\bf box \:} M| = \langle 0, |M| \rangle$;
      \item $|{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M| = \langle 0, |M| \rangle$;
      \item $|{\bf let \: box \:} x = N {\: \bf in \:} M| = \langle \pi_1 |N| , |M| [x := \pi_2 |N|] \rangle$
      \item $|{\bf let \: box \:} \vec{x} = \vec{N} {\: \bf in \:} M| = \langle \sum \limits_{i = 1}^n \pi_1 |N|, |M| [\vec{x} := \pi_2 \vec{N}] \rangle$
    \end{enumerate}
  \end{defin}

  Let us consider the interpretation for $\text{let}_{\Box}$ rule:

  \begin{prooftree}
    \AxiomC{$|\Gamma \vdash \vec{N} : \Box \vec{A}| = |\Gamma| \vdash \vec{|N|} : \mathbb{N} \times \vec{|A|}$}
    \AxiomC{$|\vec{x} : \vec{A} \vdash M : B| = \vec{x} : \vec{|A|} \vdash |M| : |B|$}
    \RightLabel{$\text{let}_{\Box}$}
    \BinaryInfC{$|\Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{N} {\: \bf in \: } M : \Box B| = |\Gamma| \vdash \langle \sum \limits_{i = 1}^n \pi_1 |N|, |M| [\vec{x} := \pi_2 \vec{N}] \rangle : \mathbb{N} \times |B|$}
  \end{prooftree}

  \begin{lemma}:

    $|M [x := N]| = |M| [x := |N|]$ for any term $M$.
  \end{lemma}

  \begin{proof}

    Induction on the structure of $M$.
  \end{proof}

  \begin{lemma}

    $M \twoheadrightarrow_{r} N \Rightarrow |M| \twoheadrightarrow_{\beta\eta} |N|$
  \end{lemma}

  \begin{proof}

    Let us consider cases with $\beta \Box$, $\beta \Box {\bf box}$ and $\Box id$.

\begin{enumerate}
\item $|{\bf let \: box \:} x = ({\bf let \: box \:} y = N {\: \bf in \:} P) {\: \bf in \:} M| = \\
\quad\quad\quad\quad |{\bf let \: box \:} y = N {\: \bf in \:} M [x := P]|$

  $\begin{array}{lll}
  &|{\bf let \: box \:} x = ({\bf let \: box \:} y = N {\: \bf in \:} P) {\: \bf in \:} M| = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &\langle \pi_1 |N|, |M| [x := |P| [y := \pi_2 |N|]] \rangle& \\
  &|{\bf let \: box \:} y = N {\: \bf in \:} M [x := P]| = & \\
  &\langle \pi_1 |N|, |M| [x := |P|] [y := \pi_2 |N|]\rangle \equiv & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{So far as $y \notin FV(M)$} & \\
  &\langle \pi_1 |N|, |M| [x := |P| [y := \pi_2 |N|]]&
  \end{array}$

\item $|{\bf let \: box \:} \vec{x} = {\bf box \:} \vec{N} {\: \bf in \:} M| = |{\bf box \:} M [\vec{x} := \vec{N}]|$\\

  $\begin{array}{lll}
  &|{\bf let \: box \:} \vec{x} = {\bf box \:} \vec{N} {\: \bf in \:} M| = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &\langle 0 + \dots + 0, |M| [\vec{x} := \vec{|N|}]\rangle \twoheadrightarrow_{\beta}& \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Multistep reduction for natural numbers}& \\
  &\langle 0, |M| [\vec{x} := \vec{|N|}] \rangle = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &|{\bf box \:} M [\vec{x} := \vec{N}]|&
  \end{array}$

\item $|{\bf let \: box \:} x = M {\: \bf in \:} x| = |M|$\\

  $\begin{array}{lll}
  &|{\bf let \: box \:} x = M {\: \bf in \:} x| = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Interpretation}& \\
  &\langle \pi_1 |M|, x [x := \pi_2 |M|] \rangle = & \\
  &\quad\quad\quad\quad\quad\quad\quad \text{Substitution}& \\
  &\langle \pi_1 |M|, \pi_2 |M| \rangle \rightarrow_{\eta}& \\
  &\quad\quad\quad\quad\quad\quad\quad \text{$\eta$-reduction for pairs}& \\
  &|M|&
  \end{array}$

\item $\begin{array}{lll}
  &|{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M| = \langle 0 , |M| \rangle = |{\bf box \:} M|&
  \end{array}$
\end{enumerate}

  Hence $\lambda_{\text{IEL}^{-}}$ sounds for $\lambda_{\to, \times, \mathbb{N}}$,
  then multistep reduction in $\lambda_{\text{IEL}^{-}}$ is strongly normalizing, so far as multistep reduction in $\lambda_{\to, \times, \mathbb{N}}$ is strongly normalizing.

  \end{proof}
\end{proof}


\begin{theorem}
  $ $

  $\twoheadrightarrow_r$ is confluent.
\end{theorem}

\begin{proof}

  By Newman's lemma \cite{Morten}, if relation is strongly normalizing and locally conluent, then this relation is confluent.

It is sufficient to show that $\twoheadrightarrow_r$ is locally confluent.

\begin{lemma} Local confluence

If $M \rightarrow_{r} N$ and $M \rightarrow_{r} Q$, then there exists some term $P$,
such that $N \twoheadrightarrow_{r} P$ and $Q \twoheadrightarrow_{r} P$.

\end{lemma}

\begin{proof}

Let us consider the following critical pairs and show that they are joinable:

\begin{enumerate}
\item $ $ \\

\xymatrix{
{\bf let \: box \:} x = ({\bf let \: box \:} \vec{y} = {\bf box \:} \vec{N} {\: \bf in \:} P) {\: \bf in \:} M \ar[d]_{\beta \Box} \ar[dr]^{\beta \Box {\bf box}} \\
{\bf let \: box \:} \vec{y} = {\bf box \:} \vec{N} {\: \bf in \:} M [x := P] & {\bf let \: box \:} x = {\bf box \:} P [\vec{y} := \vec{N}] {\: \bf in \:} M
}

\vspace{\baselineskip}

$\begin{array}{lll}
&{\bf let \: box \:} \vec{y} = {\bf box \:} \vec{N} {\: \bf in \:} M [x := P] \rightarrow_{\beta \Box {\bf box}}& \\
&\quad\quad\quad\quad\quad\quad\quad {\bf box \:} M [x := P] [\vec{y} := \vec{N}]& \\
&{\bf let \: box \:} x = {\bf box \:} P [\vec{y} := \vec{N}] {\: \bf in \:} M \rightarrow_{\beta \Box {\bf box}}& \\
&\quad\quad\quad\quad\quad\quad\quad {\bf box \:} M [x := P[\vec{y} := \vec{N}]] \equiv & \\
&\text{So far as $x \notin \vec{y}$}& \\
&\quad\quad\quad\quad\quad\quad\quad {\bf box \:} M [x := P] [\vec{y} := \vec{N}] & \\
\end{array}$

\item $ $ \\

\xymatrix{
{\bf let \: box \:} x = ({\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N) {\: \bf in \:} M \ar[d]^{\beta \Box} \ar[dr]^{\beta \Box \underline{\quad}} \\
{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M [x := N] & {\bf let \: box \:} x = {\bf box \:} N {\: \bf in \:} M
}

$\begin{array}{lll}
&{\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} M [x := N] \rightarrow_{\beta \Box \underline{\quad}} {\bf box \:} (M [x := N])& \\
&{\bf let \: box \:} x = {\bf box \:} N {\: \bf in \:} M \rightarrow_{\beta \Box {\bf box}} {\bf box \:} (M [x := N])&
\end{array}$
\end{enumerate}
\end{proof}

Also we may consider four critical pairs which are used in local confluence proof for lambda-calculus based on {\bf IK} and \cite{ModalK}.

\end{proof}

\begin{theorem}
  $ $

  Normal form in call-by-name $\lambda_{\text{IEL}^{-}}$ has the subformula property: if $M$ is in normal formal, then its all subterms are in normal form too.

\end{theorem}

\begin{proof}
  By induction on the structure of $M$.
  Case with ${\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \:} N$ was considered by Kakutani \cite{ModalK} \cite{ModalK1}.

  If ${\bf box \:} M$ is in normal form, so $M$ is in normal form and its subterms are in normal form too by hypothesis.

  Thus if ${\bf box \:} M$ is in normal form, then all its subterms are in normal form too.
\end{proof}

\section{Categorical semantics}

\begin{defin} Monoidal category

  Monoidal category is a category $\mathcal{C}$ with additional monoidal structure:
  \begin{enumerate}
    \item A bifunctor $\otimes : \mathcal{C} \times \mathcal{C} \to C$ called tensor product;
    \item Identity object $\mathds{1}$;
    \item A natural isomorphism called associator: $\alpha_{A,B,C}: (A \otimes B) \otimes C \cong A \otimes (B \otimes C)$;
    \item A natural isomorphism called left unitor: $L_A : \mathds{1} \otimes A \cong A$;
    \item A natural isomorphism called right unitor $R_A : A \otimes \mathds{1} \cong A$;
    \item A coherence condition called MacLane pentagon, i.e. the following diagram commutes:

    \xymatrix{
      & (A \otimes (B \otimes C)) \otimes D \ar[dr]^{\alpha_{A,B \otimes C,D}}\\
      ((A \otimes B) \otimes C) \otimes D \ar[d]_{\alpha_{A \otimes B, C, D}} \ar[ur]^{\alpha_{A,B,C} \otimes id_D \quad} && A \otimes ((B \otimes C) \otimes D) \ar[d]^{id_A \otimes \alpha_{B,C,D}}\\
      (A \otimes B) \otimes (C \otimes D) \ar[rr]_{\alpha_{A,B,C \otimes D}}&& A \otimes (B \otimes (C \otimes D))
    }
    \item A coherence condition called triangle identity:

    \xymatrix{
    && (A \otimes \mathds{1}) \otimes B \ar[rr]^{\alpha_{A, \mathds{1}, B}} \ar[dr]_{R_A \otimes id_B} && A \otimes (\mathds{1} \otimes B) \ar[dl]^{id_A \otimes L_B} \\
    &&& A \otimes B
    }
  \end{enumerate}
\end{defin}

\begin{defin} Cartesian closed category

  Cartesian closed category is a category with a terminal object, finite products and exponentiation.
\end{defin}

Note that, any cartesian closed category is the special case of a monoidal category, where tensor is a product and identity object is a terminal object.

\begin{defin} Monoidal functor

  Let $\langle \mathcal{C}, \otimes_1, \mathds{1}_{\mathcal{C}} \rangle$ and $\langle \mathcal{D}, \otimes_2, \mathds{1}_{\mathcal{D}} \rangle$ are monoidal categories.

  A monoidal functor $\mathcal{F} : \langle \mathcal{C}, \otimes_1, \mathds{1} \rangle \to \langle \mathcal{D}, \otimes_2, \mathds{1}' \rangle$ is a functor
  $\mathcal{F} : \mathcal{C} \to \mathcal{D}$ with additional natural transformations:

  \begin{enumerate}
  \item $u : \mathds{1}_{\mathcal{D}} \to \mathcal{F}\mathds{1}_{\mathcal{C}}$;
  \item $A \varoast B : \mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}B \to \mathcal{F}(A \otimes_{\mathcal{C}} B)$.
\end{enumerate}

  and coherence maps:

  \begin{itemize}
    \item Associativity:

  \xymatrix{
    && (\mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}B) \otimes_{\mathcal{D}} \mathcal{F}C \ar[d]_{(A \varoast B) \otimes_{\mathcal{D}} id_{\mathcal{F}B}}
    \ar[rr]^{\alpha^{\mathcal{D}}_{{\mathcal{F}A, \mathcal{F}B, \mathcal{F}C}}} && \mathcal{F}A \otimes_{\mathcal{D}} (\mathcal{F}B \otimes_{\mathcal{D}} \mathcal{F}C) \ar[d]^{id_{\mathcal{F}A} \otimes_{\mathcal{D}} \ast_{B,C}}\\
    && \mathcal{F}(A \otimes_{\mathcal{C}} B) \otimes_{\mathcal{D}} \mathcal{C} \ar[d]_{(A \otimes_{\mathcal{C}} B) \varoast C} && \mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}(B \otimes_{\mathcal{C}} C) \ar[d]^{A \varoast (B \otimes_{\mathcal{C}} C) }\\
    && \mathcal{F}((A \otimes_{\mathcal{C}} B) \otimes_{\mathcal{C}} C) \ar[rr]_{\mathcal{F}(\alpha^{\mathcal{C}}_{A,B,C})}&& \mathcal{F}(A \otimes_{\mathcal{C}} (B \otimes_{\mathcal{C}} C))
  }

    \item Left unitality:

    \xymatrix{
    &&  \mathds{1}_{\mathcal{D}} \otimes_{\mathcal{D}} \mathcal{F}A \ar[d]_{L^{\mathcal{D}}_{\mathcal{F}A}}\ar[rr]^{u \otimes_{\mathcal{D}} id_{\mathcal{F}A}} && \mathcal{F}\mathds{1}_{\mathcal{C}} \otimes_{\mathcal{D}} \mathcal{F}A \ar[d]^{\mathds{1}_{\mathcal{C}} \varoast A} \\
    &&  \mathcal{F}A && \mathcal{F}(\mathds{1}_{\mathcal{C}} \otimes_{\mathcal{C}} A) \ar[ll]_{\mathcal{F}(L^{\mathcal{C}}_A)}
    }

    \item Right unitality:

    \xymatrix{
    &&  \mathcal{F}A \otimes_{\mathcal{D}} \mathds{1}_{\mathcal{D}} \ar[d]_{R^{\mathcal{D}}_{\mathcal{F}A}}\ar[rr]^{id_{\mathcal{F}A} \otimes_{\mathcal{D}} u} && \mathcal{F}A \otimes_{\mathcal{D}} \mathcal{F}\mathds{1}_{\mathcal{C}} \ar[d]^{A \varoast \mathds{1}_{\mathcal{C}}} \\
    &&  \mathcal{F}A && \mathcal{F}(A \otimes_{\mathcal{C}} \mathds{1}_{\mathcal{C}} ) \ar[ll]^{\mathcal{F}(R^{\mathcal{C}}_A)}
    }
  \end{itemize}
\end{defin}

\begin{defin} Applicative functor

  An applicative functor is a triple $\langle \mathcal{C}, \mathcal{F}, \eta \rangle$,
where $\mathcal{C}$ is a monoidal category, $\mathcal{F}$ is a monoidal endofunctor and $\eta : Id_{\mathcal{C}} \Rightarrow \mathcal{F}$ is a natural transformation (similar to unit in monad), such that:

\begin{enumerate}
\item $u = \eta_{\mathds{1}}$;
\item $A \varoast B \circ (\eta_A \otimes \eta_B) = \eta_{A \otimes B}$, i.e. the following diagram commutes:

\xymatrix
{
&&& A \otimes B \ar[rr]^{\eta_A \otimes \eta_B} \ar[drr]_{\eta_{A \otimes B}} && \mathcal{F}A \otimes \mathcal{F}B \ar[d]^{A \varoast B} \\
&&&&& \mathcal{F}(A \otimes B)
}
\end{enumerate}
\end{defin}


By default we will consider some monoidal functor on cartesian closed category below.

\subsection{Soundness and completeness}

\begin{defin} Semantical translation from $\lambda_{\text{IEL}^{-}}$ to some cartesian closed category $\mathcal{C}$ with an applicative functor $\boxdot$:

\begin{enumerate}
\item Interpretation for types:
  \begin{itemize}
    \item $[\![A]\!] := \hat{A}, A \in \mathbb{T}$, where $\hat{A}$ is an object of $\mathcal{C}$ obtained by some given assignment;
    \item $[\![A \to B]\!] := [\![B]\!]^{[\![A]\!]}$;
    \item $[\![A \times B]\!] := [\![A]\!] \times [\![B]\!]$.
  \end{itemize}
\item Interpretation for modal types:
  \begin{enumerate}
    \item $[\![\Box A]\!] = \boxdot [\![A]\!]$;
  \end{enumerate}
\item Interpretaion for contexts:
  \begin{enumerate}
    \item $[\![ \quad ]\!] = \mathds{1}$, where $\mathds{1}$ is a terminal object of a given ccc;
    \item $[\![\Gamma, x : A]\!] = [\![\Gamma]\!] \times [\![A]\!]$
  \end{enumerate}
\item Interpretation for typing assignment:
  \begin{enumerate}
    \item $[\![\Gamma \vdash M : A]\!] := [\![M]\!] : [\![\Gamma]\!] \to [\![A]\!]$.
  \end{enumerate}
\item Interpretation for typing rules:

\begin{prooftree}
\AxiomC{$ $}
\UnaryInfC{$[\![\Gamma, x : A \vdash x : A]\!] = \pi_2 : [\![\Gamma]\!] \times [\![A]\!] \rightarrow
[\![A]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma, x : A \vdash M : B]\!] = [\![M]\!] : [\![\Gamma]\!] \times [\![A]\!] \rightarrow [\![B]\!]$}
\UnaryInfC{$[\![\Gamma \vdash (\lambda x. M) : A \to B]\!] = \Lambda([\![M]\!]) : [\![\Gamma]\!]
\rightarrow[\![B]\!]^{[\![A]\!]}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A \to B]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![B]\!]^{[\![A]\!]}$}
\AxiomC{$[\![\Gamma \vdash N : A]\!] = [\![N]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M N) : B]\!] = [\![\Gamma]\!] \xrightarrow{\langle [\![M]\!], [\![N]\!]
\rangle} [\![B]\!]^{[\![A]\!]} \times [\![A]\!] \xrightarrow{\epsilon} [\![B]\!] $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A ]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\AxiomC{$[\![\Gamma \vdash N : B ]\!] = [\![N]\!] : [\![\Gamma]\!] \rightarrow [\![B]\!]$}
\BinaryInfC{$[\![\Gamma \vdash \langle M, N \rangle : A \times B]\!] = \langle [\![M]\!], [\![N]\!] \rangle : [\![\Gamma]\!] \rightarrow
[\![A]\!] \times [\![B]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A_1 \times A_2]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A_1]\!] \times
[\![A_2]\!]$}
\RightLabel{$i \in \{1,2\}$}
\UnaryInfC{$[\![\Gamma \vdash \pi_i M : A_i]\!] = [\![\Gamma]\!] \xrightarrow{[\![M]\!]} [\![A_1]\!] \times
[\![A_2]\!] \xrightarrow{\pi_i} [\![A_i]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\UnaryInfC{$[\![\Gamma \vdash {\bf box \:} M : \Box A]\!] := [\![\Gamma]\!] \xrightarrow{[\![M]\!]}
[\![A]\!] \xrightarrow{\eta_{[\![A]\!]}} \boxdot [\![A]\!]$}
\end{prooftree}

\begin{small}
  \begin{prooftree}
    \AxiomC{$[\![\Gamma \vdash \vec{M} : \Box \vec{A}]\!] = \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \prod \limits_{i=1}^n \boxdot [\![A_i]\!]$}
    \AxiomC{$[\![\vec{x} : \vec{A} \vdash N : B]\!] = [\![N]\!] : \prod \limits_{i=1}^n [\![A_i]\!] \rightarrow [\![B]\!]$}
    \BinaryInfC{$[\![\Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \: } M : \Box B]\!] = \boxdot ([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \boxdot [\![B]\!]$}
  \end{prooftree}
\end{small}
\end{enumerate}
\end{defin}

\begin{theorem} Soundness

  Let $\Gamma \vdash M : A$ and $M =_r N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$
\end{theorem}

\begin{proof}


\begin{lemma}
$ $

$[\![M [x_1 := M_1,\dots, x_n := M_n]]\!] = [\![M]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle$.

\end{lemma}

\begin{proof}

$ $

1)

$\begin{array}{lll}
& [\![\Gamma \vdash ({\bf box \:} M) [ \vec{x} := \vec{M}] : \Box A]\!] = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By substitution definition}& \\
&[\![ \Gamma \vdash {\bf box \:} (M [ \vec{x} := \vec{M}]) : \Box A]\!]& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Interpretation for {\bf box}}\\
&\eta_{[\![A]\!]} \circ [\![(M [ \vec{x} := \vec{M}])]\!]& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Assumption} \\
&\eta_{[\![A]\!]} \circ ([\![M]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle) = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}&\\
&(\eta_{[\![A]\!]} \circ [\![M]\!]) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle = & \\
&\quad\quad\quad\quad\quad\quad\quad  \text{Interpretation for {\bf box}}& \\
&[\![ \Gamma \vdash {\bf box \:} M : \Box A]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle = & \\
\end{array}$

\vspace{\baselineskip}

2)

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash ({\bf let \: box} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : \Box B]\!] =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Substitution} &\\
&[\![\Gamma \vdash {\bf let \: box} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N : \Box B]\!] =& \\
&\quad\quad\quad\quad\quad\quad\quad  \text{Interpretation for $let_{\Box}$} \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \ast \dots \ast [\![A_n]\!]) \circ [\![\Gamma \vdash (\vec{M} [\vec{y} := \vec{P}]) : \Box \vec{A}]\!] =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Induction hypothesis}& \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \ast \dots \ast [\![A_n]\!]) \circ ([\![\vec{M}]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle) = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}& \\
&(\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \ast \dots \ast [\![A_n]\!]) \circ [\![\vec{M}]\!]) \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{Interpretaion}& \\
&[\![\Gamma \vdash {\bf let \: box} \: \vec{x} = \vec{M} {\: \bf in \:} N : \Box B]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle&
\end{array}$

\end{proof}

\begin{lemma}
  $ $

  Let $\Gamma \vdash M : A$ and $M \to_r N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$;
\end{lemma}

\begin{proof}
  $ $

Cases with $\beta$-reductions for $let_{\Box}$ are shown in \cite{ModalK1}. Let us consider cases with ${\bf box}$.

\vspace{\baselineskip}

1) $[\![\Gamma \vdash {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N : \Box B]\!] = [\![\Gamma \vdash {\bf box \:} N [\vec{x} := \vec{M}] : \Box B]\!]$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{M} {\: \bf in \:} N : \Box B]\!] = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpretation}& \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ \langle \eta_{[\![A_1]\!]} \circ [\![M_1]\!],\dots,\eta_{[\![A_n]\!]} \circ [\![M_n]\!] \rangle = \\
&\quad\quad\quad\quad\quad\quad\quad \text{By the property of a pair of morphisms}& \\
&\boxdot ([\![N]\!]) \circ ([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ (\eta_{[\![A_1]\!]} \times \dots \times \eta_{[\![A_n]\!]}) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]\rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}& \\
&\boxdot ([\![N]\!]) \circ (([\![A_1]\!] \varoast \dots \varoast [\![A_n]\!]) \circ (\eta_{[\![A_1]\!]} \times \dots \times \eta_{[\![A_n]\!]})) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{By the definition of an applicative functor}& \\
&\boxdot ([\![N]\!]) \circ \eta_{[\![A_1]\!] \times \dots \times [\![A_n]\!]} \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Naturality of $\eta$}& \\
&\eta_{[\![B]\!]} \circ [\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Associativity of composition}& \\
&\eta_{[\![B]\!]} \circ ([\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]) \rangle =& \\
&\quad\quad\quad\quad\quad\quad\quad \text{Substitution lemma}& \\
&\eta_{[\![B]\!]} \circ [\![\Gamma \vdash N [\vec{x} := \vec{M}] : \Box B]\!]& \\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpetation}& \\
&[\![\Gamma \vdash {\bf box \:} (N [\vec{x} := \vec{M}]) : \Box B]\!]&
\end{array}$

\vspace{\baselineskip}

2) $[\![\vdash {\bf let \: box \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : \Box A]\!] = [\![\vdash {\bf box \:} M : \Box A]\!]$

$\begin{array}{lll}
&[\![\vdash {\bf let \: box \:} \underline{\quad} = \underline {\quad} {\: \bf in \:} M : \Box A]\!] = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpretation}& \\
&\boxdot ([\![M]\!]) \circ u_{\mathds{1}} = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By the definition of an applicative functor}& \\
&\boxdot {K}([\![M]\!]) \circ \eta_{\mathds{1}} = & \\
&\quad\quad\quad\quad\quad\quad\quad \text{By naturality of $\eta$} & \\
&\eta_{[\![A]\!]} \circ [\![M]\!] = &\\
&\quad\quad\quad\quad\quad\quad\quad \text{By interpretation} & \\
&[\![\vdash {\bf box \:} M : \Box A]\!]&
\end{array}$
\end{proof}

\end{proof}

\begin{theorem} Completeness

Let $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$, then $M =_r N$.
\end{theorem}

\begin{proof}

$ $

We will consider term model for simply typed lambda calculus $\times$ and $\to$ standardly described in \cite{LambekScott}:

\begin{defin} Equivalence on term pairs:
  $ $

  Let us define relation $\sim_{A, B} \subseteq (\mathbb{V} \times \Lambda_{\Box})^2$, such that:

  $(x, M) \sim_{A, B} (y, N) \Leftrightarrow x : A \vdash M : B \:\: \& \:\: y : A \vdash N : A \:\: \& \:\: M =_r N [y := x]$;
\end{defin}

We will denote equivalence class as $[x, M]_{A, B} = \{ (y, N) \: | \: (x, M) \sim_{A, B} (y, N) \}$ (we will drop indices below).


\begin{defin} Category $\mathcal{C}(\lambda)$:
\begin{enumerate}
  \item $Ob_{\mathcal{C}} = \{ \hat{A} \: | \: A \in \mathbb{T} \} \cup \{ \mathds{1} \}$;
  \item $Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B}) = \{ [x, M] \: | \: x : A \vdash_{\lambda_{\text{IEL}^{-}}} M : B \}$;
  \item Let $[x, M] \in Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B})$ and $[y,N] \in Hom_{\mathcal{C}(\lambda)}(\hat{B},\hat{C})$, then $[y,M] \circ [x, M] = [x, N [y := M]]$;
  \item Identity morphism $id_{\hat{A}} = [x,x] \in Hom_{\mathcal{C}(\lambda)(\hat{A}, \hat{A})}$;
  \item $\mathds{1}$ is a terminal object;
  \item $\widehat{A \times B} = \hat{A} \times \hat{B}$;
  \item Canonical projection is defined as $[x, \pi_i x] \in Hom_{\mathcal{C}(\lambda)}(\hat{A_1} \times \hat{A_2},\hat{A_i})$ for $i \in \{ 1, 2 \}$;
  \item $\widehat{A \to B} = \hat{B}^{\hat{A}}$;
  \item Evaluation arrow $\epsilon = [x, (\pi_2 x) (\pi_1 x)] \in Hom_{\mathcal{C}(\lambda)(\hat{B}^{\hat{A}} \times \hat{A}, \hat{B})}$.
\end{enumerate}
\end{defin}

We define endofunctor $\boxdot$ on $\mathcal{C}(\lambda)$ and natural transformation $\eta$ from $id_{\mathcal{C}(\lambda)}$ to this endofunctor.
It is sufficient to show $\boxdot$ and $\eta$ form an applicative functor on $\mathcal{C}(\lambda)$ for theorem proof.

\begin{defin}
  Let us define an endofunctor $\boxdot : \mathcal{C}(\lambda) \to \mathcal{C}(\lambda)$, such that
forall $[x,M] \in Hom_{\mathcal{C}(\lambda)}(\hat{A},\hat{B}), \boxdot ([x,M]) = [y, {\bf let \: box \:} x = y {\: \bf in \:} M] \in Hom_{\mathcal{C}(\lambda)}(\boxdot \hat{A}, \boxdot \hat{B})$
(denotation: $\text{fmap } f$ for an arbitrary arrow $f$).

\end{defin}

\begin{lemma} Functoriality

\begin{enumerate}
  \item $\text{fmap }(g \circ f) = \text{fmap }(g) \circ \text{fmap }(f)$;
  \item $\text{fmap }(id_{\hat{A}}) = id_{\boxdot}\hat{A}$.
\end{enumerate}
\end{lemma}

\begin{proof}

Easy checking using reduction rules.

\end{proof}

\begin{defin}

  Let us define natural transformations:

\begin{enumerate}
  \item $\eta: Id_{\mathcal{C}(\lambda)} \Rightarrow \boxdot$, s. t. $\forall \hat{A} \in Ob_{\mathcal{C}(\lambda)}$, $\eta_{\hat{A}} = [x, {\bf box \:} x] \in Hom_{\mathcal{C}(\lambda)}(\hat{A}, \boxdot \hat{A})$;
  \item $\hat{A} \varoast \hat{B} : \boxdot \hat{A} \times \boxdot \hat{B} \to \boxdot (\hat{A} \times \hat{B})$, s. t. $\forall \hat{A}, \hat{B} \in Ob_{\mathcal{C}(\lambda)}, \ast_{\hat{A},\hat{B}} = [p, {\bf let \: box \:} x,y = \pi_1 p, \pi_2 p {\: \bf in \:} \langle x, y \rangle] \in Hom_{\mathcal{C}(\lambda)}(\boxdot \hat{A} \times \boxdot \hat{B}, \boxdot (\hat{A} \times \hat{B}))$.
\end{enumerate}
\end{defin}

Implementation for $\ast$ in our term model is the instance of ${\text{let}_{\Box}}$-rule:

\begin{prooftree}
\AxiomC{$p : \Box A \times \Box B \vdash p : \Box A \times \Box B$}
\UnaryInfC{$p : \Box A \times \Box B \vdash \pi_1 p : \Box A$}
\AxiomC{$p : \Box A \times \Box B \vdash p : \Box A \times \Box B$}
\UnaryInfC{$p : \Box A \times \Box B \vdash \pi_2 p : \Box B$}
\AxiomC{$x : A \vdash x : A$}
\AxiomC{$y : B \vdash y : B$}
\BinaryInfC{$x : A, y : B \vdash \langle x, y \rangle : A \times B$}
\TrinaryInfC{$p : \Box A \times \Box B \vdash {\bf let \: box \:} x,y = \pi_1 p, \pi_2 p {\: \bf in \:} \langle x, y \rangle : \Box (A \times B)$}
\end{prooftree}

\begin{lemma}
  $ $

  $\boxdot$ is a monoidal endofunctor
\end{lemma}

\begin{proof}
$ $

See \cite{ModalK}
\end{proof}

\begin{lemma} Naturality and coherence for $\eta$:

\begin{enumerate}
  \item $\text{fmap } f \circ \eta_A = \eta_B \circ f$;
  \item $(\hat{A} \varoast \hat{B}) \circ (\eta_{A} \times \eta_{B}) = \eta_{\hat{A} \times \hat{B}}$;
\end{enumerate}
\end{lemma}

\begin{proof}
  $ $

\begin{enumerate}
\item $\text{fmap } f \circ \eta_{\hat{A}} = \eta_{\hat{B}} \circ f$ \\

$\begin{array}{lll}
&\eta_{\hat{B}} \circ f = & \\
&[y, {\bf box \:} y] \circ [x, M] = &\\
&\quad\quad\quad\quad\quad\quad \text{Composition} & \\
&[x, {\bf box \:} y [y := M]] = &\\
&\quad\quad\quad\quad\quad\quad \text{By substitution}& \\
&[x, {\bf box \:} M]& \\
& &\\
&\text{On the other hand:}& \\
&\text{fmap } f \circ \eta_{\hat{A}} = & \\
&[z, {\bf let \: box \:} x = z {\: \bf in \:} M] \circ [x, {\bf box \:} x] = &\\
&\quad\quad\quad\quad\quad\quad \text{By the definition of composition}& \\
&[x, {\bf let \: box \:} x = z {\: \bf in \:} M [z := {\bf box \:} x]] = & \\
&\quad\quad\quad\quad\quad\quad \text{By substitution}& \\
&[x, {\bf let \: box \:} x = {\bf box \:} x {\: \bf in \:} M] = & \\
&\quad\quad\quad\quad\quad\quad \text{$\beta$-reduction rule}& \\
&[x, {\bf box \:} M [x := x]] = &\\
&\quad\quad\quad\quad\quad\quad \text{By substitution} & \\
&[x, {\bf box \:} M]&
\end{array}$

\item $(\hat{A} \varoast \hat{B}) \circ (\eta_{A} \times \eta_{B}) = \eta_{\hat{A} \times \hat{B}}$ \\

$\begin{array}{lll}
& (\hat{A} \varoast \hat{B}) \circ (\eta_{A} \times \eta_{B}) = & \\
& [q, {\bf let \: box \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle] \circ [p, \langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{Composition}& \\
& [p, {\bf let \: box \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle [q := \langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle]] = & \\
& \quad\quad\quad\quad\quad\quad \text{By substitution}& \\
& [p, {\bf let \: box \:} x, y = \pi_1 (\langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle), \pi_2 (\langle {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) \rangle) {\: \bf in \:} \langle x, y \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{Reduction rules}& \\
& [p, {\bf let \: box \:} x, y = {\bf box \:} (\pi_1 p), {\bf box \:} (\pi_2 p) {\: \bf in \:} \langle x, y \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{Reduction rule}& \\
& [p, {\bf box \:} (\langle x,y \rangle [x := \pi_1 p, y := \pi_2 p])] = & \\
& \quad\quad\quad\quad\quad\quad \text{Substitution}& \\
& [p, {\bf box \:} \langle \pi_1 p, \pi_2 p \rangle] = & \\
& \quad\quad\quad\quad\quad\quad \text{$\eta$-reduction}& \\
& [p, {\bf box \:} p] =& \\
& \quad\quad\quad\quad\quad\quad \text{By definition}& \\
& \eta_{\hat{A} \times \hat{B}}&
\end{array}$
\end{enumerate}
\end{proof}

\begin{defin}
  $ $

  $u_{\mathds{1}} = [\sqbullet, {\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} \sqbullet] \in Hom_{\mathcal{C}(\lambda)}(\mathds{1}, \boxdot \mathds{1})$.
\end{defin}

\begin{lemma}
  $ $

  $u_{\mathds{1}} = \eta_{\mathds{1}}$

\end{lemma}

\begin{proof}

  Immediately.
\end{proof}

\begin{lemma}

  $\langle \mathcal{C}(\lambda), \boxdot, \eta \rangle$ is an applicative functor
\end{lemma}

\begin{proof}
  Immediately follows from previous lemmas in the section.
\end{proof}

\end{proof}

\section{Relation with Moggi's monadic metalanguage}

\begin{defin} Monadic metalanguage

  Monadic metalanguage is a simply typed lambda calculus with additional typing rules:

\begin{minipage}{0.45\textwidth}
\begin{prooftree}
  \AxiomC{$\Gamma \vdash M : A$}
  \RightLabel{$\bigcirc_I$}
  \UnaryInfC{$\Gamma \vdash {\bf val \:} M : \bigcirc A$}
\end{prooftree}
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}
\begin{tabular}{p{\textwidth}}
\begin{prooftree}
  \AxiomC{$\Gamma \vdash M : \bigcirc A$}
  \AxiomC{$\Gamma, x : A \vdash N : \bigcirc B$}
  \RightLabel{$\bigcirc_E$}
  \BinaryInfC{$\Gamma \vdash {\bf let \: val \:} x = M {\: \bf in \:} N : \bigcirc B$}
\end{prooftree}
\end{tabular}
\end{minipage}

\end{defin}

\begin{defin} Reduction rules for monadic metalanguage
  \begin{enumerate}
    \item ${\bf let \: val \:} x = {\bf val \:} M {\: \bf in \:} N \rightarrow_{\beta} N [x := M]$;
    \item ${\bf let \: val \:} x = ({\bf let \: val \:} y = N {\: \bf in \:} P) {\: \bf in \:} M \rightarrow_{\beta} {\bf let \: val \:} y = N {\: \bf in \:} ({\bf let \: val \:} x = P {\: \bf in \:} M)$;
    \item ${\bf let \: val \:} x = M {\: \bf in \:} {\bf val} x \rightarrow_{\eta} M$.
  \end{enumerate}
\end{defin}

Let us define translation $\ulcorner . \urcorner$ from $\lambda_{\text{IEL}^{-}}$ into monadic metalanguage.
Without loss of generality we will consider $\lambda_{\text{IEL}^{-}}$ with $\to$ and $\Box$:

\begin{defin} Translation for types
  \begin{enumerate}
    \item $\ulcorner A \urcorner = A$ for an atomic $A$;
    \item $\ulcorner A \to B \urcorner = \ulcorner A \urcorner \to \ulcorner B \urcorner$;
    \item $\ulcorner \Box A \urcorner = \bigcirc \ulcorner A \urcorner$
  \end{enumerate}
\end{defin}

\begin{defin} Translation for terms
  \begin{enumerate}
    \item $\ulcorner x \urcorner = x$ for $x \in \mathbb{V}$;
    \item $\ulcorner \lambda x. M \urcorner = \lambda x. \ulcorner M \urcorner$;
    \item $\ulcorner M N \urcorner = \ulcorner M \urcorner \ulcorner N \urcorner$;
    \item $\ulcorner {\bf box \:} M \urcorner = {\bf val \:} \ulcorner M \urcorner$
    \item $\ulcorner {\bf let \: box \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N \urcorner = {\bf val \:} \ulcorner N \urcorner$;
    \item $\ulcorner {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \:} N \urcorner = {\bf let \: val \:} \vec{x} = \ulcorner \vec{M} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner N \urcorner$;
  \end{enumerate}
\end{defin}

Where ${\bf let \: val \:} \vec{x} = \ulcorner \vec{M} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner N \urcorner$ denotes
${\bf let \: val \:} x_n = \ulcorner M_n \urcorner {\: \bf in \:} (\dots ({\bf let \: val \:} x_1 = \ulcorner M_1 \urcorner {\bf \: in \: } \ulcorner N \urcorner) \dots)$

\begin{defin} Interpretation for modal rules
  \begin{prooftree}
    \AxiomC{$\ulcorner \Gamma \vdash M : A \urcorner = \ulcorner \Gamma \urcorner \vdash \ulcorner M \urcorner : \ulcorner A \urcorner$}
    \UnaryInfC{$\ulcorner \Gamma \vdash {\bf box \:} M : \Box A \urcorner = \ulcorner \Gamma \urcorner \vdash {\bf val \:} \ulcorner M \urcorner : \bigcirc \ulcorner A \urcorner$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ulcorner \Gamma \vdash \vec{M} : \Box \vec{A} \urcorner = \ulcorner \Gamma \urcorner \vdash \ulcorner \vec{M} \urcorner : \bigcirc \ulcorner \vec{A} \urcorner$}
    \AxiomC{$\ulcorner \vec{x} : \vec{A} \vdash N : B \urcorner = \vec{x} : \ulcorner \vec{A} \urcorner \vdash \ulcorner N \urcorner : \ulcorner B \urcorner$}
    \UnaryInfC{$\vec{x} : \ulcorner \vec{A} \urcorner \vdash {\bf val \:} \ulcorner N \urcorner : \bigcirc \ulcorner B \urcorner$}
    \BinaryInfC{$\ulcorner \Gamma \vdash {\bf let \: box \:} \vec{x} = \vec{M} {\: \bf in \:} N : \Box B \urcorner = \ulcorner \Gamma \urcorner \vdash {\bf let \: val \:} \vec{x} = \ulcorner \vec{M} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner N \urcorner : \bigcirc \ulcorner B \urcorner$}
  \end{prooftree}
\end{defin}

\begin{lemma}
  $ $

  $\ulcorner M [x := N] \urcorner = \ulcorner M \urcorner [x := \ulcorner N \urcorner]$
\end{lemma}

\begin{proof}
  Induction on the structure of $M$.
\end{proof}

\begin{lemma}
  $ $

  If $M =_{r} N$, then $\ulcorner M \urcorner =_{\beta \eta} \ulcorner N \urcorner$.
\end{lemma}

\begin{proof}
$ $

1) \\
$\begin{array}{lll}
&\ulcorner {\bf let \: box \:} x = ({\bf let \: box \:} \vec{y} = \vec{N} {\: \bf in \:} P) {\: \bf in \:} M \urcorner = & \\
&\quad {\bf let \: val \:} x = ({\bf let \: val \:} \vec{y} = \ulcorner \vec{N} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner P \urcorner) {\: \bf in \:} {\bf val \:} \ulcorner M \urcorner \rightarrow_{\beta} & \\
&\quad {\bf let \: val \:} \vec{y} = \ulcorner \vec{N} \urcorner {\: \bf in \:} ({\bf let \: val \:} x = \ulcorner P \urcorner {\: \bf in \:} {\bf val \:} \ulcorner M \urcorner) \rightarrow_{\beta} & \\
&\quad {\bf let \: val \:} \vec{y} = \ulcorner \vec{N} \urcorner {\: \bf in \:} {\bf val \:} \ulcorner M \urcorner [x := \ulcorner P \urcorner] = & \\
&\ulcorner {\bf let \: box \:} \vec{y} = \vec{N} {\: \bf in \:} M [x := P] \urcorner&
\end{array}$

\vspace{\baselineskip}

2) \\
$\begin{array}{lll}
&\ulcorner {\bf let \: box \:} \vec{x} = {\bf box \:} \vec{N} {\: \bf in \:} M \urcorner = & \\
&\quad {\bf let \: val \:} \vec{x} = {\bf val \:} \ulcorner \vec{N} \urcorner {\: \bf in \:} {\bf val} \ulcorner M \urcorner \rightarrow_{\beta} & \\
&\quad {\bf val \:} \ulcorner M \urcorner [\vec{x} := \ulcorner \vec{N} \urcorner] =& \\
&\ulcorner {\bf box \:} M [\vec{x} := \vec{N}] \urcorner&
\end{array}$

\vspace{\baselineskip}

3) \\
$\begin{array}{lll}
&\ulcorner {\bf let \: box \:} x = M {\: \bf in \:} x \urcorner = & \\
&\quad {\bf let \: val \:} x = \ulcorner M \urcorner {\: \bf in \:} {\bf val \:} x \rightarrow_{\eta}& \\
&\ulcorner M \urcorner&
\end{array}$

\end{proof}

\begin{theorem}
  $ $

  If $\Gamma \vdash M : A$, then $\ulcorner \Gamma \urcorner \vdash \ulcorner M \urcorner : \ulcorner A \urcorner$
\end{theorem}

\begin{proof}
  Follows from lemmas above.
\end{proof}


\section{Acknowledgment}

  We are grateful to Neel Krishnaswami, Vladimir Krupski, Valeria de Paiva, Valerii Plisko and Vladimir Vasyukov for consulting and advice.

  \addcontentsline{toc}{section}{References}

  \begin{thebibliography}{}

  \bibitem{Artemov} Artemov S. and Protopopescu T., \/ ``Intuitionistic Epistemic Logic'', \textit{The
  Review of Symbolic Logic}, 2016, vol. 9, no 2. pp. 266-298.\parskip=1mm

  \bibitem{Krupski} Krupski V. N. and Yatmanov A., \/ ``Sequent Calculus for Intuitionistic Epistemic Logic
  IEL'', \textit{Logical Foundations of Computer Science: International Symposium, LFCS 2016, Deerfield
  Beach, FL, USA, January 4-7, 2016. Proceedings}, 2016, pp. 187-201.\parskip=1mm

  \bibitem{Haskell} Haskell Language. // URL: https://www.haskell.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Idris} Idris. A Language with Dependent Types.// URL:https://www.idris-lang.org. (Date:
  1.08.2017) \parskip=1mm

  \bibitem{Purs} Purescript. A strongly-typed functional programming language that compiles to JavaScript.
  URL: http://www.purescript.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Base} Hackage, \/ ``The base package'' // URL: https://hackage.haskell.org/package/base-4.10.0.0
  (Date: 1.08.2017) \parskip=1mm

  \bibitem{Miran} Lipovaca M, \/ ``Learn you a Haskell for Great Good!''. //URL:
  http://learnyouahaskell.com/chapters (Date: 1.08.2017) \parskip=1mm

  \bibitem{McP} McBride C. and Paterson R., ``Applicative programming with effects", \textit{Journal of
  Functional Programming}, 2008, vol. 18, no 01. pp 1-13. \parskip=1mm

  \bibitem{McP2} McBride C. and Paterson R, ``Functional Pearl. Idioms: applicative programming with
  effects'', \textit{Journal of Functional Programming}, 2005. vol. 18, no 01. pp 1-20. \parskip=1mm

  \bibitem{Neder} R. Nederpelt and H. Geuvers, ``Type Theory and Formal Proof: An Introduction''.
  \textit{Cambridge University Press}, New York, NY, USA, 2014. pp. 436. \parskip=1mm

  \bibitem{Morten} Sorensen M. H. and Urzyczyn P, ``Lectures on the Curry-Howard isomorphism'',
  \textit{Studies in Logic and the Foundations of Mathematics}, vol. 149, \textit{Elsevier Science}, 1998.
  pp 261. \parskip=1mm

  \bibitem{Pierce} Pierce B. C., ``Types and Programming Languages''. \textit{Cambridge, Mass: The MIT
  Press}, 2002. pp. 605. \parskip=1mm

  \bibitem{Girard} Girard J.-Y., Taylor P. and  Lafont Y, ``Proofs and Types'', \textit{Cambridge University
  Press}, New York, NY, USA, 1989. pp. 175. \parskip=1mm

  \bibitem{Baren} Barendregt. H. P., ``Lambda calculi with types" // Abramsky S., Gabbay Dov M., and S. E.
  Maibaum, ``Handbook of logic in computer science (vol. 2), Osborne Handbooks Of Logic In Computer
  Science'', Vol. 2. \textit{Oxford University Press, Inc.}, New York, NY, USA, 1993. pp 117-309.
  \parskip=1mm

  \bibitem{Hindley} Hindley J. Roger, ``Basic Simple Type Theory''. \textit{Cambridge University Press}, New
  York, NY, USA, 1997. pp. 185. \parskip=1mm

  \bibitem{Lax} Pfenning F. and Davies R., ``A judgmental reconstruction of modal logic'',
  \textit{Mathematical Structures in Computer Science}, vol. 11, no 4, 2001, pp. 511-540. \parskip=1mm

  \bibitem{Baren2} H.P. Barendregt. The Lambda Calculus --- Its Syntax and Semantics. Studies in Logic and
  the Foundations of Mathematics, vol. 103. Amsterdam: North-Holland, 1985.

  \bibitem{ModalK} Yoshihiko KAKUTANI, A Curry-Howard Correspondence for Intuitionistic Normal Modal Logic, Computer Software, Released February 29, 2008, Online ISSN , Print ISSN 0289-6540.

  \bibitem{ModalK1} Kakutani Y. (2007) Call-by-Name and Call-by-Value in Normal Modal Logic. In: Shao Z. (eds) Programming Languages and Systems. APLAS 2007. Lecture Notes in Computer Science, vol 4807. Springer, Berlin, Heidelberg

  \bibitem{Abe} T. Abe. Completeness of modal proofs in first-order predicate logic. Computer Software, JSSST Journal, 24:165 -- 177, 2007.

  \bibitem{LambekScott} Lambek, J. and Scott P.J. (1986) Introduction to Higher Order Categorical Logic, Cambridge Studies in Advanced Mathematics 7, Cambridge: Cambridge University Press.

  \bibitem{ElKelly} Samuel Eilenberg and Max Kelly, Closed categories. Proc. Conf. Categorical Algebra (La Jolla, Calif., 1965).

  \bibitem{Abramsky} Samson Abramsky and Nikos Tzevelekos, Introduction to Categories and Categorical Logic

  \bibitem{ModalLa} G. A. Kavvos. The Many Worlds of Modal $\Lambda$--calculi: I. Curry-Howard for Necessity, Possibility and Time

  \bibitem{Cons} Ross Paterson. in Mathematics of Program Construction, Madrid, 2012, Lecture Notes in Computer Science, vol. 7342, pp. 300--323, Springer, 2012.
\end{thebibliography}

\end{document}
