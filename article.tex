\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{dsfont}
\usepackage[all, 2cell]{xy}
\usepackage[all]{xy}
\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{defin}{Definition}
\newtheorem{ex}{Example}
\newtheorem{col}{Corollary}
\newtheorem{con}{Consequence}
\usepackage{listings} 		% for source code
\date{}
\title{Modal type theory based on the intuitionistic epistemic logic}

\begin{document}
\maketitle

\begin{abstract}
Modal intuitionistic epistemic logic IEL$^{-}$ was proposed by S.Artemov and T. Protopopescu as the formal
foundation for the intuitionistic theory of knowledge. We construct a modal simply typed lambda-calculus
which is Curry-Howard isomorphic to IEL$^{-}$ as formal theory of calculations with applicative functors in
functional programming languages like Haskell or Idris.
\end{abstract}


  % This is a comment, not shown in final output.
  % The following shows typesetting  power of LaTeX:

  \section{Introduction}

  Modal intutionistic epistemic logic IEL was proposed by S. Artemov and T. Proropopescu \cite{Artemov}. IEL
  provides the epistimology and the theory of knowledge as based on BHK-semantics of intuitionistic logic.
  IEL$^{-}$  is a variant of IEL, that corresponds to intuitionistic belief.
  Informally, ${\bf K}A$ denotes that $A$ is verified intuitionistically.

  Intuitionistic epistemic logic IEL$^{-}$ is defined with by following axioms and derivation rules:

  \begin{defin} Intuitionistic epistemic logic IEL:

    1) IPC axioms;

    2) ${\bf K}(A \to B) \to ({\bf K}A \to {\bf K}B)$ (normality);

    3) $A \to {\bf K}A$ (co-reflection);

    Rule: MP.

  \end{defin}

  We have the deduction theorem and necessitation rule which is derivable.

  V. Krupski and  A. Yatmanov provided the sequential calculus for IEL and proved that this calculus is
  PSPACE-complete \cite{Krupski}.

  Functional programming languages such as Haskell \cite{Haskell}, Idris \cite{Idris}, Purescript \cite{Purs}
  Elm \cite{Elm} or Scala \cite{Scala} have special type classes\footnote{Type class in Haskell is a general interface for
  special group of datatypes.} for calculations with container types like \verb"Functor" and
  \verb"Applicative" \footnote{Reader may read more about container types in the Haskell standard library documentation\cite{Base} or in the next one textbook
  \cite{Miran}}:

  \begin{lstlisting}[language=Haskell]
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    class Functor f => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}

  By \emph{container} (or \emph{computational context}) type we mean some type-operator $f$, where $f$ is a
  ``function'' from $*$ to $*$: type operator takes a simple type (which has kind $*$) and returns another
  simple type type with kind \verb"*". For more detailed description of the type system with kinds used in
  Haskell see \cite{Morten}.

  The motivation for using an applicative functor is quite natural. Applicative functor allows to generalize the action of a functor for functions with arbitrary number of arguments, for instance:
  \begin{lstlisting}[language=Haskell]
  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
  liftA2 f x y = pure f <*> x <*> y
  \end{lstlisting}

  It's not difficult to see that modal axioms in $IEL^{-}$ and types of the methods of Applicative class in
  Haskell-like languages (which is described below) are syntactically similar and we are going to show that
  this coincidence has a non-trivial computational meaning.

  The main goal of our research is a relationship between intuitionistic epistemic logic $IEL^{-}$ and
  functional programming with effects. We show that relationship by building the type system (which is called $\lambda_{\textbf{K}}$) which is Curry-Howard isomorphic to $IEL^{-}$. So we will consider $\textbf{K}$-modality as an arbitrary applicative functor.

  $\lambda_{{\bf K}}$ consists of the rules for simply typed lambda-calculus and special typing rules for
  lifting types into the applicative functor $\textbf{K}$. We assume that our type system will
  axiomatize the simplest case of computation with effects with one container. We provide proof-theoretical
  view on
  this kind of computations in functional programming and prove strong normalization and confluence.

  \section{Typed lambda-calculus based on IEL$^{-}$}

  At first we define the natural deduction for IEL$^{-}$ :

  \begin{defin} Natural deduction NIEL for IEL$^{-}$ is an extenstion of intuitionistic natural deduction with additional derivation rules for modality:

  \begin{minipage}{0.5\textwidth}
    \begin{flushleft}
  	\begin{prooftree}
    	\AxiomC{$\Gamma \vdash A$}
    	\RightLabel{$\textbf{K}_I$}
    	\UnaryInfC{$\Gamma \vdash \textbf{K}A$}
  \end{prooftree}
    \end{flushleft}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \begin{flushright}
  	\begin{prooftree}
    \AxiomC{$\Gamma \vdash {\bf K} \vec{A}$}
    \AxiomC{$\vec{A} \vdash B$}
    \BinaryInfC{$\Gamma \vdash {\bf K} B$}
  	\end{prooftree}
    \end{flushright}
  \end{minipage}
  \end{defin}

Where $\Gamma \vdash {\bf K} \vec{A}$ is a syntax sugar for $\Gamma \vdash {\bf K} A_1 ,\dots, \Gamma \vdash {\bf K} A_n$.

  \vspace{\baselineskip}

  \begin{lemma}
    $\Gamma \vdash_{\text{NIEL}^{-}_{\land, \to}} A \Rightarrow$ IEL$^{-} \vdash \bigwedge \Gamma \rightarrow A$.
  \end{lemma}

  \begin{proof}
Induction on the derivation.

  \vspace{\baselineskip}

Let us consider cases with modality.

\vspace{\baselineskip}

1) If $\Gamma \vdash_{NIEL^{-}_{\land, \to}} A$, then $IEL^{-} \vdash \bigwedge \Gamma \rightarrow \textbf{K}A$.

$\begin{array}{lll}
(1) & \bigwedge \Gamma \rightarrow A & \text{assumption}\\
(2) & A \rightarrow \textbf{K}A &\text{co-reflection}\\
(3) & (\bigwedge \Gamma \rightarrow A) \rightarrow ((A \rightarrow \textbf{K}A) \rightarrow (\bigwedge \Gamma \rightarrow \textbf{K}A))&\text{IPC theorem}\\
(4) & (A \rightarrow \textbf{K}A) \rightarrow (\bigwedge \Gamma \rightarrow \textbf{K}A) &\text{from (1), (3) and MP}\\
(5) & \bigwedge \Gamma \rightarrow \textbf{K}A &\text{from (2), (4) and MP}\\
\end{array}$

\vspace{\baselineskip}

2) If $\Gamma \vdash_{NIEL^{-}_{\land, \to}} {\bf K} \vec{A}$ and $\vec{A} \vdash B$, then $IEL^{-} \vdash \bigwedge \Gamma \rightarrow \textbf{K}B$.

$\begin{array}{lll}
(1) &\bigwedge \Gamma \rightarrow \bigwedge \limits_{i = 1}^{n} {\bf K} A_i & \text{assumption} \\
(2) &\bigwedge \limits_{i = 1}^{n} {\bf K} A_i \rightarrow {\bf K} \bigwedge \limits_{i = 1}^{n} A_i& \text{IEL theorem} \\
(3) &\bigwedge \Gamma \rightarrow {\bf K} \bigwedge \limits_{i = 1}^{n} A_i & \text{from (1), (2) and transitivity} \\
(4) &\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B& \text{assumption} \\
(5) &(\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B) \rightarrow {\bf K} (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{co-reflection}\\
(6) &{\bf K} (\bigwedge \limits_{i = 1}^{n} A_i \rightarrow B)& \text{from (2), (3) and MP} \\
(7) &{\bf K} \bigwedge \limits_{i = 1}^{n} A_i \rightarrow {\bf K} B & \text{from (6) and normality} \\
(8) &\bigwedge \Gamma \rightarrow {\bf K} B & \text{from (3), (7) and transitivity}
\end{array}$

  \end{proof}

\begin{lemma}
  $ $
  If $\text{IEL}^{-} \vdash A$, then $\text{NIEL}^{-} \vdash A$.
\end{lemma}

\begin{proof}
  Straightforward derivation of modal axioms in $\text{NIEL}^{-}$. We consider this derivation below using terms.
\end{proof}

  \vspace{\baselineskip}

  At the next step we build the typed lambda-calculus based on NIEL$^{-}_{\land, \to}$ by proof-assingment in
  rules.

  At first, we define lambda-terms and types for this lambda-calculus.

  \vspace{\baselineskip}

  \begin{defin} The set of terms:

  Let $\mathbb{V}$ be the set of variables. The set $\Lambda_{{\bf K}}$ of terms is defined by the grammar:

$\begin{array}{lll}
& \Lambda_{{\bf K}} ::= \mathbb{V} \: | \:  (\lambda \Lambda.\Lambda_{{\bf K}}) \: | \: (\Lambda_{{\bf K}}\Lambda_{{\bf K}}) \: | \: (\Lambda_{{\bf K}} , \Lambda_{{\bf K}}) \: | \: (\pi_1 \Lambda_{{\bf K}}) \: | \: (\pi_2 \Lambda_{{\bf K}}) \: | & \\
& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad ({\bf pure \: } \: \Lambda_{{\bf K}}) \: | \: ({\bf let \:\: pure} \:\: \Lambda_{{\bf K}} = \Lambda_{{\bf K}} \:\: {\bf in} \:\: \Lambda_{{\bf K}})
\end{array}$

  \end{defin}

  \begin{defin} The set of types:

  Let $\mathbb{T}$ be the set of atomic types. The set $\mathbb{T}_{{\bf K}}$ of types with applicative
  functor ${\bf K}$ is generated by the grammar:
  \begin{equation}
    \mathbb{T}_{{\bf K}} ::= \mathbb{T} \: | \: (\mathbb{T}_{{\bf K}} \to \mathbb{T}_{{\bf K}}) \: |
    \: (\mathbb{T}_{{\bf K}} \times \mathbb{T}_{{\bf K}}) \: | \: ({\bf K}\mathbb{T}_{{\bf K}})
  \end{equation}
  \end{defin}

  Context, domain of context and range of context are defined standardly \cite{Neder}\cite{Morten}.

  Our type system is based on the Curry-style typing rules:

  \begin{defin} Modal typed lambda calculus $\lambda_{{\bf K}}$ based on NIEL$^{-}_{\land, \to}$:

    \begin{center}
    \begin{prooftree}
    \AxiomC{$ $}
    \RightLabel{\scriptsize{ax}}
    \UnaryInfC{$\Gamma , x : A \vdash x : A$}
    \end{prooftree}
    \end{center}

    \begin{minipage}{0.45\textwidth}
      \begin{prooftree}
      \AxiomC{$\Gamma, x : A \vdash M : B$}
      \RightLabel{$\rightarrow_i$}
      \UnaryInfC{$\Gamma \vdash \lambda x. M : A \to B$}
      \end{prooftree}

      \begin{prooftree}
      \AxiomC{ $\Gamma \vdash M : A$ }
      \AxiomC{ $\Gamma \vdash N : B$ }
      \RightLabel{$\times_i$}
      \BinaryInfC{$\Gamma \vdash \langle M, N \rangle : A \times B$}
      \end{prooftree}

      \begin{prooftree}
        \AxiomC{$\Gamma \vdash M : A$}
        \RightLabel{$\textbf{K}_I$}
        \UnaryInfC{$\Gamma \vdash {\bf pure \: } \: M : {\bf K}A $}
      \end{prooftree}
  \end{minipage}%
  \hfill
  \begin{minipage}{0.45\textwidth}
  \begin{tabular}{p{\textwidth}}
    \begin{prooftree}
    \AxiomC{$\Gamma \vdash M : A \to B$}
    \AxiomC{$\Gamma \vdash N : A$}
    \RightLabel{$\rightarrow_e$}
    \BinaryInfC{$\Gamma \vdash MN : B$}
    \end{prooftree}

    \begin{prooftree}
    \AxiomC{ $\Gamma \vdash M : A_1 \times A_2$ }
    \RightLabel{$\times_e$, $i \in \{ 1, 2 \}$}
    \UnaryInfC{$\Gamma \vdash \pi_i M : A_i$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \vec{M} : {\bf K} \vec{A}$}
      \AxiomC{$\vec{x} : \vec{A} \vdash N : B$}
      \RightLabel{$\text{let}_{{\bf K}}$}
      \BinaryInfC{$\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } N : {\bf K} B$}
    \end{prooftree}
  \end{tabular}
  \end{minipage}%

  \end{defin}

  ${\bf K}_I$-typing rule is the same as $\bigcirc$-introduction in lax logic (also known as monadic
  metalanguage \cite{Lax}) and in typed lambda-calculus which is derived by proof-assignment for lax-logic
  proofs.
  ${\bf K}_I$ allows to inject an object of type $\alpha$ into the functor. ${\bf K}_I$  reflects the
  Haskell method {\bf pure} for Applicative class. It plays the same role as the {\bf return} method in Monad class.

  $\text{let}_{{\bf K}}$ is similar to the $\Box$-rule in typed lambda calculus for intuitionistic normal modal logic {\bf IK}, which is described in \cite{ModalK}.

  In fact, our calculus is the extention of typed lambda calculus for {\bf IK} with typing rule appropriate to co-reflection.

  \vspace{\baselineskip}

Here are some examples of closed terms:

\begin{itemize}
\item $(\lambda x. {\bf pure \: } x) : A \to \textbf{K}A$;
\item $\lambda f. \lambda x. {\bf let \: pure} \: g, y  = f, x {\: \bf in \:} g y : {\bf K}(A \to B) \to {\bf K} A \to {\bf K} B$
\item $\lambda f. \lambda x. {\bf let \:pure} \: g, y = {\bf pure \:} f, x  {\: \bf in \: } g y : (A \to B) \to {\bf K} A \to {\bf K} B$
\end{itemize}

  \vspace{\baselineskip}

  Now we define free variables and substitutions. $\beta$-reduction, multi-step $\beta$-reduction and $\beta$-equality are defined standardly:

  \begin{defin} Set $FV(M)$ of free variables for arbitrary term $M$:

  1) $FV(x) = \{ x \}$;

  2) $FV(\lambda x. M) = FV(M) \setminus \{ x\}$;

  3) $FV(M N) = FV(M) \cup FV(N);$

  4) $FV(\langle M,N \rangle) = FV(M) \cup FV(N)$;

  5) $FV(\pi_i M) \subseteq FV(M)$, $i \in \{ 1, 2\}$;

  6) $FV(\text{pure } M) = FV(M)$;

  7) $FV({\bf let \:\: pure} \:\: \vec{N} = \vec{M} \:\: {\bf in} \:\: M) = \bigcup \limits_{i = 1}^n FV(M), \text{where $n = |\vec{M}|$}$.
  \end{defin}

  \begin{defin} Substitution:

  1) $x [x := N] = N$, $x [y := N] = x$;

  2) $(M N) [x := N] = M[x := N] N [x := N]$;

  3) $(\lambda x. M) [x := N] = \lambda x. M [x := N]$;

  4) $(M, N)[x := P] = (M[x := P], N [x := P])$;

  5) $(\pi_i M) [x := P] = \pi_i (M[x := P])$, $i \in \{ 1, 2\}$;

  6) $({\bf pure \: } M) [x := P] = {\bf pure \: } (M [x := P])$;

  7) $({\bf let \: pure \:}\vec{x} = \vec{M} {\: \bf in \:} N) [y := P] = {\bf let \: pure \:} \vec{x} = (\vec{M} [y := P]) {\: \bf in \:} M$.
  \end{defin}

  \begin{defin} Type substituition

    The substituition of type $C$ for type variable $B$ in type $A$ inductively defined as follows:

    1) $B [B := C] = B$ and $D [B := C] = D$, if $B \neq D$;

    2) $(A_1 \alpha A_2)[B := C] = (A_1[B := C]) \alpha (A_2[B := C])$, where $\alpha \in \{ \to, \times \}$;

    3) $({\bf K}A)[B := C] = {\bf K}(A [B := C])$.

    4) Let $\Gamma$ be the context, then $\Gamma [B := C] = \{ x : (A[B := C]) \: | \: x : A \in \Gamma \}$
  \end{defin}

  \begin{defin} $\beta$-reduction and $\eta$-reduction rules for \emph{$\lambda \textbf{K}$}.

  1) $(\lambda x. M) N \rightarrow_{\beta} M [x := N]$;

  2) $\pi_1 \langle M, N \rangle \rightarrow_{\beta} M$;

  3) $\pi_2 \langle M, N \rangle \rightarrow_{\beta} N$;

  4) $\begin{array}{llll}
  & {\bf let \: pure \:} \langle \vec{x}, y, \vec{z} \rangle = \langle \vec{M}, {\bf let \: pure \: } \vec{w} = \vec{N} {\bf \: in \: } Q, \vec{P} \rangle {\: in \:} R \rightarrow_{\beta} & \\
  & {\bf let \: pure \:} \langle \vec{x}, \vec{w}, \vec{z} \rangle = \langle \vec{M}, \vec{N}, \vec{P} \rangle \: { \bf in } \: R [y := Q]
  \end{array}$

  5) ${\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N \rightarrow_{\beta} {\bf pure \:} N [\vec{x} := \vec{M}]$

  6) ${\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N \rightarrow_{\beta} {\bf pure \:} N$;

  7) $\lambda x. f x \rightarrow_{\eta} f$;

  8) $\langle \pi_1 P, \pi_2 P \rangle \rightarrow_{\eta} P$;

  9) ${\bf let \: pure \:} x = M {\: \bf in \: } x \rightarrow_{\eta} M$;

  10) $M \rightarrow_{\beta \eta} N \Rightarrow {\bf pure \: M} \rightarrow_{\beta \eta} {\bf pure \: N}$
  \end{defin}


  \section{Basic lemmas}

  Now we will prove standard lemmas for contexts in type systems\footnote{We will not prove cases with
  $\to$-constructor, they are proved standardly in the same lemmas for simply typed lambda calculus, for
  example see \cite{Neder} \cite{Morten} \cite{Girard}. We will consider only modal cases}:

\begin{lemma} Basic lemmas for ${\bf K}_I$.

  i) Let $\Gamma \vdash {\bf pure \:} M : {\bf K}A$, then $\Gamma \vdash M : A$;

  ii) Let $\Gamma \vdash M : A$ and $\Gamma \subseteq \Delta$, then $\Delta \vdash M : A$;

  iii) Let $\Gamma, x : A \vdash {\bf pure \:} M : {\bf K}B$ and $\Gamma \vdash N : A$, then $\Gamma \vdash {\bf pure \:} M [x := N] : {\bf K}B$.

  iv) Let $\Gamma \vdash {\bf pure \:} M : {\bf K}A$, then $\Gamma [B := C] \vdash {\bf pure \:} M : {\bf K} (A [B := C])$.
\end{lemma}

\begin{proof}
  $ $

  i) Induction on $\Gamma \vdash {\bf pure \:} M : {\bf K}A$ and $\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{N} {\: \bf in \:} N : {\bf K}B$ correspondently.

  ii) Let $\Gamma \vdash {\bf pure \:} M : {\bf K}A$. Then $\Gamma \vdash M : A$ by generation and $\Delta \vdash M : A$ by assumption. So $\Delta \vdash {\bf pure \:} M : {\bf K} A$ by ${\bf K}_I$.

  iii) Let $\Gamma, x : A \vdash {\bf pure \:} M : {\bf K}B$ and $\Gamma \vdash N : A$.

  By generation $\Gamma, x : A \vdash M : B$ and by assumption $\Gamma \vdash M [x := N] : B$.

  By $K_I$, $\Gamma \vdash {\bf pure \:} (M [x := N]) : {\bf K}B$.

  iv) Let $\Gamma \vdash {\bf pure \:} M : {\bf K}A$. By generation $\Gamma \vdash M : A$ and by assumption $\Gamma [B := C] \vdash M : A[B := C]$.

  By $K_I$ $\Gamma \vdash {\bf pure \:} M : {\bf K}(A[B := C])$.
\end{proof}

\begin{theorem} Subject reduction

  Let $\Gamma \vdash M : A$ and $M \twoheadrightarrow_{\beta \eta} N$, then $\Gamma \vdash N : A$

\end{theorem}

\begin{proof}
For cases with application, abstraction and pairs see \cite{Morten} \cite{Pierce}.

1)
  Let $\Gamma \vdash {\bf let \: pure \:} \langle \vec{x}, y, \vec{z} \rangle = \langle \vec{M}, {\bf let \: pure \: } \vec{w} = \vec{N} {\bf \: in \: } Q, \vec{P} \rangle {\: in \:} R : {\bf K}B$,
  then $\Gamma {\bf let \: pure \:} \langle \vec{x}, \vec{w}, \vec{z} \rangle = \langle \vec{M}, \vec{N}, \vec{P} \rangle \: { \bf in } \: R [y := Q] : {\bf K}B$

2) Let $\Gamma \vdash {\bf let \: pure \:} x = M {\: \bf in \: } x : {\bf K}A$, then $\Gamma \vdash M : {\bf K}A$.

See \cite{ModalK}.

\end{proof}

\begin{theorem}
  $ $

  i) $\twoheadrightarrow_{\beta}$ is strongly normalizing;

  ii) $\twoheadrightarrow_{\beta}$ is confluent.
\end{theorem}

\begin{proof}
  $ $

i) Strong normalization for ${\bf IK}$ was proved by Kakutani for call-by-value and for call-by name \cite{ModalK} \cite{ModalK1}.

It is easy to extend Kakutani's result for ${\bf pure}$-rules.

ii) Confluence can be proved by extending Barendregt's technique with term underlying for untyped or simply typed lambda calculus \cite{Baren}.

Hence, it is sufficient to prove strip lemma.
\end{proof}

\begin{theorem}
  $ $

  Normal form in call-by-name $\lambda_{{\bf K}}$ has the subformula property.

\end{theorem}

\begin{proof}
  By induction on the structure of term. Case with ${\bf let \: pure\:} \vec{x} = \vec{M} {\: \bf in \:} N$ was considered by Kakutani \cite{ModalK} \cite{ModalK1}.
  Similary, if ${\bf pure \:} M$ is a normal form, so $M$ is a normal form too by hypothesis.
\end{proof}

\section{Categorical semantics}

\begin{defin} Monoidal functor

  Let $\langle \mathcal{C}, \otimes_1, \mathds{1} \rangle$ and $\langle \mathcal{D}, \otimes_2, \mathds{1}' \rangle$ are monoidal categories.

  A monoidal functor $\mathcal{F} : \langle \mathcal{C}, \otimes_1, \mathds{1} \rangle \to \langle \mathcal{D}, \otimes_2, \mathds{1}' \rangle$ is a functor
  $\mathcal{F} : \mathcal{C} \to \mathcal{D}$ with additional natural transformations, which satisfy the well-known conditions described in \cite{ElKelly}:

  1) $u : \mathds{1}' \to \mathcal{F}\mathds{1}$;

  2) $\ast_{A, B} : \mathcal{F}A \otimes_2 \mathcal{F}B \to \mathcal{F}(A \otimes_1 B)$.

\end{defin}

\begin{defin} Applicative functor

  An applicative functor is a triple $\langle \mathcal{C}, \mathcal{K}, \eta \rangle$,
where $\mathcal{C}$ is a symmetric monoidal category, $\mathcal{K}$ is a monoidal and $\eta : Id_{\mathcal{C}} \Rightarrow \mathcal{K}$ is a natural transformation (similar to unit in monad), such that:

1) $u = \eta_{\mathds{1}}$;

2) $\ast_{A,B} \circ (\eta_A \otimes \eta_B) = \eta_{A \otimes B}$;

3) Weak commutativity condition:

\xymatrix{
&& A \otimes \mathcal{K}B \ar[d]_{\sigma_{A, \mathcal{K}B}} \ar[rr]^{\eta_{A} \otimes id_{\mathcal{K}B}} && \mathcal{K}A \otimes \mathcal{K}B \ar[rr]^{\ast_{A,B}} && \mathcal{K}(A \otimes B) \ar[d]^{\mathcal{K}(\sigma_{A,B})}\\
&& \mathcal{K}B \otimes A \ar[rr]_{id_{\mathcal{K}B} \otimes \eta_{A}} && \mathcal{K}B \otimes \mathcal{K}A \ar[rr]_{\ast_{B,A}} && \mathcal{K}(B \otimes A)
}
\end{defin}

\subsection{Soundness and completeness}

\begin{theorem} Soundness

  Let $\Gamma \vdash M : A$ and $M =_{\beta\eta} N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$
\end{theorem}

\begin{proof}

\begin{defin} Semantical translation from $\lambda_{\textbf{K}}$ to CCC with applicative functor $\mathcal{K}$:

1) Interpretation for types:

$[\![A]\!] := \hat{A}, A \in \mathbb{T}$;

$[\![A \to B]\!] := [\![A]\!] \to [\![B]\!]$;

$[\![A \times B]\!] := [\![A]\!] \times [\![B]\!]$.

2) Interpretation for modal types: $[\![\textbf{K}A]\!] = \mathcal{K}[\![A]\!]$;

3) Interpretaion for contexts:

$[\![\Gamma = \{ x_1 : A_1, ..., x_n : A_n\}]\!] := [\![\Gamma]\!] = [\![A_1]\!] \times ... \times [\![A_n]\!]$;

4) Interpretation for typing assignment: $[\![\Gamma \vdash M : A]\!] := [\![M]\!] : [\![\Gamma]\!] \to
[\![A]\!]$.

5) Interpretation for typing rules:

\begin{prooftree}
\AxiomC{$ $}
\UnaryInfC{$[\![\Gamma, x : A \vdash x : A]\!] = \pi_2 : [\![\Gamma]\!] \times [\![A]\!] \rightarrow
[\![A]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma, x : A \vdash M : B]\!] = f : [\![\Gamma]\!] \times [\![A]\!] \rightarrow [\![B]\!]$}
\UnaryInfC{$[\![\Gamma \vdash (\lambda x. M) : A \to B]\!] = \Lambda(f) : [\![\Gamma]\!]
\rightarrow[\![B]\!]^{[\![A]\!]}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A \to B]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![B]\!]^{[\![A]\!]}$}
\AxiomC{$[\![\Gamma \vdash N : A]\!] = [\![N]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M N) : B]\!] = [\![\Gamma]\!] \xrightarrow{\langle [\![M]\!], [\![N]\!]
\rangle} [\![B]\!]^{[\![A]\!]} \times [\![A]\!] \xrightarrow{\epsilon} [\![B]\!] $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A ]\!] = f : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\AxiomC{$[\![\Gamma \vdash N : B ]\!] = g : [\![\Gamma]\!] \rightarrow [\![B]\!]$}
\BinaryInfC{$[\![\Gamma \vdash (M, N) : A \times B]\!] = \langle f, g \rangle : [\![\Gamma]\!] \rightarrow
[\![A]\!] \times [\![B]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash p : A_1 \times A_2]\!] = f : [\![\Gamma]\!] \rightarrow [\![A_1]\!] \times
[\![A_2]\!]$}
\RightLabel{$i \in \{1,2\}$}
\UnaryInfC{$[\![\Gamma \vdash \pi_i p : A_i]\!] = [\![\Gamma]\!] \xrightarrow{f} [\![A_1]\!] \times
[\![A_2]\!] \xrightarrow{\pi_i} [\![A_i]\!]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$[\![\Gamma \vdash M : A]\!] = [\![M]\!] : [\![\Gamma]\!] \rightarrow [\![A]\!]$}
\UnaryInfC{$[\![\Gamma \vdash {\bf pure \:} M : \textbf{K}A]\!] := [\![\Gamma]\!] \xrightarrow{[\![M]\!]}
[\![A]\!] \xrightarrow{\eta_{[\![A]\!]}} \mathcal{K}[\![A]\!]$}
\end{prooftree}

  \begin{prooftree}
    \AxiomC{$[\![\Gamma \vdash \vec{M} : {\bf K} \vec{A}]\!] = \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \prod \limits_{i=1}^n \mathcal{K}[\![A_i]\!]$}
    \AxiomC{$[\![\vec{x} : \vec{A} \vdash N : B]\!] = [\![N]\!] : \prod \limits_{i=1}^n [\![A_i]\!] \rightarrow [\![B]\!]$}
    \BinaryInfC{$[\![\Gamma \vdash {\bf let \: pure \:} \vec{x} = \vec{M} {\: \bf in \: } M : {\bf K} B]\!] = \mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ \langle [\![M_1]\!],\dots, [\![M_n]\!] \rangle : [\![\Gamma]\!] \rightarrow \mathcal{K}[\![B]\!]$}
  \end{prooftree}

\end{defin}

\begin{defin} Simultaneous substitution

Let $\Gamma = \{ x_1 : A_1, ..., x_n : A_n \}$, $\Gamma \vdash M : A$ and for all $i \in \{ 1,..., n \}$,
$\Gamma \vdash M_i : A_i$.

We define simultaneous substitution $M [ \vec{x} := \vec{M}]$ recursively by:

1) $x_i [ \vec{x} := \vec{M}] = M_i $;

2) $(\lambda x. M) [ \vec{x} := \vec{M}] = \lambda x. (M [ \vec{x} := \vec{M}])$;

3) $(M N) [ \vec{x} := \vec{M}] = (M [ \vec{x} = \vec{M}]) (N [ \vec{x} := \vec{M}])$;

4) $\langle M, N \rangle = \langle (M [ \vec{x} = \vec{M}]), (N [ \vec{x} := \vec{M}])\rangle$;

5) $(\pi_i P) [ \vec{x} := \vec{M}] = \pi_i (P [ \vec{x} = \vec{M}])$;

6) $({\bf pure \:} M) [ \vec{x} := \vec{M}] = {\bf pure \:} (M [ \vec{x} = \vec{M}])$;

7) $({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] =
{\bf let \: pure} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N$

\end{defin}

\begin{lemma}
$ $

$[\![M [x_1 := M_1,\dots, x_n := M_n]]\!] = [\![M]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle$.

\end{lemma}

\begin{proof}

$ $

1) $[\![\Gamma \vdash ({\bf pure \:} M) [ \vec{x} := \vec{M}] : {\bf K}A ]\!] = [\![ \Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle$.

\vspace{\baselineskip}

$\begin{array}{lll}
& [\![\Gamma \vdash ({\bf pure \:} M) [ \vec{x} := \vec{M}] : {\bf K}A]\!] = [\![ \Gamma \vdash {\bf pure \:} (M [ \vec{x} := \vec{M}]) : {\bf K}A]\!] &
\text{Substitution definition} \\
& \quad\quad\quad\quad\quad\quad\quad = \eta_{[\![A]\!]} \circ [\![(M [ \vec{x} := \vec{M}])]\!]&
\text{Translation for pure}\\
& \quad\quad\quad\quad\quad\quad\quad = \eta_{[\![A]\!]} \circ ([\![M]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle) & \text{Induction hypothesis} \\
& \quad\quad\quad\quad\quad\quad\quad = (\eta_{[\![A]\!]} \circ [\![M]\!]) \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle & \text{Associativity of composition}\\
& \quad\quad\quad\quad\quad\quad\quad = [\![ \Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] \circ \langle [\![M_1]\!], \dots,
[\![M_n]\!] \rangle& \text{Translation for pure}\\
\end{array}$

\vspace{\baselineskip}

2) $\begin{array}{lll}&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : {\bf K} B]\!]
=[\![\Gamma \vdash {\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N : {\bf K}B]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle& \end{array}$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N) [\vec{y} := \vec{P}] : {\bf K} B]\!] =& \\
&\text{Substitution definition}& \\
&[\![\Gamma \vdash {\bf let \: pure} \: \vec{x} = (\vec{M} [\vec{y} := \vec{P}]) {\: \bf in \:} N : {\bf K}B]\!] =& \\
&\text{Interpretaion for $let_{\bf K}$}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ [\![\Gamma \vdash (\vec{M} [\vec{y} := \vec{P}]) \vdash : {\bf K}\vec{A}]\!] =& \\
&\text{Induction hypothesis}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ ([\![\vec{M}]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle) = & \\
&\text{Associativity of composition}& \\
&(\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ [\![\vec{M}]\!]) \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle = & \\
&\text{By interpretation}&\\
&[\![\Gamma \vdash ({\bf let \: pure} \: \vec{x} = \vec{M} {\: \bf in \:} N]\!] \circ \langle [\![P_1]\!],\dots,[\![P_n]\!]\rangle&
\end{array}$

\end{proof}

\begin{lemma}
  $ $

  Let $\Gamma \vdash M : A$ and $M \twoheadrightarrow_{\beta \eta} N$, then $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$;
\end{lemma}

\begin{proof}
  $ $

Cases with $\beta$-reductions for $let_{\bf K}$ are shown in \cite{ModalK1}. Let us consider cases with ${\bf pure}$.

\vspace{\baselineskip}

1) $[\![\Gamma \vdash {\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N : {\bf K}B]\!] = [\![\Gamma \vdash {\bf pure \:} N [\vec{x} := \vec{M}] : {\bf K}B]\!]$

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\Gamma \vdash {\bf let \: pure \:} \vec{x} = {\bf pure \:} \vec{M} {\: \bf in \:} N : {\bf K}B]\!] = & \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By interpretation}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ \langle \eta_{[\![A_1]\!]} \circ [\![M_1]\!],\dots,\eta_{[\![A_n]\!]} \circ [\![M_n]\!] \rangle = \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By the property of a pair of morphisms}& \\
&\mathcal{K}([\![N]\!]) \circ \ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ (\eta_{[\![A_1]\!]} \times \dots \times \eta_{[\![A_n]\!]}) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]\rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Associativity of composition}& \\
&\mathcal{K}([\![N]\!]) \circ (\ast_{[\![A_1]\!],\dots,[\![A_n]\!]} \circ (\eta_{[\![A_1]\!]} \times \dots \eta_{[\![A_n]\!]})) \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By the definition of an applicative functor}& \\
&\mathcal{K}([\![N]\!]) \circ \eta_{[\![A_1]\!] \times \dots \times [\![A_n]\!]} \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Naturality of $\eta$}& \\
&\eta_{[\![B]\!]} \circ [\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!] \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Associativity of composition}& \\
&\eta_{[\![B]\!]} \circ ([\![N]\!] \circ \langle [\![M_1]\!], \dots, [\![M_n]\!]) \rangle =& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad Simultaneous substitution lemma}& \\
&\eta_{[\![B]\!]} \circ [\![N [\vec{x} := \vec{M}]]\!]& \\
&\text{\quad\quad\quad\quad\quad\quad\quad\quad\quad By interpetation}& \\
&[\![\Gamma \vdash {\bf pure \:} (N [\vec{x} := \vec{M}]) : {\bf K}B]\!]&
\end{array}$

2) $[\![\vdash {\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N : {\bf }K A ]\!] = [\![\vdash {\bf pure \:} N : {\bf K A}]\!]$.

\vspace{\baselineskip}

$\begin{array}{lll}
&[\![\vdash {\bf let \: pure \:} \underline{\quad} = \underline{\quad} {\: \bf in \:} N : {\bf }K A ]\!] = & \text{By interpetation}\\
&\mathcal{K}([\![N]\!]) \circ \eta_{\mathds{1}} =& \text{Naturality for $\eta$} \\
&\eta_{[\![A]\!]} \circ [\![N]\!] =& \text{By interpretation} \\
&[\![\vdash {\bf pure \:} N : {\bf K} A]\!]&
\end{array}$

\vspace{\baselineskip}

3)

If $\Gamma \vdash M : A$ and $M \rightarrow_{\beta \eta} N$, then $[\![\Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] = [\![\Gamma \vdash {\bf pure \:} N : {\bf K}A]\!]$.

\vspace{\baselineskip}

If $\Gamma \vdash M : A$ and $M \rightarrow_{\beta \eta} N$, then $\Gamma \vdash N : A$ by subject reduction.

By assumption $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$.

So $\eta_{[\![A]\!]} \circ [\![\Gamma \vdash M : A]\!] = \eta_{[\![A]\!]} \circ [\![\Gamma \vdash N : A]\!]$.

Hence $[\![\Gamma \vdash {\bf pure \:} M : {\bf K}A]\!] = [\![\Gamma \vdash {\bf pure \:} N : {\bf K}A]\!]$.

\end{proof}

\end{proof}

\begin{theorem} Completeness

Let $[\![\Gamma \vdash M : A]\!] = [\![\Gamma \vdash N : A]\!]$, then $M =_{\beta \eta} N$.
\end{theorem}

\begin{proof}

$ $

We will consider term model for simply typed lambda calculus $\times$ and $\to$ standardly described in \cite{LambekScott}.

\begin{defin}
  Let us define an endofunctor $\mathcal{K} : \mathcal{C}(\lambda) \to \mathcal{C}(\lambda)$, such that
forall $[x,M] \in Hom_{\mathcal{C}(\lambda)}(A,B), {\bf K}([x,M]) = [y, {\bf let \: pure \:} x = y {\: \bf in \:} M] \in Hom_{\mathcal{C}(\lambda)}({\bf K} A, {\bf K} B)$ (denotation: $\text{fmap } f$ for an arbitrary arrow $f$).

\end{defin}

\begin{lemma} Functoriality

  i) $\text{fmap }(g \circ f) = \text{fmap }(g) \circ \text{fmap }(f)$;

  ii) $\text{fmap }(id_A) = id_{{\bf K}A}$.
\end{lemma}

\begin{proof}

Easy checking using reduction rules.

\end{proof}

\begin{defin}

  Let us define natural transformations:

  1) $\eta:Id \Rightarrow \mathcal{K}$, s. t. $\forall A \in Ob_{\mathcal{C}(\lambda)}$, $\eta_A = [x, {\bf pure \:} x] \in Hom_{\mathcal{C}(\lambda)}(A, {\bf K}A)$;

  2) $\ast_{A,B}:{\bf K}A \times {\bf K}B \to {\bf K}(A \times B)$, s. t. $\forall A, B \in Ob_{\mathcal{C}(\lambda)}, \ast_{A,B} = [p, {\bf let \: pure \:} x,y = \pi_1 p, \pi_2 p {\: \bf in \:} \langle x, y \rangle] \in Hom_{\mathcal{C}(\lambda)}({\bf K}A \times {\bf K}B, {\bf K}(A \times B))$.
\end{defin}

Implementation for $\ast$ in our term model is a modification of ${\text{let}_{\bf K}}$-rule:

\begin{prooftree}
\AxiomC{$p : {\bf K}A \times {\bf K}B \vdash p : {\bf K}A \times {\bf K}B$}
\UnaryInfC{$p : {\bf K}A \times {\bf K}B \vdash \pi_1 p : {\bf K} A$}
\AxiomC{$p : {\bf K}A \times {\bf K}B \vdash p : {\bf K}A \times {\bf K}B$}
\UnaryInfC{$p : {\bf K}A \times {\bf K}B \vdash \pi_2 p : {\bf K} B$}
\AxiomC{$x : A \vdash x : A$}
\AxiomC{$y : B \vdash y : B$}
\BinaryInfC{$x : A, y : B \vdash \langle x, y \rangle : A \times B$}
\TrinaryInfC{$p : {\bf K}A \times {\bf K}B \vdash {\bf let \: pure \:} \langle x,y \rangle = \langle \pi_1 p, \pi_2 p \rangle {\: \bf in \:} \langle x, y \rangle : {\bf K}(A \times B)$}
\end{prooftree}

\begin{lemma} Naturality for $\eta$ and for $\ast$

  i) $\text{fmap } f \circ \eta_A = \eta_B \circ f$;

  ii) $\text{fmap } (f \times g) \circ \ast_{A, B} = \ast_{C,D} \circ (\text{fmap } f) \times (\text{fmap } g)$.

  iii) $\ast_{A,B} \circ (\eta_{A} \times \eta_{B}) = \eta_{A \times B}$;
\end{lemma}

\begin{proof}
  $ $

  i) $\text{fmap } f \circ \eta_A = \eta_B \circ f$

\vspace{\baselineskip}

$\begin{array}{lll}
&\eta_B \circ f = & \text{By the definition} \\
&[y, {\bf pure \:} y] \circ [x, M] = & \text{By the definition of composition}\\
&[x, {\bf pure \:} y [y := M]] = & \text{By substitution}\\
&[x, {\bf pure \:} M]& \\
& &\\
&\text{On the other hand:}& \\
&\text{fmap } f \circ \eta_A = & \text{By the definiton} \\
&[z, {\bf let \: pure \:} x = z {\: \bf in \:} M] \circ [x, {\bf pure \: x}] = & \text{By the definition of composition}\\
&[x, {\bf let \: pure \:} x = z {\: \bf in \:} M [z := {\bf pure \:} x]] = & \text{By substitution} \\
&[x, {\bf let \: pure \:} x = {\bf pure \: x} {\: \bf in \:} M] = & \text{$\beta$-reduction rule}\\
&[x, {\bf pure \:} M [x := x]] = & \text{By substitution}\\
&[x, {\bf pure \:} M]&
\end{array}$

\vspace{\baselineskip}

ii)  $\text{fmap } (f \times g) \circ \ast_{A, B} = \ast_{C,D} \circ (\text{fmap } f) \times (\text{fmap } g)$

\vspace{\baselineskip}

See \cite{ModalK}.

\vspace{\baselineskip}

iii) $\ast_{A,B} \circ (\eta_{A} \times \eta_{B}) = \eta_{A \times B}$

\vspace{\baselineskip}

$\begin{array}{lll}
& \ast_{A,B} \circ (\eta_{A} \times \eta_{B}) = & \\
& \text{By unfolding} & \\
& [q, {\bf let \: pure \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle] \circ [p, \langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle] = & \\
& \text{Composition}& \\
& [p, {\bf let \: pure \:} x, y = \pi_1 q, \pi_2 q {\: \bf in \:} \langle x, y \rangle [q := \langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle]] = & \\
& \text{By substitution}& \\
& [p, {\bf let \: pure \:} x, y = \pi_1 (\langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle), \pi_2 (\langle {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) \rangle) {\: \bf in \:} \langle x, y \rangle] = & \\
& \text{Reduction rules}& \\
& [p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), {\bf pure \:} (\pi_2 p) {\: \bf in \:} \langle x, y \rangle] = & \\
& \text{Reduction rule}& \\
& [p, {\bf pure \:} (\langle x,y \rangle [x := \pi_1 p, y := \pi_2 p])] = & \\
& \text{Substitution}& \\
& [p, {\bf pure \:} \langle \pi_1 p, \pi_2 p \rangle] = & \\
& \text{$\eta$-reduction}& \\
& [p, {\bf pure \:} p] =& \\
& \text{By definition}& \\
& \eta_{A \times B}&
\end{array}$

\end{proof}

  Tensorial strength is defined as follows:

\begin{defin} Tensorial strength
  $ $

  Let $[p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle] \in Hom_{\mathcal{C}(\lambda)}(A \times {\bf K}B, {\bf K}(A \times B))$.

  So tensorial strength is defined as $\tau_{A, B} = \ast_{A, B} \circ [p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle]$.
\end{defin}

It is clearly that tensorial strength defined above can be simplified as follows:

$\begin{array}{lll}
&\ast_{A, B} \circ [p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle] = & \text{By definition} \\
&[p^{'}, {\bf let \: pure \:} x, y = \pi_1 p^{'}, \pi_2 p^{'} {\: \bf in \:} \langle x, y \rangle] \circ [p, \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle] = & \text{By composition} \\
&[p, {\bf let \: pure \:} x, y = \pi_1 p^{'}, \pi_2 p^{'} {\: \bf in \:} \langle x, y \rangle [p^{'} := \langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle]] = & \text{By substitution} \\
&[p, {\bf let \: pure \:} x, y = \pi_1 (\langle {\bf pure \:} (\pi_1 p), \pi_2 p \rangle), \pi_2 (\langle \pi_1 p, {\bf pure \:} (\pi_2 p) \rangle) {\: \bf in \:} \langle x, y \rangle] = & \text{By $\beta$-reduction rules} \\
&[p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle x, y \rangle]&
\end{array}$



\begin{lemma} Weak commutativity.
  $ $

  $\begin{array}{lll}
  & \text{fmap } ([p, \langle \pi_2 p, \pi_1 p \rangle]) \circ \tau_{A,B} = & \\
  & \ast_{B, A} \circ [q, \langle \pi_1 q, {\bf pure \:} (\pi_2 q) \rangle] \circ [p, \langle \pi_2 p, \pi_1 p \rangle]&
  \end{array}$
\end{lemma}

\begin{proof}
  $ $

  $\begin{array}{lll}
  & \text{fmap } ([r, \langle \pi_2 r, \pi_1 r \rangle]) \circ \tau_{A,B} = & \\
  &\text{By the definition of $\tau$}& \\
  & \text{fmap } ([r, \langle \pi_2 r, \pi_1 r \rangle]) \circ [p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle x, y \rangle] = & \\
  &\text{By the definition of fmap}& \\
  & [q, {\bf let \: pure \:} r = q {\: \bf in \:} \langle \pi_2 r, \pi_1 r \rangle] \circ [p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle x, y \rangle] = & \\
  &\text{Composition}& \\
  & [p, {\bf let \: pure \:} r = q {\: \bf in \:} \langle \pi_2 r, \pi_1 r \rangle [q := {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle x, y \rangle]] = &\\
  &\text{By $\beta$-reduction rules}& \\
  & [p, {\bf let \: pure \:} r = ({\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle x, y \rangle) {\: \bf in \:} \langle \pi_2 r, \pi_1 r \rangle] = & \\
  &\text{By $\beta$-reduction rules}& \\
  & [p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle \pi_2 r, \pi_1 r \rangle [r := \langle x, y \rangle]] = & \\
  &\text{By substitution}& \\
  & [p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle \pi_2 \langle x, y \rangle, \pi_1 \langle x, y \rangle \rangle]= & \\
  &\text{By $\beta$-reduction rules}& \\
  & [p, {\bf let \: pure \:} x, y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle y, x \rangle ] = & \\
  & & \\
  &\text{On the other hand}&\\
  &\ast_{B, A} \circ [q, \langle \pi_1 q, {\bf pure \:} (\pi_2 q) \rangle] \circ [p, \langle \pi_2 p, \pi_1 p \rangle] = & \\
  &\text{By the definition of $\ast$}& \\
  &[r, {\bf let \: pure \:} y,x = \pi_1 r, \pi_2 r {\: \bf in \:} \langle y, x \rangle] \circ [q, \langle \pi_1 q, {\bf pure \:} (\pi_2 q) \rangle] \circ [p, \langle \pi_2 p, \pi_1 p \rangle] = & \\
  &\text{Composition}& \\
  &[r, {\bf let \: pure \:} y,x = \pi_1 r, \pi_2 r {\: \bf in \:} \langle y, x \rangle] \circ [p, \langle \pi_1 q, {\bf pure \:} (\pi_2 q) \rangle [q := \langle \pi_2 p, \pi_1 p  \rangle]] = & \\
  &\text{By subsitution and by  $\beta$-reduction rules}& \\
  &[r, {\bf let \: pure \:} y,x = \pi_1 r, \pi_2 r {\: \bf in \:} \langle y, x \rangle] \circ [p, \langle \pi_2 p, {\bf pure \:} (\pi_1 p) \rangle ]] = & \\
  &\text{Composition}& \\
  &[p, {\bf let \: pure \:} y,x = \pi_1 r, \pi_2 r {\: \bf in \:} \langle y, x \rangle [r := \langle \pi_2 p, {\bf pure \:} (\pi_1 p) \rangle]] = & \\
  &\text{By subsitution and by  $\beta$-reduction rules}& \\
  &[p, {\bf let \: pure \:} y,x = \pi_2 p, {\bf pure \:} (\pi_1 p) {\: \bf in \:} \langle y, x \rangle] = & \\
  &\text{By symmetricity of assingment}&\\
  &[p, {\bf let \: pure \:} x,y = {\bf pure \:} (\pi_1 p), \pi_2 p {\: \bf in \:} \langle y, x \rangle]&
  \end{array}$
\end{proof}

\begin{lemma}

  {\bf K} is an applicative functor
\end{lemma}

\begin{proof}
  Immediately follows from previous lemmas in the section.
\end{proof}

\end{proof}

  \addcontentsline{toc}{section}{References}

  %далее сам список используевой литературы
  \begin{thebibliography}{}

  \bibitem{Artemov} Artemov S. and Protopopescu T., \/ ``Intuitionistic Epistemic Logic'', \textit{The
  Review of Symbolic Logic}, 2016, vol. 9, no 2. pp. 266-298.\parskip=1mm

  \bibitem{Krupski} Krupski V. N. and Yatmanov A., \/ ``Sequent Calculus for Intuitionistic Epistemic Logic
  IEL'', \textit{Logical Foundations of Computer Science: International Symposium, LFCS 2016, Deerfield
  Beach, FL, USA, January 4-7, 2016. Proceedings}, 2016, pp. 187-201.\parskip=1mm

  \bibitem{Haskell} Haskell Language. // URL: https://www.haskell.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Idris} Idris. A Language with Dependent Types.// URL:https://www.idris-lang.org. (Date:
  1.08.2017) \parskip=1mm

  \bibitem{Purs} Purescript. A strongly-typed functional programming language that compiles to JavaScript.
  URL: http://www.purescript.org. (Date: 1.08.2017) \parskip=1mm

  \bibitem{Elm} Elm. A delightful language for reliable webapps. // URL: http://elm-lang.org. (Date:
  1.08.2017) \parskip=1mm

  \bibitem{Base} Hackage, \/ ``The base package'' // URL: https://hackage.haskell.org/package/base-4.10.0.0
  (Date: 1.08.2017) \parskip=1mm

  \bibitem{Miran} Lipovaca M, \/ ``Learn you a Haskell for Great Good!''. //URL:
  http://learnyouahaskell.com/chapters (Date: 1.08.2017) \parskip=1mm

  \bibitem{McP} McBride C. and Paterson R., ``Applicative programming with effects", \textit{Journal of
  Functional Programming}, 2008, vol. 18, no 01. pp 1-13. \parskip=1mm

  \bibitem{McP2} McBride C. and Paterson R, ``Functional Pearl. Idioms: applicative programming with
  effects'', \textit{Journal of Functional Programming}, 2005. vol. 18, no 01. pp 1-20. \parskip=1mm

  \bibitem{Neder} R. Nederpelt and H. Geuvers, ``Type Theory and Formal Proof: An Introduction''.
  \textit{Cambridge University Press}, New York, NY, USA, 2014. pp. 436. \parskip=1mm

  \bibitem{Morten} Sorensen M. H. and Urzyczyn P, ``Lectures on the Curry-Howard isomorphism'',
  \textit{Studies in Logic and the Foundations of Mathematics}, vol. 149, \textit{Elsevier Science}, 1998.
  pp 261. \parskip=1mm

  \bibitem{Pierce} Pierce B. C., ``Types and Programming Languages''. \textit{Cambridge, Mass: The MIT
  Press}, 2002. pp. 605. \parskip=1mm

  \bibitem{Girard} Girard J.-Y., Taylor P. and  Lafont Y, ``Proofs and Types'', \textit{Cambridge University
  Press}, New York, NY, USA, 1989. pp. 175. \parskip=1mm

  \bibitem{Baren} Barendregt. H. P., ``Lambda calculi with types" // Abramsky S., Gabbay Dov M., and S. E.
  Maibaum, ``Handbook of logic in computer science (vol. 2), Osborne Handbooks Of Logic In Computer
  Science'', Vol. 2. \textit{Oxford University Press, Inc.}, New York, NY, USA, 1993. pp 117-309.
  \parskip=1mm

  \bibitem{Hindley} Hindley J. Roger, ``Basic Simple Type Theory''. \textit{Cambridge University Press}, New
  York, NY, USA, 1997. pp. 185. \parskip=1mm

  \bibitem{Lax} Pfenning F. and Davies R., ``A judgmental reconstruction of modal logic'',
  \textit{Mathematical Structures in Computer Science}, vol. 11, no 4, 2001, pp. 511-540. \parskip=1mm

  \bibitem{Baren2} H.P. Barendregt. The Lambda Calculus --- Its Syntax and Semantics. Studies in Logic and
  the Foundations of Mathematics, vol. 103. Amsterdam: North-Holland, 1985.

  \bibitem{ModalK} Yoshihiko KAKUTANI, A Curry-Howard Correspondence for Intuitionistic Normal Modal Logic, Computer Software, Released February 29, 2008, Online ISSN , Print ISSN 0289-6540.

  \bibitem{ModalK1} Kakutani Y. (2007) Call-by-Name and Call-by-Value in Normal Modal Logic. In: Shao Z. (eds) Programming Languages and Systems. APLAS 2007. Lecture Notes in Computer Science, vol 4807. Springer, Berlin, Heidelberg

  \bibitem{Abe} T. Abe. Completeness of modal proofs in first-order predicate logic. Computer Software, JSSST Journal, 24:165 -- 177, 2007.

  \bibitem{LambekScott} Lambek, J. and Scott P.J. (1986) Introduction to Higher Order Categorical Logic, Cambridge Studies in Advanced Mathematics 7, Cambridge: Cambridge University Press.

  \bibitem{ElKelly} Samuel Eilenberg and Max Kelly, Closed categories. Proc. Conf. Categorical Algebra (La Jolla, Calif., 1965).

\end{thebibliography}

\end{document}
