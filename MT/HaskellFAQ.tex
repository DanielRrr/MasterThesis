\subsection{Глоссарий по основным конструкциям функционального языка программирования Haskell: функторы и аппликативные функторы}

\begin{defin} Класс типов

  Классом типов в языке Haskell -- это реализация некоторого общего интерфейса для некоторой совокупности типов.

  Представителем класса типов называется реализация данного класса для конкретного типа.
\end{defin}

\begin{defin} Функтор

  Функтор -- это однопараметрический класс типов, позволяющий пронести действие одноместной функции через значения,
  полученные в результате применения к их типу одноместного типового оператора.
\end{defin}

Определение в стандартной библиотеке выглядит следующим образом:

\begin{lstlisting}[language=Haskell]
  class Functor f where
    fmap :: (a -> b) -> f a -> f b
\end{lstlisting}

Рассмотрим примеры:

\begin{itemize}
  \item Список (неограниченная в длине последовательность) является функтором:

  \begin{lstlisting}[language=Haskell]
    instance Functor [] where
      fmap :: (a -> b) -> [a] -> [b]
      fmap f [] = []
      fmap f (x:xs) = (f x) : (fmap f xs)
  \end{lstlisting}

  Данный пример достаточно прост: реализация функтора для списка -- это функция высшего порядка, которая,
  принимая на входе одноместную функцию из типа $a$ в тип $b$ и список элементов типа $a$, возвращает список элементов типа $b$, который
  получен применением функции к каждому элементу списка, полученного на вход.

  Пример использования:

\begin{lstlisting}[language=Haskell]
  > fmap succ ''bg`lo`fmd\USrtodqmnu`''
  ''champagne supernova''
\end{lstlisting}

В данном примере мы отобразили функцию ``следующий за''
\footnote{В языке Haskell функция ``следующий за'' определения для
любого типа, между элементами которого есть линейный порядок,
в частности, лексиграфический порядок на символах, вводимых с клавиатуры компьютера}
на строчку, указанную выше. Строка в языка Haskell -- это частный случай списка, списка символов.
Тогда \verb"fmap" применяет функцию \verb"succ" к каждой букве строки, возвращая в результате
строку со словосочетанием ``champagne supernova''.

  \item Пара (тип декартова произведения типов) также функтор:
  \begin{lstlisting}[language=Haskell]
  instance Functor (b,) where
    fmap :: (a -> c) -> (b,a) -> (b,c)
    fmap f (x,y) = (x, f y)
  \end{lstlisting}

  Конструктор пары является двухпараметрическим типовым оператором, но мы сделали из него однопараметрический оператор фиксацией первого параметра.

  Данная реализация также довольно проста: на вход принимается функция из типа $a$ в тип $c$ и кортеж, в котором первая координата имеет тип $b$, а вторая -- тип $a$.
  На выходе мы получаем кортеж типа $(b,c)$, применяя полученную на вход функцию ко второй координате пары.

  \item Тип $Maybe$ -- это однопараметрический типовой оператор, для обработки неопределенных значений, иными словами тип $Maybe$ доопределяет
  частично-определенную функцию до тотальной:
  \begin{lstlisting}[language=Haskell]
    data Maybe a = Nothing | Just a
  \end{lstlisting}

  Реализация функтора для типа $Maybe$:
  \begin{lstlisting}[language=Haskell]
    instance Functor Maybe where
      fmap :: (a -> b) -> Maybe a -> Maybe b
      fmap f Nothing = Nothing
      fmap f (Just x) = Just (f x)
  \end{lstlisting}

  Если второй аргумент является неопределенным значением (на вход передан $Nothing$), то и возвращается $Nothing$. Если же значение определено, то есть оно имеет вид $Just \: x$, тогда
  мы применяем функцию функцию к $x$, а результат вычисления оборачиваем в конструктор $Just$.
\end{itemize}

\begin{defin} Аппликативный функтор

  Аппликативным функтором называется класс типов, обобщающий функтор для функций произвольной арности.
\end{defin}

Определение класса в языке Haskell:

\begin{lstlisting}[language=Haskell]
  class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{lstlisting}

Обобщение действия функтора с помощью методой класса \verb"Applicative" для произвольной функции:
\begin{lstlisting}[language=Haskell]
  liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  liftA2 g x y = pure g <*> x <*> y
\end{lstlisting}

Данный комбинатор берет функцию, которая по объектам из типов $a$ и $b$ сопоставляет объект типа $c$ и,
по аргументам $x$ и $y$ типов соответственно $f \: a$ и $f \: b$, полученных в результате применения к данным типов функтора $f$,
возвращает объект типа $f \: c$, тип которого также получен в результате применения функтора к типу $f \: c$.

Рассмотрим реализацию данной функции детальнее. Имея функцию $g$ типа \verb"a -> b -> c", мы
применяет к ней \verb"pure", получая в результате объект \verb"pure g" типа \verb"f (a -> b -> c)",
иными словами, мы подняли функцию $g$ на уровень функтора $f$.

Далее мы применяем поднятую функцию $f$ к аргументу $x$ типа $f \: a$ с использованием \verb"(<*>)"
и получаем объект \verb"pure g <*> x" типа \verb"f (b -> c)", получив одноместную функцию из \verb"b" в \verb"c".
Затем мы \verb"pure g <*> x" применяем к аргументу $y$ типа $f \: b$ опять же с использованием
\verb"(<*>)" и получаем объект типа $f \: c$.

Рассмотрим примеры представителей класса типов \verb"Applicative":

\begin{itemize}
  \item Списки
  \begin{lstlisting}[language=Haskell]
    instance Applicative [] where
      pure x = [x]
      fs <*> xs = [ f x | f <- fs , x <- xs]
  \end{lstlisting}

  Метод \verb"pure" для списков переводит объект $x$ произвольного типа $a$ в
  одноэлементный список $[x]$. Метод \verb"(<*>)" в качестве левого операдна
  принимает список функций и список аргументов -- в качестве правого и возващает
  список всевозможных применений элементов первого списка к элементам второго списка.
  Нотация здесь является калькой с теоретико-множественной нотации, которая могла бы иметь
  следующий вид $\{ f(x) \: | \: f \in B^A \land x \in A \}$.
  \item Пары
  \begin{lstlisting}[language=Haskell]
  instance Monoid a => Applicative ((,) a) where
      pure x = (mempty, x)
      (u, f) <*> (v, x) = (u <> v, f x)
  \end{lstlisting}

  Чтобы пару сделать аппликативным функтором, необходимо соблюсти следующее ограничение:
  тип первой координаты должен быть моноидом \footnote{То есть тип должен содержать нейтральный и бинарную ассоциативную операцию.
  Моноид в языке Haskell также является классом типов, который, как видно из названия, является калькой с одноименной структуры в алгебре.}.

  Метод \verb"pure" переводит объект $x$ произвольного типа $b$ в упорядоченную пару, первый элемент которой единица моноида $a$,
  а второй -- $x$, полученный при входе. Метод \verb"(<*>)" принимает две пары: первая пара -- это пара элемента $u$ моноида и некоторой функции $f$,
  вторая пара состоит из другого элемента $v$ моноида и аргумента $x$. Возвращаемый результат:
  соединение элементво $u$ и $v$ с помощью моноидной операции в первой координате, а во второй координате -- применение функции $f$ к аргументу $x$.

  Пример использования:
  \begin{lstlisting}[language=Haskell]
  > (''(what's the story) '' , succ) <*> (''morning glory?'' , 1994)
  (''(what's the story) morning glory?'',1995)
  \end{lstlisting}
  где \verb"succ" -- функция ``следующий за''.

  \item Тип Maybe
  \begin{lstlisting}[language=Haskell]
    instance Applicative Maybe where
      pure = Just
      Just f <*> m = fmap f m
      Nothing <*> _m = Nothing
  \end{lstlisting}

  В данной реализации представителя, \verb"pure" просто оборачивает значение типа произольно типа $a$ в $Just$,
  создавая таким образом объект типа \verb"Maybe a". Метод \verb"(<*>)" принимает функцию типа \verb"Maybe (a -> b)" и
  аргумент типа \verb"Maybe a". Если аргументы, переданные \verb"(<*>)", имеют вид $\verb"Just f"$ и $\verb"Just m"$,
  где $f$ и $m$ -- это объекты типов \verb"a -> b" и \verb"a" соответственно, тогда происходит применение функции $f$
  к аргументу $m$ внутри \verb"Just" и возвращаемое значение в таком случае имеет вид \verb"Just (f m)".
  В остальных случаях возвращается \verb"Nothing".

  Пример использования:
  \begin{lstlisting}[language=Haskell]
  > liftA2 (++) (Just "Definitely") Nothing
  Nothing

  > liftA2 (++) (Just ''Definitely '') (Just "Maybe")
  Just ''Definitely Maybe''
  \end{lstlisting}

Данный пример как раз является примером того, как действие функтора обобщается на функций многих аргументов,
в данном случае, двух аргументов. Здесь функцией двух аргументов является функция $(++)$, конкатенация строк.

В первом случае определен только первый аргумент, строка \verb"Definitely", обернутая в \verb"Just",
второй же аргумент является неопределенным (так как в качестве второго аргумента передан \verb"Nothing"),
поэтому данная попытка конкатенации строк также вернет \verb"Nothing".

Во втором примере, второй аргумент определен, это строка \verb"Maybe", обернутая в \verb"Just".
Тогда конкатенация пройдет успешно и \verb"liftA2" пронесет комбинатор $(++)$ и совершит конкатенацию строк
\verb"Definitely" и \verb"Maybe" внутри \verb"Just", и на выходе будет возвращена строка \verb"Definitely Maybe",
к которой применен \verb"Just".
\end{itemize}
